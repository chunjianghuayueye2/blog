<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>春江花月夜o</title>
  
  <subtitle>既自以心为形役，奚惆怅而独悲。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-22T08:47:35.234Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>durian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>安装配置</title>
    <link href="http://example.com/2021/06/22/rabbitmq/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2021/06/22/rabbitmq/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</id>
    <published>2021-06-22T06:48:05.782Z</published>
    <updated>2021-06-22T08:47:35.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a href="https://blog.csdn.net/qq_39669058/article/details/102568451">安装</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">yum -y update</span><br><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install erlang socat</span><br><span class="line">erl -version</span><br><span class="line"></span><br><span class="line">erlang手动安装</span><br><span class="line"># centos内置erlang版本过低手动下载</span><br><span class="line">wget http:&#x2F;&#x2F;erlang.org&#x2F;download&#x2F;otp_src_21.3.tar.gz</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;erlang --with-ssl --enable-threads --enable-smp-support --enable-kernel-poll --enable-hipe --without-javac</span><br><span class="line"></span><br><span class="line">erlang语言编译配置选项：</span><br><span class="line"></span><br><span class="line">–prefix 指定安装目录 </span><br><span class="line"></span><br><span class="line">–enable-smp-support启用对称多处理支持（Symmetric Multi-Processing对称多处理结构的简称）</span><br><span class="line"></span><br><span class="line">–enable-threads启用异步线程支持</span><br><span class="line"></span><br><span class="line">–enable-sctp启用流控制协议支持（Stream Control Transmission Protocol，流控制传输协议）</span><br><span class="line"></span><br><span class="line">–enable-kernel-poll启用Linux内核poll</span><br><span class="line"></span><br><span class="line">–enable-hipe启用高性能Erlang</span><br><span class="line"></span><br><span class="line">–with-ssl 启用ssl包</span><br><span class="line"></span><br><span class="line">–without-javac 不用java编译</span><br><span class="line"></span><br><span class="line">编译安装</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">配置Erlang的环境变量</span><br><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;erlang&#x2F;bin</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line">测试Erlang安装是否成功，输入erl，查看版本信息</span><br><span class="line">测试输入hello.，在控制台上看到输入hello,之后退出输入halt().，Erlang环境安装完毕</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># rabbitmq安装</span><br><span class="line">rpm --import https:&#x2F;&#x2F;packagecloud.io&#x2F;rabbitmq&#x2F;rabbitmq-server&#x2F;gpgkey</span><br><span class="line">rpm --import https:&#x2F;&#x2F;packagecloud.io&#x2F;gpg.key</span><br><span class="line"></span><br><span class="line">curl -s https:&#x2F;&#x2F;packagecloud.io&#x2F;install&#x2F;repositories&#x2F;rabbitmq&#x2F;</span><br><span class="line">rabbitmq-server&#x2F;script.rpm.sh | sudo bash</span><br><span class="line"></span><br><span class="line">wget</span><br><span class="line">centOS7：</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;rabbitmq-server&#x2F;releases&#x2F;download&#x2F;v3.8.5</span><br><span class="line">&#x2F;rabbitmq-server-3.8.5-1.el7.noarch.rpm</span><br><span class="line">CentOS8:</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rabbitmq&#x2F;rabbitmq-server&#x2F;releases&#x2F;download&#x2F;v3.8.5</span><br><span class="line">&#x2F;rabbitmq-server-3.8.5-1.el8.noarch.rpm</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/qq_39669058/article/details/102568451&quot;&gt;安装&lt;/a&gt;&lt;/h2</summary>
      
    
    
    
    <category term="bigdata" scheme="http://example.com/categories/bigdata/"/>
    
    <category term="rabbitmq" scheme="http://example.com/categories/bigdata/rabbitmq/"/>
    
    
  </entry>
  
  <entry>
    <title>socket</title>
    <link href="http://example.com/2021/06/18/python/socket/"/>
    <id>http://example.com/2021/06/18/python/socket/</id>
    <published>2021-06-18T01:03:51.525Z</published>
    <updated>2021-06-16T06:52:30.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ip地址分类"><a href="#Ip地址分类" class="headerlink" title="Ip地址分类"></a>Ip地址分类</h2><p>Ip地址由网络地址和主机地址组成分为5类：</p><ul><li><p>1.A类IP地址<br>一个A类IP地址由1字节的网络地址和3字节主机地址组成，<br>网络地址的最高位必须是“0”（位运算）， 地址范围从1.0.0.0 到126.0.0.0。<br>可用的A类网络有126个，每个网络能容纳1千多万个主机。</p></li><li><p>2.B类IP地址<br>一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，<br>网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255。<br>可用的B类网络有16382个，每个网络能容纳6万多个主机 。</p></li><li><p>3.C类IP地址<br>一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的<br>最高位必须是“110”。范围从192.0.0.0到223.255.255.255。C类网络<br>可达209万余个，每个网络能容纳254个主机。</p></li><li><p>4.D类地址用于多点广播（Multicast）。<br>D类IP地址第一个字节以“lll0”开始，它是一个专门保留的地址。<br>它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。<br>多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。</p></li><li><p>5.E类IP地址<br>以“llll0”开始，为将来使用保留。<br>全零（“0．0．0．0”）地址对应于当前主机。全“1”的<br>IP地址（“255．255．255．255”）是当前子网的广播地址。<br>在IP地址3种主要类型里，各保留了3个区域作为私有地址，<br>其地址范围如下：<br>A类地址：10.0.0.0～10.255.255.255 </p></li></ul><h2 id="私有网络"><a href="#私有网络" class="headerlink" title="私有网络"></a>私有网络</h2><ul><li>iPv4地址枯竭为何还能支撑？<br>这就要说起NAT(Network Address Translation)网络地址转换技术<br>当我们在家或者在公司上网时，你的电脑肯定有一个类似192.168.0.1的地址，<br>这种地址属于私网地址，不属于公共互联网地址，每一个小的局域网都会使用<br>一个网段的私网地址，在与外界联系时变成公网，这样几十台上百台电脑只需<br>要一个公网地址。甚至还能私网套私网NAT套NAT一层一层，节约公网ip数量<br>但是NAT也有很多限制：私网访问公网虽然方便，但是公网访问私网就很困难，<br>很多服务受到限制，也影响了网络处理的效率。</li></ul><p><strong>具体百度iPv4和ipv6</strong></p><ul><li>私有ip<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.0 – 10.255.255.255</span><br><span class="line">172.16.0.0 – 172.31.255.255</span><br><span class="line">192.168.0.0 – 192.168.255.255</span><br></pre></td></tr></table></figure></li></ul><h2 id="Port端口"><a href="#Port端口" class="headerlink" title="Port端口"></a>Port端口</h2><p>当你发送一段信息给别的电脑ip时，你这段信息主要是要访问别的电脑的哪个进程呢？如何确定是哪个进程呢？<br>当进程运行时，会告诉自身电脑给它的信息要从哪个端口传入，如：7788,7890等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dest ip:192.168.1.2</span><br><span class="line">Src ip:192.168.1.3</span><br><span class="line">Dest port:7788</span><br><span class="line">Src port:4567</span><br><span class="line">Content:你好</span><br></pre></td></tr></table></figure><ul><li><p>端口号<br>0到2^16（65535）</p></li><li><p>知名端口号 不能随便用<br>0到1023<br>80端口分配给HTTP<br>21端口分配给FTP</p></li><li><p>大于1024随便用<br>动态端口 Dynamic ports<br>1024到65535</p></li></ul><h2 id="Socket简介"><a href="#Socket简介" class="headerlink" title="Socket简介"></a>Socket简介</h2><p>socket是网络通信的必须物，Socket是应用层<br>与TCP/IP协议族通信的中间软件抽象层，它是一组接口。<br>在设计模式中，Socket其实就是一个门面模式，它把复<br>杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，<br>一组简单的接口就是全部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"># ipv4协议 </span><br><span class="line">创建tcp连接</span><br><span class="line"># s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"># udp连接</span><br><span class="line">s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"># 可以使用套接字收发数据</span><br><span class="line">#关闭套接字</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><ul><li>ubuntu和windows通讯<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim缩进：shift V选择，v缩退 &gt;缩进</span><br><span class="line">ctrl n补全</span><br><span class="line">如果要实现ubuntu和我们windows的通讯</span><br><span class="line">如ip：172.154.2.12和192.168.33.23的通讯</span><br><span class="line">改成桥接模式，sudo dhclient等待分配ip</span><br><span class="line">然后ip会自动变为和另一个ip同一个网段</span><br><span class="line">ping 192.168.33.53</span><br><span class="line">10.167.2.111</span><br></pre></td></tr></table></figure></li></ul><h2 id="socket简单使用"><a href="#socket简单使用" class="headerlink" title="socket简单使用"></a>socket简单使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"># ipv4协议 </span><br><span class="line">创建tcp连接</span><br><span class="line"># s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"># udp连接</span><br><span class="line">s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">while True:</span><br><span class="line">    # 键盘获取数据</span><br><span class="line">    data &#x3D; input(&quot;请输入你要发送的数据: &quot;)</span><br><span class="line">    if data &#x3D;&#x3D; &#39;exit&#39;:</span><br><span class="line">        break</span><br><span class="line">    # 可以使用套接字收发数据</span><br><span class="line">    s.sendto(data.encode(&#39;utf-8&#39;), (&#39;10.167.2.90&#39;, 8080))</span><br><span class="line">#关闭套接字</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><ul><li><p>想要一个程序有一个固定的端口接收数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from socket import *</span><br><span class="line">s &#x3D; socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">local_addr &#x3D; (&#39;&#39;, 7788)</span><br><span class="line">s.bind(local_addr)</span><br><span class="line">recv_data &#x3D; s.recvfrom(1024)</span><br><span class="line">print(recv_data)</span><br><span class="line">print(recv_data[0].decode(&#39;utf-8&#39;))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure></li><li><p>绑定发送数据端口<br>不绑定端口会随机端口分配！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">s.bind((&#39;&#39;, 8080))</span><br></pre></td></tr></table></figure></li></ul><h2 id="udp聊天器"><a href="#udp聊天器" class="headerlink" title="udp聊天器"></a>udp聊天器</h2><ul><li>单工：收音机只能收不能发，只能单向</li><li>半双工：对讲机，我在收的时候发不了，发的时候收不了，同一时刻单向</li><li>全双工：手机，同一时刻既可以发，也可以收</li></ul><p>socket套接字是全双工 但现在没有多进程线程或协程的情况下，是半双工</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">def send_msg(s):</span><br><span class="line">    &quot;&quot;&quot; 发送消息&quot;&quot;&quot;</span><br><span class="line">    dest_ip &#x3D; input(&#39;请输入对方的ip：&#39;)</span><br><span class="line">    dest_port &#x3D; int(input(&quot;请输入对方的port:&quot;))</span><br><span class="line">    send_data &#x3D; input(&quot;请输入要发送的消息：&quot;)</span><br><span class="line">    s.sendto(send_data.encode(&#39;utf-8&#39;), (dest_ip,dest_port ))</span><br><span class="line">    </span><br><span class="line">def recv_msg(s):</span><br><span class="line">    &quot;&quot;&quot; 接收数据&quot;&quot;&quot;</span><br><span class="line">     # 接收并显示</span><br><span class="line">    recv_data &#x3D; s.recv_from(1024)</span><br><span class="line">    print(&quot;%s : %s&quot; % (str(recv_data[1]), recv_data[0].decode(&#39;utf-8&#39;)</span><br><span class="line">    </span><br><span class="line">def main():</span><br><span class="line">    s &#x3D; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    # 绑定ip 端口</span><br><span class="line">    s.bind((&quot;&quot;, 7788))</span><br><span class="line">    while True:</span><br><span class="line">        # 发送</span><br><span class="line">        send_msg(s) </span><br><span class="line">        # 接收数据</span><br><span class="line">        recv_msg(s)</span><br><span class="line">if __name __ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="TCP通信模型"><a href="#TCP通信模型" class="headerlink" title="TCP通信模型"></a>TCP通信模型</h2><ul><li><p>udp通信模型<br>在通信开始前，不需要建立相关连接，<br>只需要发送数据即可，类似于生活中写信<br>udp发的消息可能丢失，不安全，简单   </p></li><li><p>tcp类似于打电话，稳定，面向连接</p></li></ul><h3 id="tcp模型简介"><a href="#tcp模型简介" class="headerlink" title="tcp模型简介"></a>tcp模型简介</h3><ul><li><p>1.通信双方必须先建立连接</p><ul><li>1.创建连接</li><li>2.数据传送</li><li>3.终止连接</li></ul></li><li><p>2.发送应答机制：<br>当主机发送数据之后，接收方会告诉主机是否接收到数据，（没收到会显示超时上传）<br>网购都是tcp，qq：tcp，抢票tcp。保证数据可靠</p></li><li><p>3.tcp严格区分服务器和客户端</p></li></ul><h3 id="tcp客户端构建流程"><a href="#tcp客户端构建流程" class="headerlink" title="tcp客户端构建流程"></a>tcp客户端构建流程</h3><ul><li>1.创建套接字</li><li>2.目的信息</li><li>3.链接服务器 多了这个</li><li>4.显示用户输入数据</li><li>5.接收对方发来数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">def main():</span><br><span class="line">    # 1.创建tcp套接字</span><br><span class="line">    tcp_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    # 2.链接服务器</span><br><span class="line">    server_ip &#x3D; input(&#39;请输入服务器的ip：&#39;)</span><br><span class="line">    server_port &#x3D; int(input(&quot;请输入服务器的port:&quot;))</span><br><span class="line">    server_addr &#x3D; (server_ip, server_port)</span><br><span class="line">    tcp_socket.connect(server_addr)</span><br><span class="line">    # 3.发送&#x2F;接收数据</span><br><span class="line">    send_data &#x3D; input(&#39;请输入要发送的数据:&#39;)</span><br><span class="line">    tcp_socket.send(send_data.encode(&#39;utf-8&#39;))</span><br><span class="line">    # 4.关闭套接字</span><br><span class="line">    tcp_socket.close()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><h3 id="tcp服务器创建流程"><a href="#tcp服务器创建流程" class="headerlink" title="tcp服务器创建流程"></a>tcp服务器创建流程</h3><ul><li>1.套接字</li><li>2.ip port</li><li>3.listen使套接字变为可以被动链接</li><li>4.accept等待客户端的链接</li><li>5.recv/send接收发送的数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"># tcp服务器端</span><br><span class="line">def main():</span><br><span class="line">    # 1.买个手机（创建套接字）</span><br><span class="line">    tcp_server_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    </span><br><span class="line">    # 2.拆入手机卡（绑定本地信息）</span><br><span class="line">    tcp_server_socket.bind((&quot;&quot;, 7890) )</span><br><span class="line">    </span><br><span class="line">    # 3.将手机设置为响铃（让默认套接字由主动变为被动）</span><br><span class="line">    tcp_server_socket.listen(128)</span><br><span class="line">    while True:</span><br><span class="line">        # 4.等待电话到来（等待客户端链接 accept）</span><br><span class="line">        print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">        client_socket, client_addr &#x3D; tcp_server_socket.accept()</span><br><span class="line">        print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">        print(&quot;一个新的客户端已经到来%s&quot; % str(client_addr))</span><br><span class="line">        while True:</span><br><span class="line">            #接收客户端发送的数据</span><br><span class="line">            try:</span><br><span class="line">                recv_data &#x3D; client_socket.recv(1024)</span><br><span class="line">            except:</span><br><span class="line">                break</span><br><span class="line">            # 客户端调用close或者发出退出信息</span><br><span class="line">            if str(recv_data.decode(&#39;utf-8&#39;)) &#x3D;&#x3D; &#39;退出&#39; or not recv_data:</span><br><span class="line">                break</span><br><span class="line">            print(&quot;客户端发送过来的请求是%s&quot; % str(recv_data.decode(&#39;utf-8&#39;)))</span><br><span class="line">            # 回送一部分数据给客户端</span><br><span class="line">            client_socket.send(&quot;shadiao&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;OK&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;shadiao&quot;.encode(&#39;utf-8&#39;))</span><br><span class="line"></span><br><span class="line">        # 关闭套接字</span><br><span class="line">        client_socket.close()</span><br><span class="line">        print(&#39;服务完毕&#39;)</span><br><span class="line">    tcp_server_socket.close()</span><br><span class="line">    </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><h3 id="TCP文件下载器"><a href="#TCP文件下载器" class="headerlink" title="TCP文件下载器"></a>TCP文件下载器</h3><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">def send_file_2_client(client_addr, client_socket):</span><br><span class="line">    while True:</span><br><span class="line">        # 接收客户端需要的文件名</span><br><span class="line">        try:</span><br><span class="line">            file_name &#x3D; client_socket.recv(1024)</span><br><span class="line">        except:</span><br><span class="line">            break</span><br><span class="line">        # 客户端调用close或者发出退出信息</span><br><span class="line">        if str(file_name.decode(&#39;utf-8&#39;)) &#x3D;&#x3D; &#39;退出&#39; or not file_name:</span><br><span class="line">            break</span><br><span class="line">        print(&quot;客户端(%s)需要的文件是:%s&quot; % (str(client_addr), </span><br><span class="line">        str(file_name.decode(&#39;utf-8&#39;))))</span><br><span class="line">        # 打开文件读取数据</span><br><span class="line">        file_content &#x3D; None</span><br><span class="line">        try:</span><br><span class="line">            f &#x3D; open(file_name, &#39;rb&#39;)</span><br><span class="line">            file_content &#x3D; f.read()</span><br><span class="line">            f.close()</span><br><span class="line">        except Exception as ret:</span><br><span class="line">            print(&quot;没有要下载的文件(%s)&quot; % file_name)</span><br><span class="line">        if file_content:</span><br><span class="line">            # 发送对应的数据给客户端</span><br><span class="line">            client_socket.send(file_content)</span><br><span class="line">            </span><br><span class="line">def main():</span><br><span class="line">    # 1.买个手机（创建套接字）</span><br><span class="line">    tcp_server_socket &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    </span><br><span class="line">    # 2.拆入手机卡（绑定本地信息）</span><br><span class="line">    tcp_server_socket.bind((&quot;&quot;, 7890) )</span><br><span class="line">    </span><br><span class="line">    # 3.将手机设置为响铃（让默认套接字由主动变为被动）</span><br><span class="line">    tcp_server_socket.listen(128)</span><br><span class="line">    while True:</span><br><span class="line">    # 4.等待电话到来（等待客户端链接 accept）</span><br><span class="line">        print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">        client_socket, client_addr &#x3D; tcp_server_socket.accept()</span><br><span class="line">        print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">        print(&quot;一个新的客户端已经到来%s&quot; % str(client_addr))</span><br><span class="line">        #调用发送文件函数为客户端服务</span><br><span class="line">        send_file_2_client(client_addr, client_socket)</span><br><span class="line">        # 关闭套接字</span><br><span class="line">        client_socket.close()</span><br><span class="line">    print(&#39;服务完毕&#39;)</span><br><span class="line">    tcp_server_socket.close()</span><br><span class="line">    </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from socket import *</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    tcp_client_socket &#x3D; socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    server_ip &#x3D; input(&quot;请输入服务器ip:&quot;)</span><br><span class="line">    server_port &#x3D; int(input(&quot;请输入服务器port:&quot;))</span><br><span class="line"></span><br><span class="line">    tcp_client_socket.connect((server_ip, server_port))</span><br><span class="line"></span><br><span class="line">    file_name &#x3D; input(&quot;请输入要下载的文件名:&quot;)</span><br><span class="line"></span><br><span class="line">    tcp_client_socket.send(file_name.encode(&quot;utf-8&quot;))</span><br><span class="line"></span><br><span class="line">    recv_data &#x3D; tcp_client_socket.recv(1024)</span><br><span class="line">    if recv_data:</span><br><span class="line">        with open(&quot;[接收]&quot; + file_name, &quot;wb&quot;) as f:</span><br><span class="line">            f.write(recv_data)</span><br><span class="line"></span><br><span class="line">    tcp_client_socket.close()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="简单TCP文件上传器"><a href="#简单TCP文件上传器" class="headerlink" title="简单TCP文件上传器"></a>简单TCP文件上传器</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line">client &#x3D; socket.socket()</span><br><span class="line">client.connect((&#39;localhost&#39;, 9999))</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    cmd &#x3D; input(&#39;file name &lt;&lt;:&#39;)</span><br><span class="line">    if len(cmd) &#x3D;&#x3D; 0:</span><br><span class="line">        continue</span><br><span class="line">    client.send(cmd.encode(&#39;utf-8&#39;))</span><br><span class="line">    server_size &#x3D; client.recv(1024).decode()</span><br><span class="line">    file_size &#x3D; 0</span><br><span class="line">    if server_size !&#x3D; &#39;0&#39;:</span><br><span class="line">        f &#x3D; open(&#39;2&#39;+cmd , &#39;wb&#39;)</span><br><span class="line">        while file_size &lt; int(server_size) :</span><br><span class="line">            print(file_size, server_size)</span><br><span class="line">            data &#x3D; client.recv(1024)</span><br><span class="line">            if data:</span><br><span class="line">                file_size +&#x3D; len(data)</span><br><span class="line">                f.write(data)</span><br><span class="line">            else:</span><br><span class="line">                print(&#39;err&#39;)</span><br><span class="line">                continue</span><br><span class="line">            # print(data)</span><br><span class="line">        f.close()</span><br><span class="line">        print(&#39;file over&#39;)</span><br></pre></td></tr></table></figure><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import errno</span><br><span class="line">import selectors</span><br><span class="line">import socket</span><br><span class="line">import os, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def accept(sock, mask):</span><br><span class="line">    conn, addr &#x3D; sock.accept()</span><br><span class="line">    conn.setblocking(False)</span><br><span class="line">    sel.register(conn, selectors.EVENT_READ, read)</span><br><span class="line"></span><br><span class="line">def read(conn, mask):</span><br><span class="line">    file_name &#x3D; conn.recv(1024).decode()</span><br><span class="line">    if os.path.isfile(file_name):</span><br><span class="line">        file_size &#x3D; os.stat(file_name).st_size</span><br><span class="line">        conn.send(str(file_size).encode(&#39;utf-8&#39;))</span><br><span class="line">        print(file_size)</span><br><span class="line">        # print(conn.recv(1024))</span><br><span class="line">        with open(file_name, &#39;rb&#39;) as f:</span><br><span class="line">            for line in f:</span><br><span class="line">                if line !&#x3D; &#39;&#39;:</span><br><span class="line">                    print(line)</span><br><span class="line">                    conn.send(line)</span><br><span class="line">            print(&#39;over&#39;)</span><br><span class="line">    else:</span><br><span class="line">        conn.send(b&#39;0&#39;)</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    sel &#x3D; selectors.DefaultSelector()</span><br><span class="line">    sock &#x3D; socket.socket()</span><br><span class="line">    sock.bind((&#39;localhost&#39;, 9999))</span><br><span class="line">    sock.listen()</span><br><span class="line">    sock.setblocking(False)</span><br><span class="line">    sel.register(sock, selectors.EVENT_READ, accept)</span><br><span class="line">    while True:</span><br><span class="line">        events &#x3D; sel.select()</span><br><span class="line">        for key, mask in events:</span><br><span class="line">            callaback &#x3D; key.data</span><br><span class="line">            callaback(key.fileobj, mask)</span><br></pre></td></tr></table></figure><h3 id="TCP注意点"><a href="#TCP注意点" class="headerlink" title="TCP注意点"></a>TCP注意点</h3><ul><li>1.tcp服务器一般情况下都需要绑定：否则客户端找不到服务器</li><li>2.客户端为什么不绑定？因为是主动连接服务器，所以只要确定<br>服务器ip，port信息就行，本地客户端随机就行，还可以多开</li><li>3.tcp通过lisent将套接字socket由主动变为被动，这是tcp服务<br>器必须要做的</li><li>4.当客户端需要链接服务器是，需要使用connect进行链接，而udp<br>不需要，tcp只要有链接成功才能通信</li><li>5.当tcp客户端链接服务器后，服务器会用一个新的套接字来标记客<br>户端，单独为此客户服务</li><li>6.listen后的套接字是被动套接字，专门用来接收客户端的链接请求，<br>而accept返回的新的套接字是标记这个客户端的服务</li><li>7.关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户<br>端不能够链接服务器，但是之前链接成功的可以正常通信</li><li>8.关闭accept这个套接字意味着这个客户端服务完毕</li><li>9.当客户端套接字close，服务器端会recv解阻塞，并且返回recv长<br>度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>没有多任务就不能同时执行，单核cpu的时间片轮转<br>单核cpu只能同一时间执行一个任务，但只要够快，就像多线程一样</p><ul><li><p>并行：真的多任务</p></li><li><p>并发：假的多任务<br>任务数多于cpu的核数，就是并发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threading</span><br><span class="line">threading.enumerate()查看线程</span><br></pre></td></tr></table></figure><h3 id="两种方法调用线程"><a href="#两种方法调用线程" class="headerlink" title="两种方法调用线程"></a>两种方法调用线程</h3></li><li><p>1．直接调用函数名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1 &#x3D; treading.Thread(target&#x3D;sing)</span><br><span class="line">t1.start（）</span><br></pre></td></tr></table></figure></li><li><p>2.创建类继承thread</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MyThread(threading.Thread): 必须继承threading</span><br><span class="line">def run(self):必须有run方法</span><br><span class="line">&#x2F;…..</span><br><span class="line">t &#x3D; MyThread()</span><br><span class="line">t.start()这个start自动调用run</span><br><span class="line">多线程共享全局变量</span><br><span class="line">！！全局变量不一定要加global</span><br><span class="line">全局变量改了地址指向，需要global</span><br><span class="line">若[1, 2]列表append，指向地址未变，不需要global</span><br><span class="line">[1, 2] + [100, 200] 就变了</span><br><span class="line">指向地址变化用global，仅仅修改了指向空间中的数据</span><br><span class="line">不用global</span><br><span class="line"></span><br><span class="line">t1 &#x3D; treading.Thread(target&#x3D;sing， args&#x3D;(,))一定是一个元组</span><br><span class="line">target指定这个线程去哪个函数执行代码</span><br><span class="line">args指定调用函数的时候，传递什么数据过去</span><br></pre></td></tr></table></figure></li></ul><h3 id="共享变量问题"><a href="#共享变量问题" class="headerlink" title="共享变量问题"></a>共享变量问题</h3><p>大家都用同一个变量，资源竞争，比如两个线程同时写一个变量<br>如果出现资源竞争，就会出错</p><ul><li>线程在执行如g_num += 1时，会分为三步:<ul><li>1.获取g_num的值</li><li>2.把获取的值+1</li><li>3.把第二步的结果存储到g_num中<br>当线程同时调用，g_num都是一起加，还没开始存储</li></ul></li></ul><ul><li><p>如何解决共享变量资源竞争的问题</p><ul><li><p>原子性：<br>我做的时候你不做，要么做完，要么不做</p></li><li><p>同步协调：<br>就像走路，一左一右协调行走</p></li><li><p>互斥锁X：<br>当多个线程同时修改一个数据时，需要进行同步控制<br>某个线程进行修改共享数据时，先将其锁定，此时资源锁定状态，<br>其他线程不可修改，直到该线程释放资源，将资源的状态变为非锁定。</p></li></ul></li><li><p>锁方案一  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mutex &#x3D; threading.Lock()</span><br><span class="line">上锁</span><br><span class="line">mutex.acquire()</span><br><span class="line">释放锁</span><br><span class="line">mutex.release()</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">g_num &#x3D; 0</span><br><span class="line"></span><br><span class="line">def test1(num):</span><br><span class="line">    global g_num</span><br><span class="line">    # 上锁，若之前没上锁，上锁成功，若之前上锁了，会堵塞在这儿，直到这个锁被解开</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    for i in range(num):</span><br><span class="line">        g_num +&#x3D; 1</span><br><span class="line">    # 解锁</span><br><span class="line">    mutex.release()</span><br><span class="line">    print(&quot;-------------in test1 g_num&#x3D;%d------&quot; % g_num)</span><br><span class="line"></span><br><span class="line">def test2(num):</span><br><span class="line">    global g_num</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    for i in range(num):</span><br><span class="line">        g_num +&#x3D; 1</span><br><span class="line">    # 解锁</span><br><span class="line">    mutex.release()</span><br><span class="line">    print(&quot;-------------in test2 g_num&#x3D;%d------&quot; % g_num)</span><br><span class="line"></span><br><span class="line"># 创建一个互斥锁 默认未上锁</span><br><span class="line">mutex &#x3D; threading.Lock()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    t1 &#x3D; threading.Thread(target&#x3D;test1, args&#x3D;(1000000,))</span><br><span class="line">    t2 &#x3D; threading.Thread(target&#x3D;test2, args&#x3D;(1000000,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;-------------in main Thread g_num&#x3D;%d------&quot; % g_num)</span><br><span class="line">    </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li><li><p>锁方案二<br>上锁的代码越少越好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">g_num &#x3D; 0</span><br><span class="line"></span><br><span class="line">def test1(num):</span><br><span class="line">    global g_num</span><br><span class="line">    # 上锁，若之前没上锁，上锁成功，若之前上锁了，会堵塞在这儿，直到这个锁被解开</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    for i in range(num):</span><br><span class="line">        g_num +&#x3D; 1</span><br><span class="line">    # 解锁</span><br><span class="line">    mutex.release()</span><br><span class="line">    print(&quot;-------------in test1 g_num&#x3D;%d------&quot; % g_num)</span><br><span class="line"></span><br><span class="line">def test2(num):</span><br><span class="line">    global g_num</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    for i in range(num):</span><br><span class="line">        g_num +&#x3D; 1</span><br><span class="line">    # 解锁</span><br><span class="line">    mutex.release()</span><br><span class="line">    print(&quot;-------------in test2 g_num&#x3D;%d------&quot; % g_num)</span><br><span class="line"></span><br><span class="line"># 创建一个互斥锁 默认未上锁</span><br><span class="line">mutex &#x3D; threading.Lock()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    t1 &#x3D; threading.Thread(target&#x3D;test1, args&#x3D;(1000000,))</span><br><span class="line">    t2 &#x3D; threading.Thread(target&#x3D;test2, args&#x3D;(1000000,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&quot;-------------in main Thread g_num&#x3D;%d------&quot; % g_num)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><h4 id="互斥锁死锁问题"><a href="#互斥锁死锁问题" class="headerlink" title="互斥锁死锁问题"></a>互斥锁死锁问题</h4><p>如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。<br>如在线程A中acquireB 同时在B中acquireA就会出现死锁无法走动</p><ul><li><p>解决死锁：</p><ul><li>1.程序设计时尽量避免</li><li>2.添加超时时间</li></ul></li><li><p>银行家算法：<br>银行10单位，c1 9 c2 3 c3 8, 如何借款，先给c1 2, c2 2, c3 4<br>c2还钱 c3 4, c3还钱 c1 7</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Ip地址分类&quot;&gt;&lt;a href=&quot;#Ip地址分类&quot; class=&quot;headerlink&quot; title=&quot;Ip地址分类&quot;&gt;&lt;/a&gt;Ip地址分类&lt;/h2&gt;&lt;p&gt;Ip地址由网络地址和主机地址组成分为5类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.A类IP地址&lt;br&gt;一个A类</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="http://example.com/2021/06/18/python/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/06/18/python/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2021-06-18T01:03:51.525Z</published>
    <updated>2021-06-16T14:32:57.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>python中，lambda函数也叫匿名函数，及即<strong>没有具体名称的函数</strong>，<br>它允许快速定义单行函数，类似于C语言的宏，可以用在任何需要函<br>数的地方。这区别于def定义的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lambda x : x*x</span><br><span class="line">lambda x, y : x * x + y</span><br></pre></td></tr></table></figure><ul><li>lambda在运行一些小型的简单的函数时比较适用</li></ul><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map会把可迭代对象的每个元素e拿出来function(e),并存入结果作为返回</p><ul><li>公式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(function, iterable)</span><br></pre></td></tr></table></figure></li><li>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(list(map(lambda x:x*x, [1, 2, 3, 4, 5])))</span><br><span class="line">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure></li></ul><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>reduce函数将一个可迭代的对象转变成一个元素。最终获得一个数字</p><ul><li>公式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(function, iterable)</span><br></pre></td></tr></table></figure></li><li>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from functiontools import reduce</span><br><span class="line">print(reduce(lambda x, y : x * y, [1, 2, 3, 4, 5]))</span><br><span class="line">120</span><br></pre></td></tr></table></figure></li></ul><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter函数传入一个迭代对象作为参数并将<br>这个迭代对象当中所有那些你不要的东西滤去。</p><ul><li><p>公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(function, iterable)</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(list(filter(lambda x:x%2&#x3D;&#x3D;0, [1, 2, 3, 4, 5])))</span><br><span class="line">[2, 4]</span><br><span class="line">print(list(filter(lambda x:x&lt;0, [1, 2, 3, 4, 5, -1, -5]))</span><br><span class="line">[-1, -5]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lambda&quot;&gt;&lt;a href=&quot;#lambda&quot; class=&quot;headerlink&quot; title=&quot;lambda&quot;&gt;&lt;/a&gt;lambda&lt;/h2&gt;&lt;p&gt;python中，lambda函数也叫匿名函数，及即&lt;strong&gt;没有具体名称的函数&lt;/strong&gt;，&lt;b</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>tuple部分源码解析(cpython)</title>
    <link href="http://example.com/2021/06/18/python/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/tuple%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/18/python/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/tuple%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-18T01:03:51.525Z</published>
    <updated>2021-06-17T13:28:33.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PyTupleObject"><a href="#PyTupleObject" class="headerlink" title="PyTupleObject"></a>PyTupleObject</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    PyObject *ob_item[1];</span><br><span class="line">&#125; PyTupleObject;</span><br></pre></td></tr></table></figure><ul><li>1.PyObject_VAR_HEAD<br>PyTupleObject在底层是个变长对象(需要存储列表元素个数).<br>虽然, 在python中, tuple是不可变对象</li><li>2.PyObject*ob_item[1]指向存储元素的数组</li></ul><h2 id="tuple创建"><a href="#tuple创建" class="headerlink" title="tuple创建"></a>tuple创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyTuple_New(register Py_ssize_t size)</span><br><span class="line">&#123;</span><br><span class="line">    register PyTupleObject *op;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 大小为负数, return</span><br><span class="line">    if (size &lt; 0) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果大小&#x3D;0, 空元组, 直接取free_list第一个返回</span><br><span class="line">#if PyTuple_MAXSAVESIZE &gt; 0</span><br><span class="line">    if (size &#x3D;&#x3D; 0 &amp;&amp; free_list[0]) &#123;</span><br><span class="line">        op &#x3D; free_list[0];</span><br><span class="line">        Py_INCREF(op);</span><br><span class="line"></span><br><span class="line">#ifdef COUNT_ALLOCS</span><br><span class="line">        tuple_zero_allocs++;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        return (PyObject *) op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果free_list可分配, 从free_list取一个</span><br><span class="line">    if (size &lt; PyTuple_MAXSAVESIZE &amp;&amp; (op &#x3D; free_list[size]) !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F; 上面  op &#x3D; free_list[size] 取得单链表头</span><br><span class="line">        &#x2F;&#x2F; free_list指向单链表下一个元素, 对应位置阈值--</span><br><span class="line">        free_list[size] &#x3D; (PyTupleObject *) op-&gt;ob_item[0];</span><br><span class="line">        numfree[size]--;</span><br><span class="line"></span><br><span class="line">#ifdef COUNT_ALLOCS</span><br><span class="line">        fast_tuple_allocs++;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 初始化 ob_size和ob_type</span><br><span class="line">      &#x2F;* Inline PyObject_InitVar *&#x2F;</span><br><span class="line">#ifdef Py_TRACE_REFS</span><br><span class="line">        Py_SIZE(op) &#x3D; size;</span><br><span class="line">        Py_TYPE(op) &#x3D; &amp;PyTuple_Type;</span><br><span class="line">#endif</span><br><span class="line">        _Py_NewReference((PyObject *)op);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">#endif   &#x2F;&#x2F; free_list不可用</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 计算空间</span><br><span class="line">        Py_ssize_t nbytes &#x3D; size * sizeof(PyObject *);</span><br><span class="line">        &#x2F;* Check for overflow *&#x2F;</span><br><span class="line">        if (nbytes &#x2F; sizeof(PyObject *) !&#x3D; (size_t)size ||</span><br><span class="line">            (nbytes &gt; PY_SSIZE_T_MAX - sizeof(PyTupleObject) - sizeof(PyObject *)))</span><br><span class="line">        &#123;</span><br><span class="line">            return PyErr_NoMemory();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 分配内存</span><br><span class="line">        op &#x3D; PyObject_GC_NewVar(PyTupleObject, &amp;PyTuple_Type, size);</span><br><span class="line">        if (op &#x3D;&#x3D; NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 初始化ob_item每个元素</span><br><span class="line">    for (i&#x3D;0; i &lt; size; i++)</span><br><span class="line">        op-&gt;ob_item[i] &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 第一次分配空数组, 将其放入free_list第一个位置</span><br><span class="line">#if PyTuple_MAXSAVESIZE &gt; 0</span><br><span class="line">    if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        free_list[0] &#x3D; op;</span><br><span class="line">        ++numfree[0];</span><br><span class="line">        Py_INCREF(op);          &#x2F;* extra INCREF so that this is never freed *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef SHOW_TRACK_COUNT</span><br><span class="line">    count_tracked++;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    _PyObject_GC_TRACK(op);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回</span><br><span class="line">    return (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1.如果size=0, 从free_list[0]取, 直接返回</li><li>2.否则, 确认free_list[size], 是否可用, 可用获取</li><li>3.否则, 从内存分配新的空间</li><li>4.初始化, 返回</li></ul><h2 id="tuple回收"><a href="#tuple回收" class="headerlink" title="tuple回收"></a>tuple回收</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">tupledealloc(register PyTupleObject *op)</span><br><span class="line">&#123;</span><br><span class="line">    register Py_ssize_t i;</span><br><span class="line">    &#x2F;&#x2F; 获取元素个数</span><br><span class="line">    register Py_ssize_t len &#x3D;  Py_SIZE(op);</span><br><span class="line"></span><br><span class="line">    PyObject_GC_UnTrack(op);</span><br><span class="line">    Py_TRASHCAN_SAFE_BEGIN(op)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (len &gt; 0) &#123;</span><br><span class="line">        i &#x3D; len;</span><br><span class="line">        &#x2F;&#x2F; 遍历, 析构每个元素</span><br><span class="line">        while (--i &gt;&#x3D; 0)</span><br><span class="line">            Py_XDECREF(op-&gt;ob_item[i]);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 与对象缓冲池相关</span><br><span class="line">#if PyTuple_MAXSAVESIZE &gt; 0</span><br><span class="line">        if (len &lt; PyTuple_MAXSAVESIZE &amp;&amp;</span><br><span class="line">            numfree[len] &lt; PyTuple_MAXFREELIST &amp;&amp;</span><br><span class="line">            Py_TYPE(op) &#x3D;&#x3D; &amp;PyTuple_Type)</span><br><span class="line">        &#123;</span><br><span class="line">            op-&gt;ob_item[0] &#x3D; (PyObject *) free_list[len];</span><br><span class="line">            numfree[len]++;</span><br><span class="line">            free_list[len] &#x3D; op;</span><br><span class="line">            goto done; &#x2F;* return *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 调用回收</span><br><span class="line">    Py_TYPE(op)-&gt;tp_free((PyObject *)op);</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    Py_TRASHCAN_SAFE_END(op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>回收ob_item每个元素</li><li>如果符合条件, 放入到free_list</li><li>否则, 回收</li></ul><h2 id="tuple缓冲池"><a href="#tuple缓冲池" class="headerlink" title="tuple缓冲池"></a>tuple缓冲池</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Speed optimization to avoid frequent malloc&#x2F;free of small tuples *&#x2F;</span><br><span class="line">#ifndef PyTuple_MAXSAVESIZE</span><br><span class="line"># 会被缓存的tuple长度阈值, 20, 长度&lt;20的, 才会走对象缓冲池逻辑</span><br><span class="line">#define PyTuple_MAXSAVESIZE     20</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef PyTuple_MAXFREELIST</span><br><span class="line">每种size的tuple最多会被缓存2000个</span><br><span class="line">#define PyTuple_MAXFREELIST  2000</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if PyTuple_MAXSAVESIZE &gt; 0</span><br><span class="line"># free_list, 指针数组, 每个位置, 存储了指向一个单链表头的地址</span><br><span class="line">static PyTupleObject *free_list[PyTuple_MAXSAVESIZE];</span><br><span class="line"># numfree, 一个计数数组, 存储free_list对应位置的单链表长度</span><br><span class="line">static int numfree[PyTuple_MAXSAVESIZE];</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ul><li>作用: 优化小tuple的mall/free</li><li>free_list[0], 指向空数组, 有且仅有一个</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PyTupleObject&quot;&gt;&lt;a href=&quot;#PyTupleObject&quot; class=&quot;headerlink&quot; title=&quot;PyTupleObject&quot;&gt;&lt;/a&gt;PyTupleObject&lt;/h2&gt;&lt;figure class=&quot;highlight plai</summary>
      
    
    
    
    <category term="python源码解析" scheme="http://example.com/categories/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>项目解析</title>
    <link href="http://example.com/2021/06/18/python/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/18/python/%E9%A1%B9%E7%9B%AE%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-18T01:03:51.525Z</published>
    <updated>2021-06-17T08:25:59.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rms-Repair-Management-System"><a href="#rms-Repair-Management-System" class="headerlink" title="rms(Repair Management System)"></a>rms(Repair Management System)</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">rms</span><br><span class="line">├── </span><br><span class="line">│   └──materialManage</span><br><span class="line">│           ├── views</span><br><span class="line">│           ├── forms</span><br><span class="line">│           ├── urls.py</span><br><span class="line">│           ├── cron.py</span><br><span class="line">│           ├── testSQL.py</span><br><span class="line">│           ├── tests.py</span><br><span class="line">│           ├── redis.py</span><br><span class="line">│           └── mysql.py</span><br><span class="line">└──</span><br><span class="line">│   └── performance</span><br><span class="line">│           ├── views</span><br><span class="line">│           ├── forms</span><br><span class="line">│           ├── urls.py</span><br><span class="line">│           ├── cron.py</span><br><span class="line">│           ├── testSQL.py</span><br><span class="line">│           ├── tests.py</span><br><span class="line">│           ├── redis.py</span><br><span class="line">│           └── mysql.py</span><br><span class="line">└──</span><br><span class="line">│   └── rework     </span><br><span class="line">│           ├── views</span><br><span class="line">│           ├── forms</span><br><span class="line">│           ├── urls.py</span><br><span class="line">│           ├── cron.py</span><br><span class="line">│           ├── testSQL.py</span><br><span class="line">│           ├── tests.py</span><br><span class="line">│           ├── redis.py</span><br><span class="line">│           └── mysql.py         </span><br><span class="line">└──</span><br><span class="line">│   └── smartDebug</span><br><span class="line">│           ├── views</span><br><span class="line">│           ├── forms</span><br><span class="line">│           ├── urls.py</span><br><span class="line">│           ├── cron.py</span><br><span class="line">│           ├── testSQL.py</span><br><span class="line">│           ├── tests.py</span><br><span class="line">│           ├── redis.py</span><br><span class="line">│           └── mysql.py</span><br><span class="line">│── utils</span><br><span class="line">│── urls.py</span><br><span class="line">│── mysql.py</span><br><span class="line">│── redis.py</span><br><span class="line">│── celery.py</span><br><span class="line">│── config.py</span><br></pre></td></tr></table></figure><h3 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h3><h4 id="mysql模块"><a href="#mysql模块" class="headerlink" title="mysql模块"></a>mysql模块</h4><ul><li>1.使用pooledDB连接池</li><li>2.在外部定义一个总的MySQL的大类</li><li>3.在各个模块分别继承MySQL</li><li>4.在views视图中按照模块单例导入</li><li>5.testSQL用户测试某些表</li></ul><h4 id="redis模块"><a href="#redis模块" class="headerlink" title="redis模块"></a>redis模块</h4><p>类似于mysql架构</p><ul><li>1.使用connectionPool定义一个类，并写一些常用方法</li><li>2.在views视图中模块单例导入</li><li>3.用于缓存(str)、排行榜（zset)、开关(str)、计数器(网站访问次数之类的)</li></ul><h4 id="urls模块"><a href="#urls模块" class="headerlink" title="urls模块"></a>urls模块</h4><p>用的普通django路由系统加include外部囊括</p><h4 id="views和forms模块"><a href="#views和forms模块" class="headerlink" title="views和forms模块"></a>views和forms模块</h4><ul><li>1.使用的rest_framework.decorators.api_view FBV </li><li>2.使用django.forms.Form进行校验</li></ul><h4 id="cron-py"><a href="#cron-py" class="headerlink" title="cron.py"></a>cron.py</h4><p>执行一些定时任务</p><ul><li>使用linux的单机crontab执行某些定时任务</li></ul><h4 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h4><p>存放一些小工具比如：</p><ul><li>发送邮件</li><li>转义字符</li><li>获取时间</li><li>数据库插入</li></ul><h4 id="tests-py"><a href="#tests-py" class="headerlink" title="tests.py"></a>tests.py</h4><p>用于自定义一些小的测试接口</p><h4 id="celery-py"><a href="#celery-py" class="headerlink" title="celery.py"></a>celery.py</h4><ul><li>1.使用redis作为消息列表和结果存储工具</li><li>2.某些工具接口异步任务，定时任务加入task</li><li>3.为分布式架构做准备</li></ul><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p>一些本项目的相关配置</p><h4 id="权限模块"><a href="#权限模块" class="headerlink" title="权限模块"></a>权限模块</h4><p>按照客户要求做数据本项目自己的权限模块</p><ul><li>用户表</li><li>权限表</li><li>关联表</li><li>前后端限制</li></ul><h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><h4 id="materialManagement"><a href="#materialManagement" class="headerlink" title="materialManagement"></a>materialManagement</h4><p>物料管理模块主要分为两个部分数据可视化和用户操作部分 </p><h5 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h5><ul><li>1.主要是根据客户需求进行数据的可视化显示一些按周，月显示的柱状图、折线图、列表</li><li>2.按照权限划分不同的可视权限</li><li>3.对接别的系统接口解析一些数据进行可视化</li><li>4.解析某些log文件的相关可视化</li><li>5.显示物料库存、不良物料等</li><li>6.物料差异分析</li></ul><h5 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h5><ul><li>1.用户物料申请、入库、退料、领料</li><li>2.老板签核</li><li>3.公告发布、文件上传</li></ul><h4 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h4><p>绩效模块主要部分绩效可视化和用户操作<br>首先对接产线斯科系统定时获取源数据，对接人资系统获取工时人员信息</p><h5 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h5><ul><li>1.通过分析源数据按照客户的逻辑对工程师进行周、月、年的绩效数据获取并显示</li><li>2.分析一些按部门的绩效，作为部门绩效评比</li><li>3.按照权限可视化</li></ul><h5 id="用户操作-1"><a href="#用户操作-1" class="headerlink" title="用户操作"></a>用户操作</h5><ul><li>1.工程师对比源数据，某些异常物料进行申请销料</li><li>2.管理者按照职位层级层层签核通过</li><li>3.管理者上传工程师月、年加分信息原因并按层级签核</li><li>4.管理者上传某些公告显示</li></ul><h4 id="Rework"><a href="#Rework" class="headerlink" title="Rework"></a>Rework</h4><p>重工模块主要包括重工系统数据可视、重工系统用户操作</p><h5 id="重工系统数据维护可视化"><a href="#重工系统数据维护可视化" class="headerlink" title="重工系统数据维护可视化"></a>重工系统数据维护可视化</h5><p>由于各个部门开发的重工系统不一致，导致需要申请多个api显示</p><ul><li>整合各个部门开发重工系统数据</li><li>按照相应逻辑按年月日进行显示</li><li>wip分析显示</li></ul><h5 id="用户操作-2"><a href="#用户操作-2" class="headerlink" title="用户操作"></a>用户操作</h5><ul><li>整合用户操作统一到当前系统</li><li>兼容各个系统旧数据</li><li>用户相关checkout、checkin操作</li></ul><h4 id="smartDebug"><a href="#smartDebug" class="headerlink" title="smartDebug"></a>smartDebug</h4><p>主要是一些提前报警功能，比如一块料只能用5次，根据<br>源数据计算得到使用了四次了就报警表示更换报废该料</p><h2 id="sso-单点登录系统"><a href="#sso-单点登录系统" class="headerlink" title="sso(单点登录系统)"></a>sso(单点登录系统)</h2><p>整个测试平台为一个大的项目其中分为多个项目，为整个测试平台实现单点登录</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sso</span><br><span class="line">└── views.py</span><br><span class="line">├── mysql.py</span><br><span class="line">├── config.py</span><br><span class="line">├── utils</span><br><span class="line">├── tests.py</span><br><span class="line">├── middlewares.py</span><br></pre></td></tr></table></figure><h3 id="架构概述"><a href="#架构概述" class="headerlink" title="架构概述"></a>架构概述</h3><h4 id="通过人资系统的第三方登录对接（和github第三方类似）"><a href="#通过人资系统的第三方登录对接（和github第三方类似）" class="headerlink" title="通过人资系统的第三方登录对接（和github第三方类似）"></a>通过人资系统的第三方登录对接（和github第三方类似）</h4><ul><li>1.申请secretKey、appid放在config中</li><li>2.带必填参数访问xxxxxx/login?response_type=code&amp;client_id=xxxx&amp;redirect_uri=xxxxx&amp;state=xxxxx&amp;continue=oauth2</li><li>3.登录成功后有回调函数，第三方会带着生成的code调用回调函数</li><li>4.回调函数中拿着code和state、appid、secretKey、grant_type去访问xxxxxxx/oauth/access_token拿到access_token</li><li>5.然后带着access_token访问xxxxx/user_info获取一部分返回的用户信息</li><li>6.解析该用户是否在我们的用户组里<ul><li>1.存在可以获取到email、full_name检测更新数据库</li><li>2.使用jwt生成token</li><li>3.不存在，先按照人资的认证信息简单在数据增加此人，并生成jwt</li></ul></li></ul><h4 id="jwt实现单点登录"><a href="#jwt实现单点登录" class="headerlink" title="jwt实现单点登录"></a>jwt实现单点登录</h4><ul><li>jwt放置在sessionStorage</li><li>通过简单中间件实现验证和续签，续签是每次访问完接口process_response时<br>如果该token的创建时间没有超过7.5h就生成一个新的1小时为过期的token（这里其实可以用redis存储黑名单，但使token有了状态）</li></ul><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><ul><li>初始化为每个项目客户的管理者申请好权限</li><li>权限申请按照层级签署、驳回生效</li><li>主要用来前端根据权限限制用户访问某些网页</li></ul><h4 id="人员信息可视化"><a href="#人员信息可视化" class="headerlink" title="人员信息可视化"></a>人员信息可视化</h4><p>相关离职人员、出差人员、调动人员、角色人员按时间显示</p><h2 id="一些小的项目、脚本和窗口"><a href="#一些小的项目、脚本和窗口" class="headerlink" title="一些小的项目、脚本和窗口"></a>一些小的项目、脚本和窗口</h2><ul><li>帮各个部门的助理写的一些处理文件、excel之类的和简单的数据显示的网站</li><li>帮同事写的一些pyside2、wxpython的简单gui处理接口</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;rms-Repair-Management-System&quot;&gt;&lt;a href=&quot;#rms-Repair-Management-System&quot; class=&quot;headerlink&quot; title=&quot;rms(Repair Management System)&quot;&gt;&lt;/a&gt;r</summary>
      
    
    
    
    <category term="webframe" scheme="http://example.com/categories/webframe/"/>
    
    
  </entry>
  
  <entry>
    <title>部分PEP8规范</title>
    <link href="http://example.com/2021/06/18/python/PEP8%E8%A7%84%E8%8C%83/"/>
    <id>http://example.com/2021/06/18/python/PEP8%E8%A7%84%E8%8C%83/</id>
    <published>2021-06-18T01:03:51.510Z</published>
    <updated>2021-06-16T07:11:00.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​PEP是Python Enhancement Proposal的缩写，通常翻译为“Python增强提案”。<br>​每个PEP都是一份为Python社区提供的指导Python往更好的方向发展的技术文档，<br>其中的第8号增强提案（PEP 8）是针对Python语言编订的代码风格指南。</p><h2 id="空格使用"><a href="#空格使用" class="headerlink" title="空格使用"></a>空格使用</h2><ul><li>1.各种右括号前不要加空格。</li><li>2.逗号、冒号、分号前不要加空格。</li><li>3.函数的左括号前不要加空格。如Func(1)。</li><li>4.序列的左括号前不要加空格。如list[2]。</li><li>5.操作符左右各加一个空格，不要为了对齐增加空格。</li><li>6.函数默认参数使用的赋值符左右省略空格。</li><li>7.不要将多句语句写在同一行，尽管使用‘；’允许。</li><li>8.if/for/while语句中，即使执行语句只有一句，也必须另起一行。</li></ul><h2 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h2><ul><li>1.每行最大长度为120</li><li>2.class需要空两行</li><li>3.缩进为4空格表示</li></ul><h2 id="文档编排"><a href="#文档编排" class="headerlink" title="文档编排"></a>文档编排</h2><ul><li>1.导入包需要按照内置包、第三方包、自己写的包的顺序分块导入</li><li>2.不要在import一句中导入多个库，如import time, math</li><li>3.为了避免库冲突少使用from xxx import xxx，改用import xxx，xxx.xxx调用</li></ul><h2 id="注释使用"><a href="#注释使用" class="headerlink" title="注释使用"></a>注释使用</h2><ul><li><p>1.当一段代码发生变化时，第一件事就是要修改注释！</p></li><li><p>2.块注释，在一段代码前增加的注释。在‘#’后加一空格。段落之间以只有‘#’的行间隔。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Description : Module config.</span><br><span class="line"># </span><br><span class="line"># Input : None</span><br><span class="line">#</span><br><span class="line"># Output : None</span><br></pre></td></tr></table></figure></li><li><p>3.行注释，在一句代码后加注释。比如：(但是这种方式尽量少使用)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; x + 1       # Increment x</span><br></pre></td></tr></table></figure></li><li><p>4.避免无谓的注释。</p></li></ul><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ul><li>1.尽量单独使用小写字母‘l’，大写字母‘O’等容易混淆的字母。</li><li>2.模块命名尽量短小，使用全部小写的方式，可以使用下划线。</li><li>3.包命名尽量短小，使用全部小写的方式，不可以使用下划线。</li><li>4.类的命名使用CapWords的方式，模块内部使用的类采用_CapWords的方式。(class 接大写)</li><li>5.异常命名使用CapWords+Error后缀的方式。</li><li>6.全局变量尽量只在模块内有效，类似C语言中的static。<br>实现方法有两种，一是all机制，二是前缀一个下划线。</li><li>7.函数命名使用全部小写的方式，可以使用下划线。</li><li>8.常量命名使用全部大写的方式，可以使用下划线。</li><li>9.类的属性（方法和变量）命名使用全部小写的方式，可以使用下划线。</li><li>10.类的属性有3种作用域public、non-public和subclass API，<br>可以理解成C++中的public、private、protected，non-public属性前，前缀一条下划线。</li><li>11.类的属性若与关键字名字冲突，后缀一下划线，尽量不要使用缩略等其他方式。</li><li>12.为避免与子类属性命名冲突，在类的一些属性前，前缀两条下划线。<br>比如：类Foo中声明__a,访问时，只能通过Foo._Foo__a，避免歧义，<br>如果子类也叫Foo，那就无能为力了。</li><li>13.类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​PEP是Python Enhancement Proposal的缩写，通常翻译为“Python增强提案”。&lt;br&gt;​每个PEP都是一份为P</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>celery</title>
    <link href="http://example.com/2021/06/18/python/celery/"/>
    <id>http://example.com/2021/06/18/python/celery/</id>
    <published>2021-06-18T01:03:51.510Z</published>
    <updated>2021-06-16T03:46:53.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>celery是一个简单，灵活且可靠的处理大量消息的分布式系统<br>。专注于实时处理的异步任务队列，同时也支持任务调度。</p><h3 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a>相关信息</h3><ul><li><p>分布式系统<br>一个系统应用有很多系统组件：web服务器，数据库，消息中间键，缓存等，<br>把这些组件架构在不同的服务器上，然后这些不同服务器上的不同组件之间<br>通过消息中间键通信的方式来实现这种协调工作。（当用户访问时，要做到<br>和访问一台服务器的用户感知是一样的）</p></li><li><p>分布式系统优点<br>负载均衡，避免单点故障</p></li><li><p>异步任务<br>asynic协程执行，利用io操作等待时间执行别的任务。（当前任务await时）</p></li></ul><h3 id="组成架构"><a href="#组成架构" class="headerlink" title="组成架构"></a>组成架构</h3><p>celery的架构由三部分组成，本质就是使用进程、协程（asyncio）封装处理异步任务，<br>一个worker就是一个进程，一个进程里面开多个协程。</p><ul><li><p>1.消息中间件<br>celery本身不提供消息服务，但直接可以集成rabbitMQ、redis等</p></li><li><p>2.任务执行单元<br>worker是celery提供的任务执行单元，worker并发的运行在分布式的系统节点中。</p></li><li><p>3.任务执行结果存储<br>task result store用来存储执行任务的结果，celery<br>支持以不同的方式储存任务的结果，包括AMQP、redis、mysql等</p></li><li><p>4.另外celery还支持不同的并发和序列化手段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.并发</span><br><span class="line">prefork、eventlet、gevent、threads</span><br><span class="line">2.序列化</span><br><span class="line">pickle、json、yaml、zlib等</span><br></pre></td></tr></table></figure></li></ul><h2 id="celery的异步任务场景"><a href="#celery的异步任务场景" class="headerlink" title="celery的异步任务场景"></a>celery的异步任务场景</h2><p>生产者连接消息中间件，创建队列，向指定队列插入数据<br>消费者连接消息中间件，监听队列，内部实现callback，<br>如果有异步操作需要在callback里面使用并发技术处理。<br>（以上这些流程celery已经帮我们做好声明，无需自己定义）<br>celery的定时任务场景（每天几点执行）。</p><ul><li>1.比如（django，简单python项目）作为生产消息的生产者;</li><li>2.rabbitMQ、redis作为消息中间件消息队列存放生产者生产出来的消息;</li><li>3.celery消费者，作为真正的异步任务执行单元，异步从消息队列中取出消息执行;</li><li>4.redis、sql等作为结果存储单元。</li></ul><h2 id="基础异步模型"><a href="#基础异步模型" class="headerlink" title="基础异步模型"></a>基础异步模型</h2><h3 id="消费者模块"><a href="#消费者模块" class="headerlink" title="消费者模块"></a>消费者模块</h3><ul><li><p>1.celery如何确定任务及监听对应任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">新建c1.py(consumer)</span><br><span class="line">import celery</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">backend &#x3D; &#39;redis:&#x2F;&#x2F;10.167.219.250:8001&#x2F;1&#39;</span><br><span class="line">broker &#x3D; &#39;redis:&#x2F;&#x2F;10.167.219.250:8001&#x2F;2&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 名字，数据库存储，消息中间件</span><br><span class="line">cel &#x3D; celery.Celery(&#39;test&#39;, backend&#x3D;backend, broker&#x3D;broker)</span><br><span class="line">@cel.task(name&#x3D;&#39;utils.myCelery.send_email&#39;)</span><br><span class="line"></span><br><span class="line">@cel.task</span><br><span class="line">def send_email(name):</span><br><span class="line">    print(&quot;向%s发送邮件...&quot;%name)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    print(&quot;向%s发送邮件完成...&quot;%name)</span><br><span class="line">    return &quot;ok&quot;</span><br><span class="line"></span><br><span class="line">@cel.task</span><br><span class="line">def send_msg(name):</span><br><span class="line">    print(&quot;向%s发送短信...&quot;%name)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    print(&quot;向%s发送短信完成...&quot;%name)</span><br><span class="line">    return &quot;ok&quot;</span><br><span class="line">注意名字的一致性</span><br></pre></td></tr></table></figure></li><li><p>2.启动消费者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">执行celery –A c1(python文件名) worker –l INFO</span><br><span class="line">E:\春江花月夜\笔记\celery&gt;celery -A c1 worker -l INFO</span><br><span class="line"></span><br><span class="line"> -------------- celery@xxxxxxx v5.0.0 (singularity)</span><br><span class="line">--- ***** -----</span><br><span class="line">-- ******* ---- Windows-10-10.0.17763-SP0 2020-10-09 15:40:49</span><br><span class="line">- *** --- * ---</span><br><span class="line">- ** ---------- [config]</span><br><span class="line">- ** ---------- .&gt; app:         test:0x2844f1f8400</span><br><span class="line">- ** ---------- .&gt; transport:   redis:&#x2F;&#x2F;10.167.219.250:8001&#x2F;2</span><br><span class="line">- ** ---------- .&gt; results:     redis:&#x2F;&#x2F;10.167.219.250:8001&#x2F;1</span><br><span class="line">- *** --- * --- .&gt; concurrency: 4 (prefork)</span><br><span class="line">-- ******* ---- .&gt; task events: OFF (enable -E to monitor tasks in this worker)</span><br><span class="line">--- ***** -----</span><br><span class="line"> -------------- [queues]</span><br><span class="line">                .&gt; celery           exchange&#x3D;celery(direct) key&#x3D;celery</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[tasks]</span><br><span class="line">  . c1.send_email</span><br><span class="line">  . c1.send_msg</span><br><span class="line"></span><br><span class="line">[2020-10-09 15:40:49,912: INFO&#x2F;MainProcess] Connected to redis:&#x2F;&#x2F;10.167.219.250:8001&#x2F;2</span><br><span class="line">[2020-10-09 15:40:49,931: INFO&#x2F;MainProcess] mingle: searching for neighbors</span><br><span class="line">[2020-10-09 15:40:50,900: INFO&#x2F;SpawnPoolWorker-1] child process 2076 calling self.run()</span><br><span class="line">[2020-10-09 15:40:50,915: INFO&#x2F;SpawnPoolWorker-2] child process 7964 calling self.run()</span><br><span class="line">[2020-10-09 15:40:50,985: INFO&#x2F;MainProcess] mingle: all alone</span><br><span class="line">[2020-10-09 15:40:51,047: INFO&#x2F;MainProcess] celery@xxxxxxx ready.</span><br><span class="line">[2020-10-09 15:40:51,069: INFO&#x2F;SpawnPoolWorker-3] child process 8856 calling self.run()</span><br><span class="line">[2020-10-09 15:40:51,192: INFO&#x2F;SpawnPoolWorker-4] child process 17216 calling self.run()</span><br><span class="line">监听成功</span><br></pre></td></tr></table></figure></li></ul><h3 id="生产者模块"><a href="#生产者模块" class="headerlink" title="生产者模块"></a>生产者模块</h3><ul><li>新建product.py<br>导入我们在celery task注册好的方法并delay调用，比如<br>在views中，存储数据后想发送邮件信息。可以使用celery</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from c1 import send_email, send_msg</span><br><span class="line"># delay(是cel.task中的方法）放入消息中間件，并傳入必要參數</span><br><span class="line">result &#x3D; send_email.delay(&#39;yuan&#39;)</span><br><span class="line"># 这时候的结果已经存入了数据库redis，我们需要通过这个id去访问结果</span><br><span class="line">print(result.id)</span><br><span class="line"></span><br><span class="line">result &#x3D; send_msg.delay(&#39;zhang&#39;)</span><br><span class="line">print(result.id)</span><br></pre></td></tr></table></figure><h3 id="结果储存模块"><a href="#结果储存模块" class="headerlink" title="结果储存模块"></a>结果储存模块</h3><p>通过执行的id进行查询，判断执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from celery.result import AsyncResult</span><br><span class="line">from c1 import cel</span><br><span class="line">async_result &#x3D; AsyncResult(id&#x3D;&quot;e78e6274-46a7-4fb1-9ae6-2084fcdad58d&quot;, app&#x3D;cel)</span><br><span class="line">if async_result.successful():</span><br><span class="line">    result &#x3D; async_result.get()</span><br><span class="line">    print(result)</span><br><span class="line">elif async_result.failed():</span><br><span class="line">    print(&#39;执行失败&#39;)</span><br><span class="line">elif async_result.status &#x3D;&#x3D; &#39;PENDING&#39;:</span><br><span class="line">    print(&#39;任务等待中被执行&#39;)</span><br><span class="line">elif async_result.status &#x3D;&#x3D; &#39;RETRY&#39;:</span><br><span class="line">    print(&#39;任务异常后重试&#39;)</span><br><span class="line">elif async_result.status &#x3D;&#x3D; &#39;STARTED&#39;:</span><br><span class="line">    print(&#39;任务已经开始被执行&#39;)</span><br></pre></td></tr></table></figure><h2 id="多任务异步模型"><a href="#多任务异步模型" class="headerlink" title="多任务异步模型"></a>多任务异步模型</h2><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><ul><li><p>1.新建consumer消费者模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">python packages</span><br><span class="line">celery_tasks</span><br><span class="line">__init__.py</span><br><span class="line">celery.py</span><br><span class="line">task01.py</span><br><span class="line">task02.py</span><br></pre></td></tr></table></figure></li><li><p>2.setting配置celery.py<br>这里的改变主要是需要include所有的需要的任务包，每<br>个任务会开启一个进程，在进程中会开启协程运行此进程中的每个任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import celery</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">backend &#x3D; &#39;redis:&#x2F;&#x2F;10.167.219.250:8001&#x2F;1&#39;</span><br><span class="line">broker &#x3D; &#39;redis:&#x2F;&#x2F;10.167.219.250:8001&#x2F;2&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 名字，数据库存储，消息中间件， 多了一个include放置你需要的所有task</span><br><span class="line">cel &#x3D; celery.Celery(&#39;test&#39;, backend&#x3D;backend, broker&#x3D;broker, include&#x3D;[&#39;celery_tasks.task01&#39;, &#39;celery_tasks.task02&#39;])</span><br><span class="line"></span><br><span class="line"># 基本配置</span><br><span class="line"># 时区</span><br><span class="line">cel.conf.timezone &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line"># 是否使用utc</span><br><span class="line">cel.conf.enable_utc &#x3D; False</span><br></pre></td></tr></table></figure></li><li><p>3.任务模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">task01</span><br><span class="line">import time</span><br><span class="line">from .celery import cel</span><br><span class="line"></span><br><span class="line">@cel.task</span><br><span class="line">def send_email(name):</span><br><span class="line">    print(&quot;向%s发送邮件...&quot;%name)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    print(&quot;向%s发送邮件完成...&quot;%name)</span><br><span class="line">    return &quot;邮件完成！&quot;</span><br><span class="line">    </span><br><span class="line">task02</span><br><span class="line">import time</span><br><span class="line">from .celery import cel</span><br><span class="line"></span><br><span class="line">@cel.task</span><br><span class="line">def send_msg(name):</span><br><span class="line">    xxx</span><br><span class="line">    print(&quot;向%s发送短信...&quot;%name)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    print(&quot;向%s发送短信完成...&quot;%name)</span><br><span class="line">    return &quot;短信完成&quot;</span><br><span class="line"></span><br><span class="line">运行celery -A celery_tasks worker -l INFO –P eventlet</span><br><span class="line">这里-P指定开启协程的方式</span><br><span class="line">通过-C控制并发数</span><br><span class="line">celery -A celery_tasks worker –l INFO –C 5</span><br><span class="line">(当存在celery遗留可以删掉celery)这里-C指定5个并发执行。</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44235861&#x2F;article&#x2F;details&#x2F;108842685</span><br></pre></td></tr></table></figure><p>生产者和结果基本与基础模型相似</p></li></ul><h2 id="Celery简单定时任务"><a href="#Celery简单定时任务" class="headerlink" title="Celery简单定时任务"></a>Celery简单定时任务</h2><h3 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h3><p>消费者都是一样的监听消息中间件，cel的装饰器包装相关任务方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 定时任务</span><br><span class="line">import time</span><br><span class="line">import celery</span><br><span class="line"># 名字，数据库存储，消息中间件， 多了一个include放置你需要的所有task</span><br><span class="line">backend &#x3D; &#39;redis:&#x2F;&#x2F;10.167.219.250:8001&#x2F;1&#39;</span><br><span class="line">broker &#x3D; &#39;redis:&#x2F;&#x2F;10.167.219.250:8001&#x2F;2&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cel &#x3D; celery.Celery(&#39;test&#39;, backend&#x3D;backend,</span><br><span class="line">broker&#x3D;broker)</span><br><span class="line"></span><br><span class="line"># 基本配置</span><br><span class="line"># 时区</span><br><span class="line">cel.conf.timezone &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line"># 是否使用utc</span><br><span class="line">cel.conf.enable_utc &#x3D; False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@cel.task</span><br><span class="line">def send_email(name):</span><br><span class="line">    print(&#39;正在发送邮件给%s&#39;%name)</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&#39;发送邮件给%s完成&#39;%name)</span><br></pre></td></tr></table></figure><ul><li>开启消费者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A python文件名 worker -l INFO</span><br></pre></td></tr></table></figure></li></ul><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 定时任务</span><br><span class="line">from c1 import send_email</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line"># 方式一</span><br><span class="line">v1 &#x3D; datetime(2019, 10, 9, 17, 18, 00)</span><br><span class="line">print(v1)</span><br><span class="line"># 需要使用国标时间</span><br><span class="line">v2 &#x3D; datetime.utcfromtimestamp(v1.timestamp())</span><br><span class="line">print(v2)</span><br><span class="line"># 用apply_async执行定时任务， 用delay执行异步任务</span><br><span class="line">result &#x3D; send_email.apply_async(args&#x3D;[&quot;egon&quot;,], eta&#x3D;v2)</span><br><span class="line">print(result.id)</span><br><span class="line"></span><br><span class="line"># 方式二</span><br><span class="line">ctime &#x3D; datetime.now()</span><br><span class="line">print(ctime)</span><br><span class="line"># 需要使用国标时间</span><br><span class="line">utc_ctime &#x3D; datetime.utcfromtimestamp(ctime.timestamp())</span><br><span class="line">from datetime import timedelta</span><br><span class="line"># 用apply_async执行定时任务， 用delay执行异步任务</span><br><span class="line">result &#x3D; send_email.apply_async(args&#x3D;[&quot;egon&quot;,], </span><br><span class="line">eta&#x3D;utc_ctime + timedelta(seconds&#x3D;10))</span><br><span class="line">print(result.id)</span><br></pre></td></tr></table></figure><h2 id="celery执行复杂定时任务"><a href="#celery执行复杂定时任务" class="headerlink" title="celery执行复杂定时任务"></a>celery执行复杂定时任务</h2><p>这种定时执行的任务和生产者无关，因为是真正的定时执行的任务，每隔多久就会执行一次。</p><h3 id="消费者-amp-生产者"><a href="#消费者-amp-生产者" class="headerlink" title="消费者&amp;生产者"></a>消费者&amp;生产者</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import celery</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">backend &#x3D; &#39;redis:&#x2F;&#x2F;10.167.219.250:8001&#x2F;1&#39;</span><br><span class="line">broker &#x3D; &#39;redis:&#x2F;&#x2F;10.167.219.250:8001&#x2F;2&#39;</span><br><span class="line"></span><br><span class="line"># 名字，数据库存储，消息中间件， 多了一个include放置你需要的所有task</span><br><span class="line">cel &#x3D; celery.Celery(&#39;test&#39;, backend&#x3D;backend, broker&#x3D;broker, </span><br><span class="line">include&#x3D;[&#39;celery_tasks.task01&#39;, &#39;celery_tasks.task02&#39;])</span><br><span class="line"></span><br><span class="line"># 基本配置</span><br><span class="line"># 时区</span><br><span class="line">cel.conf.timezone &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line"># 是否使用utc</span><br><span class="line">cel.conf.enable_utc &#x3D; False</span><br><span class="line"></span><br><span class="line">from datetime import timedelta</span><br><span class="line"># 构建定时任务调度器</span><br><span class="line">cel.conf.beat_schedule &#x3D; &#123;</span><br><span class="line">    # 名称每个定时任务的名称，自己起</span><br><span class="line">    &#39;add-every-6-seconds&#39;: &#123;</span><br><span class="line">        &#39;task&#39;: &#39;celery_tasks.task01.send_email&#39;,</span><br><span class="line">        # 每隔六秒执行一次</span><br><span class="line">        # &#39;schedule&#39;: 6.0,</span><br><span class="line">        # &#39;schedule&#39;: crontab(minutes&#x3D;&quot;*&#x2F;6&quot;),</span><br><span class="line">        &#39;schedule&#39;: timedelta(seconds&#x3D;6),</span><br><span class="line">        # 传递参数</span><br><span class="line">        &#39;args&#39;: (&#39;张三&#39;, )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="需要开启服务生产者执行定时任务"><a href="#需要开启服务生产者执行定时任务" class="headerlink" title="需要开启服务生产者执行定时任务"></a>需要开启服务生产者执行定时任务</h3><p>这个会读取配置文件中的定时任务调度器，通过里面配置的schedule时间定时向redis<br>（消息中间件）中插入任务（这个时候已经不是自定义的生产者执行插入任务，而是我们<br>单独开启的一个进程定时插入）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A +配置文件路径 beat -l INFO </span><br></pre></td></tr></table></figure><h3 id="还需要另一个新的进程（消费者）去处理队列"><a href="#还需要另一个新的进程（消费者）去处理队列" class="headerlink" title="还需要另一个新的进程（消费者）去处理队列"></a>还需要另一个新的进程（消费者）去处理队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A +配置文件路径 woker -l INFO</span><br></pre></td></tr></table></figure><h2 id="django配置celery使用"><a href="#django配置celery使用" class="headerlink" title="django配置celery使用"></a>django配置celery使用</h2><p>django利用celery完成一些定时和异步操作。</p><h3 id="异步任务调度"><a href="#异步任务调度" class="headerlink" title="异步任务调度"></a>异步任务调度</h3><ul><li><p>1.消费者+task（打包到django根目录）</p></li><li><p>2.在django项目下的配置文件夹同级目录，创建pakages，打包成项目文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">新建config.py</span><br><span class="line"># _*_ coding: utf-8 _*_</span><br><span class="line">__author__ &#x3D; &#39;春江花月夜oo&#39;</span><br><span class="line">CELERY_RESULT_BACKEND &#x3D; &#39;redis:&#x2F;&#x2F;10.167.218.136:6380&#x2F;14&#39;</span><br><span class="line">BROKER_URL &#x3D; &#39;redis:&#x2F;&#x2F;10.167.218.136:6380&#x2F;15&#39;</span><br></pre></td></tr></table></figure></li><li><p>3.把配置和主调用函数分开，实现解耦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">新建main.py</span><br><span class="line"># _*_ coding: utf-8 _*_</span><br><span class="line">__author__ &#x3D; &#39;春江花月夜oo&#39;</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">import django</span><br><span class="line">from celery import Celery</span><br><span class="line"></span><br><span class="line">app &#x3D; Celery(&quot;myCelery&quot;)</span><br><span class="line"></span><br><span class="line">pwd &#x3D; os.path.dirname(os.path.realpath(__file__))</span><br><span class="line">sys.path.append(pwd+&quot;..&#x2F;&quot;)</span><br><span class="line">os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;myproject.settings&quot;)</span><br><span class="line">django.setup()</span><br><span class="line">app.config_from_object(&#39;mycelery.config&#39;)</span><br><span class="line"></span><br><span class="line">app.autodiscover_tasks([&quot;mycelery.sms&quot;, &quot;mycelery.email&quot;])</span><br><span class="line">这里需要</span><br><span class="line">1.加载django环境变量</span><br><span class="line">2.将配置文件的消息中间件、数据库加载到app</span><br><span class="line">3.监控tasks.py（需要监控的文件夹（目录））</span><br></pre></td></tr></table></figure></li><li><p>4.新建python packages任务包email和sms</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">在包里面新建tasks.py</span><br><span class="line">from ..main import app</span><br><span class="line">import time</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">log &#x3D; logging.getLogger(&#39;django&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def send_sms(mobile):</span><br><span class="line">    print(&quot;向手机%s发送短信&quot; % mobile)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    print(&quot;向手机%s发送短信成功&quot; % mobile)</span><br><span class="line">    return &quot;send_sms ok&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def send_sms2(mobile):</span><br><span class="line">    print(&quot;向手机%s发送短信2&quot; % mobile)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    print(&quot;向手机%s发送短信2成功&quot; % mobile)</span><br><span class="line">    return &quot;send_sms2 ok&quot;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>5.异步任务调度就可把tasks中的方法放在view中调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">view.py</span><br><span class="line">def test(request):</span><br><span class="line">    # 异步任务调度</span><br><span class="line">    send_sms.delay(&#39;110&#39;)</span><br><span class="line">    send_sms2.delay(&#39;119&#39;)</span><br><span class="line"></span><br><span class="line">    # 定时任务调度</span><br><span class="line">    ctime &#x3D; datetime.now()</span><br><span class="line">    utc_ctime &#x3D; datetime.utcfromtimestamp(ctime.timestamp())</span><br><span class="line">    time_delay &#x3D; timedelta(seconds&#x3D;10)</span><br><span class="line">    task_time &#x3D; utc_ctime + time_delay</span><br><span class="line">    result &#x3D; send_sms.apply_async([&quot;911&quot;, ], eta&#x3D;task_time)</span><br><span class="line">    print(result.id)</span><br><span class="line">    return HttpResponse(&quot;Ok&quot;)</span><br></pre></td></tr></table></figure></li><li><p>6.记得配置url<br>这个时候我们调用url的view.test，在我们的view中除了执行主业务，<br>现在还在异步的执行发送信息的业务，他不会影响主业务执行效率。<br>但这里只是把任务发送到了消息队列中还需要开启worker才能处理业务。</p></li></ul><p>如果我们需要什么定时任务，其实就是python脚本，<br>借用一下django的model存储数据，和django没啥关系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;celery是一个简单，灵活且可靠的处理大量消息的分布式系统&lt;br&gt;。专注于实时处理的异步任务队列，同时也支持任务调度。&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>垃圾回收和内存管理</title>
    <link href="http://example.com/2021/06/18/python/python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://example.com/2021/06/18/python/python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2021-06-18T01:03:51.510Z</published>
    <updated>2021-06-16T06:53:44.258Z</updated>
    
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>dict部分源码解析(cpython)</title>
    <link href="http://example.com/2021/06/18/python/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/dict%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/18/python/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/dict%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-18T01:03:51.510Z</published>
    <updated>2021-06-17T09:19:09.554Z</updated>
    
    <content type="html"><![CDATA[<p>python中大部分的运行机制当中都采用了dict来进行数据的管理，所以为了最高效的查询性能，<br>dict底层选择了基于哈希表实现。其中在python3.6之前，dict的实现里将数据存在了hash表里，<br>所以之前的dict是无序且十分消耗内存的，而在python3.6以后，官方对dict进行了很大地改进<br>（主要是将数据和hash部分分离），包括从无序变为有序，在一定程度上减少了内存的消耗，以及<br>部分操作性能的提升。<br><a href="https://zhuanlan.zhihu.com/p/73426505">链接1</a><br><a href="https://www.jianshu.com/p/fcd1ce2faa0b">链接2</a></p><h2 id="3-6版本前和3-6后对比"><a href="#3-6版本前和3-6后对比" class="headerlink" title="3.6版本前和3.6后对比"></a>3.6版本前和3.6后对比</h2><h3 id="3-6前"><a href="#3-6前" class="headerlink" title="3.6前"></a>3.6前</h3><p>用一个数组存储combined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\[(hash, key, value), (hash, key, value), (hash, key, value)]</span><br><span class="line">通过计算hash把数据放到数组某个位置</span><br></pre></td></tr></table></figure><h4 id="dict状态"><a href="#dict状态" class="headerlink" title="dict状态"></a>dict状态</h4><ul><li>1.Unused：此时key为null，即还未使用当前位置，此时索引值被设为-1</li><li>2.Active：如果当前位置设置了键值对，那么就会进入该状态，表示正在使用中，此时索引值就是所在位置的索引</li><li>3.Dummy：当被使用的key删除时，将会进入该状态，用于避免探测链断开而导致索引出错的问题</li></ul><h3 id="3-6后"><a href="#3-6后" class="headerlink" title="3.6后"></a>3.6后</h3><p>用两个数组存储，一个为entries存储数据的顺序，另一个为原来的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># entries</span><br><span class="line">[3, 5, 1, 4, 2]</span><br><span class="line"></span><br><span class="line">[(hash, key, value), (hash, key, value), (hash, key, value), (hash, key, value), (hash, key, value)]</span><br></pre></td></tr></table></figure><h4 id="dict状态-1"><a href="#dict状态-1" class="headerlink" title="dict状态"></a>dict状态</h4><ul><li>1.Unused：此时key为null，即还未使用当前位置，此时索引值被设为-1</li><li>2.Active：如果当前位置设置了键值对，那么就会进入该状态，表示正在使用中，此时索引值就是所在位置的索引</li><li>3.Pending：同样是删除键值对以后进入的状态，此时索引不变，但是对应索引存储的value将会被删除，从而等待新的对应索引的key插入</li></ul><h2 id="3-6后源码"><a href="#3-6后源码" class="headerlink" title="3.6后源码"></a>3.6后源码</h2><h3 id="PyDictObject"><a href="#PyDictObject" class="headerlink" title="PyDictObject"></a>PyDictObject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    &#x2F;&#x2F; 通用对象头</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    &#x2F;&#x2F; 键值对的数量</span><br><span class="line">    Py_ssize_t ma_used;</span><br><span class="line">    &#x2F;&#x2F; 版本标记</span><br><span class="line">    uint64_t ma_version_tag;</span><br><span class="line">    &#x2F;&#x2F; key集合，哈希表就存在这里面</span><br><span class="line">    PyDictKeysObject *ma_keys;</span><br><span class="line">    &#x2F;&#x2F; entries集合，split中，所有的键值对都存在ma_values里，而combined型的ma_values将会是null</span><br><span class="line">    PyObject **ma_values;</span><br><span class="line">&#125; PyDictObject;</span><br></pre></td></tr></table></figure><h4 id="key集合"><a href="#key集合" class="headerlink" title="key集合"></a>key集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _dictkeysobject PyDictKeysObject;</span><br><span class="line">struct _dictkeysobject &#123;</span><br><span class="line">    &#x2F;&#x2F; key集合的引用数</span><br><span class="line">    Py_ssize_t dk_refcnt;</span><br><span class="line">    &#x2F;&#x2F; 哈希表索引数组的大小</span><br><span class="line">    Py_ssize_t dk_size;</span><br><span class="line">    &#x2F;&#x2F; 字典查询方法</span><br><span class="line">    dict_lookup_func dk_lookup;</span><br><span class="line">    &#x2F;&#x2F; 字典中key集合可用大小</span><br><span class="line">    Py_ssize_t dk_usable;</span><br><span class="line">    &#x2F;&#x2F; entries中键值对的数量</span><br><span class="line">    Py_ssize_t dk_nentries;</span><br><span class="line">    &#x2F;&#x2F; 每个键对应存放数据位置的索引</span><br><span class="line">    char dk_indices[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="entries集合"><a href="#entries集合" class="headerlink" title="entries集合"></a>entries集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    Py_hash_t me_hash;</span><br><span class="line">    PyObject *me_key;</span><br><span class="line">    &#x2F;&#x2F; 在split型中，value存放在ma_values中，所以只有combined型的时候，me_value才存放value</span><br><span class="line">    PyObject *me_value;</span><br><span class="line">&#125; PyDictKeyEntry;</span><br></pre></td></tr></table></figure><h3 id="dict基本配置和缓冲池"><a href="#dict基本配置和缓冲池" class="headerlink" title="dict基本配置和缓冲池"></a>dict基本配置和缓冲池</h3><ul><li><p>基本配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 哈希表的起始尺寸为8</span><br><span class="line">#define PyDict_MINSIZE 8</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 哈希表相对于索引数量的尺寸</span><br><span class="line">#define ESTIMATE_SIZE(n)  (((n)*3+1) &gt;&gt; 1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当需要更新dict尺寸时，尺寸大小为索引数*3</span><br><span class="line">#define GROWTH_RATE(d) ((d)-&gt;ma_used*3)</span><br></pre></td></tr></table></figure></li><li><p>缓冲池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; dict缓冲池大小，尺寸和list缓冲池一样是80</span><br><span class="line">#ifndef PyDict_MAXFREELIST</span><br><span class="line">#define PyDict_MAXFREELIST 80</span><br><span class="line">#endif</span><br><span class="line">&#x2F;&#x2F; dict对象和dict中的key集合对象都有进行缓冲池操作</span><br><span class="line">static PyDictObject *free_list[PyDict_MAXFREELIST];</span><br><span class="line">static int numfree &#x3D; 0;</span><br><span class="line">static PyDictKeysObject *keys_free_list[PyDict_MAXFREELIST];</span><br><span class="line">static int numfreekeys &#x3D; 0;</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建dict"><a href="#创建dict" class="headerlink" title="创建dict"></a>创建dict</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyDict_New(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 引用+1</span><br><span class="line">    dictkeys_incref(Py_EMPTY_KEYS);</span><br><span class="line">    &#x2F;&#x2F; 通过空集合和空entries创建一个空字典</span><br><span class="line">    return new_dict(Py_EMPTY_KEYS, empty_values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个dict对象</span><br><span class="line">static PyObject *</span><br><span class="line">new_dict(PyDictKeysObject *keys, PyObject **values)</span><br><span class="line">&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    assert(keys !&#x3D; NULL);</span><br><span class="line">    &#x2F;&#x2F; 缓存池</span><br><span class="line">    if (numfree) &#123;</span><br><span class="line">        mp &#x3D; free_list[--numfree];</span><br><span class="line">        assert (mp !&#x3D; NULL);</span><br><span class="line">        assert (Py_TYPE(mp) &#x3D;&#x3D; &amp;PyDict_Type);</span><br><span class="line">        _Py_NewReference((PyObject *)mp);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        mp &#x3D; PyObject_GC_New(PyDictObject, &amp;PyDict_Type);</span><br><span class="line">        if (mp &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            dictkeys_decref(keys);</span><br><span class="line">            if (values !&#x3D; empty_values) &#123;</span><br><span class="line">                free_values(values);</span><br><span class="line">            &#125;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 初始化操作，注意这里的keys和values的内容还都是空的</span><br><span class="line">    mp-&gt;ma_keys &#x3D; keys;</span><br><span class="line">    mp-&gt;ma_values &#x3D; values;</span><br><span class="line">    mp-&gt;ma_used &#x3D; 0;</span><br><span class="line">    mp-&gt;ma_version_tag &#x3D; DICT_NEXT_VERSION();</span><br><span class="line">    ASSERT_CONSISTENT(mp);</span><br><span class="line">    return (PyObject *)mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">PyDict_SetItem(PyObject *op, PyObject *key, PyObject *value)</span><br><span class="line">&#123;</span><br><span class="line">    PyDictObject *mp;</span><br><span class="line">    Py_hash_t hash;</span><br><span class="line">    if (!PyDict_Check(op)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(key);</span><br><span class="line">    assert(value);</span><br><span class="line">    mp &#x3D; (PyDictObject *)op;</span><br><span class="line">    &#x2F;&#x2F; 获取对象的哈希值，如果不是可哈希的，则无法执行setitem操作</span><br><span class="line">    if (!PyUnicode_CheckExact(key) ||</span><br><span class="line">        (hash &#x3D; ((PyASCIIObject *) key)-&gt;hash) &#x3D;&#x3D; -1)</span><br><span class="line">    &#123;</span><br><span class="line">        hash &#x3D; PyObject_Hash(key);</span><br><span class="line">        if (hash &#x3D;&#x3D; -1)</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果哈希表是一个空表，则直接往空字典插入数据</span><br><span class="line">    if (mp-&gt;ma_keys &#x3D;&#x3D; Py_EMPTY_KEYS) &#123;</span><br><span class="line">        return insert_to_emptydict(mp, key, hash, value);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 添加或修改操作函数</span><br><span class="line">    return insertdict(mp, key, hash, value);</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">#### insertdict修改逻辑</span><br></pre></td></tr></table></figure><p>static int<br>insertdict(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject *value)<br>{<br>    PyObject *old_value;<br>    PyDictKeyEntry *ep;</p><pre><code>Py_INCREF(key);Py_INCREF(value);if (mp-&gt;ma_values != NULL &amp;&amp; !PyUnicode_CheckExact(key)) &#123;    if (insertion_resize(mp) &lt; 0)        goto Fail;&#125;// 寻找对应key的索引Py_ssize_t ix = mp-&gt;ma_keys-&gt;dk_lookup(mp, key, hash, &amp;old_value);// 异常情况处理if (ix == DKIX_ERROR)    goto Fail;assert(PyUnicode_CheckExact(key) || mp-&gt;ma_keys-&gt;dk_lookup == lookdict);MAINTAIN_TRACKING(mp, key, value);if (_PyDict_HasSplitTable(mp) &amp;&amp;    ((ix &gt;= 0 &amp;&amp; old_value == NULL &amp;&amp; mp-&gt;ma_used != ix) ||     (ix == DKIX_EMPTY &amp;&amp; mp-&gt;ma_used != mp-&gt;ma_keys-&gt;dk_nentries))) &#123;    if (insertion_resize(mp) &lt; 0)        goto Fail;    ix = DKIX_EMPTY;&#125;// 如果对应的key的映射为空，则代表添加数据if (ix == DKIX_EMPTY) &#123;    assert(old_value == NULL);    if (mp-&gt;ma_keys-&gt;dk_usable &lt;= 0) &#123;        if (insertion_resize(mp) &lt; 0)            goto Fail;    &#125;    // 寻找哈希表中当前key的插入位置    Py_ssize_t hashpos = find_empty_slot(mp-&gt;ma_keys, hash);    // ep指向entries的最后一位（索引为dk_nentries处）    ep = &amp;DK_ENTRIES(mp-&gt;ma_keys)[mp-&gt;ma_keys-&gt;dk_nentries];    // 设置indices中对应entries的索引，可以看到设置的entries索引就是entries的数量，因为键值对每次都是往entries的最后一位添加的    dictkeys_set_index(mp-&gt;ma_keys, hashpos, mp-&gt;ma_keys-&gt;dk_nentries);    // 设置新加入entries的键值对数据    ep-&gt;me_key = key;    ep-&gt;me_hash = hash;    if (mp-&gt;ma_values) &#123;        assert (mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] == NULL);        mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] = value;    &#125;    else &#123;        ep-&gt;me_value = value;    &#125;    // 添加成功操作    mp-&gt;ma_used++;    mp-&gt;ma_version_tag = DICT_NEXT_VERSION();    mp-&gt;ma_keys-&gt;dk_usable--;    mp-&gt;ma_keys-&gt;dk_nentries++;    assert(mp-&gt;ma_keys-&gt;dk_usable &gt;= 0);    ASSERT_CONSISTENT(mp);    return 0;&#125;// 如果不是添加操作，并且指定entries的value和当前传入的value不同，则需要更新valueif (old_value != value) &#123;    // split型表的操作    if (_PyDict_HasSplitTable(mp)) &#123;        // 直接更新entries中对应索引的value        mp-&gt;ma_values[ix] = value;        // 当前位置属于pending状态（已删除状态），则说明之前没有使用，现在使用了，所以使用数+1        if (old_value == NULL) &#123;            assert(ix == mp-&gt;ma_used);            mp-&gt;ma_used++;        &#125;    &#125;    // combined型表的操作    else &#123;        assert(old_value != NULL);        // 由于key、value都是存在哈希表中，直接修改哈希表对应位置的value        DK_ENTRIES(mp-&gt;ma_keys)[ix].me_value = value;    &#125;    mp-&gt;ma_version_tag = DICT_NEXT_VERSION();&#125;Py_XDECREF(old_value);ASSERT_CONSISTENT(mp);Py_DECREF(key);return 0;</code></pre><p>Fail:<br>    Py_DECREF(value);<br>    Py_DECREF(key);<br>    return -1;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## hash冲突与dict hash冲突处理</span><br><span class="line">哈希算法被计算的数据是无限的，而计算后的结果范围有限，</span><br><span class="line">因此总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突</span><br><span class="line">这个时候就需要一种方法解决这种冲突</span><br><span class="line"></span><br><span class="line">### hash冲突解决方法</span><br><span class="line"></span><br><span class="line">#### 开放寻址法</span><br><span class="line">从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。</span><br><span class="line">后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于</span><br><span class="line">等于所需要存放的元素。</span><br><span class="line"></span><br><span class="line">- 线行探查法</span><br><span class="line">依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。</span><br><span class="line">直到碰到空闲的单元或者探查完全部单元为止。</span><br><span class="line"></span><br><span class="line">- 平方探查法</span><br><span class="line">发生冲突的单元d\[i], 加上 1²、 2²等。即d\[i] + 1²，d\[i] + 2², d\[i] + 3²...直到找到空闲单元。</span><br><span class="line"></span><br><span class="line">- 双散列函数探查法</span><br><span class="line">这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，</span><br><span class="line">产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1</span><br><span class="line">之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，</span><br><span class="line">探查序列的步长值是固定值l</span><br><span class="line"></span><br><span class="line">- 二次探测法</span><br></pre></td></tr></table></figure><p>f(key) = (f(key)+di) MOD m (di = 1^2, -1^2, 2^2, -2^2,……, q^2, -q^2, q &lt;= m/2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 注：1^2 表示是 1的平方</span><br></pre></td></tr></table></figure><p>设哈希表长m＝14，哈希函数H（key）＝key％11。<br>表中已有4个结点：addr(15)=4，addr(38)=5，addr(61)=6，addr(84)=7，<br>其余地址为空。如果用二次探测再散列处理冲突，关键字为49的结点的地址是？<br>因为 f(49) = 5 与 f(38) 冲突<br>所以需要采用二次探测再散列来处理冲突<br>(f(49) + di) MOD 14(哈希表长m＝14)<br>第一次 di = 1^2<br>（5 + 1）MOD 14 = 6  与addr(61)=6冲突<br>第二次 di = -1^2<br>（5 - 1）MOD 14 = 4  与addr(15)=4 冲突<br>第三次 di = 2^2<br> （5 + 4）MOD 14 = 9 没有冲突<br>所以 addr(49)=9</p><p>```</p><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><p>冲突生成链表，链表一直往下。java使用此方法作为首要解决hash冲突的方法，<br>jdk1.7完全采用单链表来存储同义词，jdk1.8则采用了一种混合模式，对于链表<br>长度大于8的，会转换为红黑树存储。</p><h3 id="再hash"><a href="#再hash" class="headerlink" title="再hash"></a>再hash</h3><p>同时构造多个不同的哈希函数<br>Hi = RHi(key) i= 1,2,3 … k;<br>当H1 = RH1(key) 发生冲突时，再用H2 = RH2(key) 进行计算，<br>直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间</p><p>###dict的hash冲突解决<br>使用开放寻址的二次探查，如果使用的容量超过数组大小的2/3，<br>就申请更大的容量。数组大小较小的时候resize为*4，<br>较大的时候resize*2</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;python中大部分的运行机制当中都采用了dict来进行数据的管理，所以为了最高效的查询性能，&lt;br&gt;dict底层选择了基于哈希表实现。其中在python3.6之前，dict的实现里将数据存在了hash表里，&lt;br&gt;所以之前的dict是无序且十分消耗内存的，而在python</summary>
      
    
    
    
    <category term="python源码解析" scheme="http://example.com/categories/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>int部分源码解析(cpython)</title>
    <link href="http://example.com/2021/06/18/python/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/int%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/18/python/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/int%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-18T01:03:51.510Z</published>
    <updated>2021-06-17T08:19:10.042Z</updated>
    
    <content type="html"><![CDATA[<p>Python中有int对象，但是在cPython中可是没有这个对象的<br>cPython中只有PyLongObject</p><h2 id="PyLongObject"><a href="#PyLongObject" class="headerlink" title="PyLongObject"></a>PyLongObject</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct _longobject &#123;</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    struct _typeobject *ob_type;    </span><br><span class="line">    Py_ssize_t ob_size; &#x2F;* Number of items in variable part *&#x2F; </span><br><span class="line">    digit ob_digit[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>1.ob_refcnt 为引用计数</li><li>2.ob_type 为一个指针，指向了一个类型</li><li>3.ob_size 为一个整数，表示ob_digit的长度</li><li>4.ob_digit 为一个数组，可以当成一个指针，存储了具体的数值</li></ul><h2 id="整数存储方式"><a href="#整数存储方式" class="headerlink" title="整数存储方式"></a>整数存储方式</h2><p>为什么一个整数要那么复杂的表示方式？Python的整数是不会溢出的，<br>他可以表示任意大的数据，因为使用简单的 c 语言是做不到的，<br>所以定义了一个那么复杂的东西。</p><h3 id="普通进位法"><a href="#普通进位法" class="headerlink" title="普通进位法"></a>普通进位法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">按照digit数组位数</span><br><span class="line">digit[0]*1 + digit[1]*10 + digit[2]*100 .....</span><br><span class="line">这样存储</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">### 负数存储</span><br><span class="line">也是放到ob_size中，如果ob_size为-1那么代表ob_digit长度为1，但是这个数为负数</span><br><span class="line"></span><br><span class="line">### 部分源码</span><br><span class="line">#### 创建int</span><br><span class="line">小于C中long类型大小的数值基于PyLong_FromLong创建，大于用PyLong_FromString</span><br><span class="line">- 步骤</span><br><span class="line">    - 1.检查如果是小整数，则直接返回缓冲池的小整数对象，在python3中缓冲池范围是[-5, 257)</span><br><span class="line">    - 2.将数值和正负数的标识分开</span><br><span class="line">    - 3.对于小于PyLong_SHIFT位的数进入快速通道，PyLong_SHIFT的值基于当前系统中定义指针的大小确定</span><br><span class="line">    （指针在32位中size为4，64位中为8，因此例如32位平台下32768以下的数字都可以进入该通道）</span><br><span class="line">    - 4.对于指针大小为4字节的情况（例如32位系统），申请对象空间</span><br><span class="line">    - 5.对于较大的数值，需要获取位数，然后申请对应大小的long对象</span><br><span class="line">    </span><br><span class="line">- [源码](https:&#x2F;&#x2F;github.com&#x2F;python&#x2F;cpython&#x2F;blob&#x2F;main&#x2F;Objects&#x2F;longobject.c)</span><br></pre></td></tr></table></figure><p>PyObject *<br>PyLong_FromLong(long ival)<br>{<br>    PyLongObject <em>v;<br>    // abs_ival中存放绝对值数值<br>    unsigned long abs_ival;<br>    unsigned long t;  /</em> unsigned so &gt;&gt; doesn’t propagate sign bit */<br>    int ndigits = 0;<br>    // 数值标记：正数(1)，负数(-1)，零(0)<br>    int sign;<br>    // 检查如果是小整数，则直接返回缓冲池的小整数对象，python3缓冲池范围是[-5, 257)<br>    CHECK_SMALL_INT(ival);<br>    // 将数值和正负数的标识分开<br>    if (ival &lt; 0) {<br>        abs_ival = 0U-(unsigned long)ival;<br>        sign = -1;<br>    }<br>    else {<br>        abs_ival = (unsigned long)ival;<br>        sign = ival == 0 ? 0 : 1;<br>    }</p><pre><code>// 对于小于PyLong_SHIFT位的数进入快速通道，PyLong_SHIFT的值基于当前系统中定义指针的大小确定// （指针在32位中size为4，64位中为8，因此例如32位平台下32768以下的数字都可以进入该通道）if (!(abs_ival &gt;&gt; PyLong_SHIFT)) &#123;    // 创建一个数值指向区域size为1*sizeof(digit)的long对象    v = _PyLong_New(1);    if (v) &#123;        // 可以看出ob_size用来标识是正数、负数还是0        Py_SIZE(v) = sign;        // ob_digit[0]里存入的是无符号的数值        v-&gt;ob_digit[0] = Py_SAFE_DOWNCAST(            abs_ival, unsigned long, digit);    &#125;    return (PyObject*)v;&#125;</code></pre><p>// 对于指针大小为4字节的情况（例如32位系统），申请对象空间的方式<br>#if PyLong_SHIFT==15<br>    /* 2 digits <em>/<br>    if (!(abs_ival &gt;&gt; 2</em>PyLong_SHIFT)) {<br>        v = _PyLong_New(2);<br>        if (v) {<br>            Py_SIZE(v) = 2<em>sign;<br>            v-&gt;ob_digit[0] = Py_SAFE_DOWNCAST(<br>                abs_ival &amp; PyLong_MASK, unsigned long, digit);<br>            v-&gt;ob_digit[1] = Py_SAFE_DOWNCAST(<br>                  abs_ival &gt;&gt; PyLong_SHIFT, unsigned long, digit);<br>        }<br>        return (PyObject</em>)v;<br>    }<br>#endif</p><pre><code>// 对于较大的数值，需要获取位数，然后申请对应大小的long对象t = abs_ival;// 获取数值所需的位数while (t) &#123;    ++ndigits;    t &gt;&gt;= PyLong_SHIFT;&#125;// 后面的逻辑跟之前的创建方式基本一样v = _PyLong_New(ndigits);if (v != NULL) &#123;    digit *p = v-&gt;ob_digit;    Py_SIZE(v) = ndigits*sign;    t = abs_ival;    while (t) &#123;        *p++ = Py_SAFE_DOWNCAST(            t &amp; PyLong_MASK, unsigned long, digit);        t &gt;&gt;= PyLong_SHIFT;    &#125;&#125;return (PyObject *)v;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 小整数缓冲池</span><br></pre></td></tr></table></figure><p>// #define NSMALLPOSINTS           257<br>// #define NSMALLNEGINTS           5<br>static PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];</p><p>// 获取小整数对象<br>static PyObject *<br>get_small_int(sdigit ival)<br>{<br>    PyObject *v;<br>    assert(-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS);<br>    // 在符合小整数的范围内，返回直接缓冲池中的对象<br>    v = (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS];<br>    Py_INCREF(v);<br>    …<br>    return v;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对于小整数使用较多的场景，我们可以通过修改小整数的缓冲池范围来进行优化</span><br><span class="line"></span><br><span class="line">#### long_add</span><br><span class="line">由于python中的int属于不可变类型数据，因此在进行加法运算时，</span><br><span class="line">会创建一个新的int对象来存储计算的结果值，并且由于int中数据的</span><br><span class="line">存储是基于数据，因此在计算时实际上模拟了从低位开始逐位相加</span><br><span class="line">算的方式来进行运算，而通过这种存储和计算方式</span><br><span class="line"></span><br><span class="line">- long_add</span><br></pre></td></tr></table></figure><p>static PyObject *<br>long_add(PyLongObject *a, PyLongObject *b)<br>{<br>    PyLongObject *z;</p><pre><code>CHECK_BINOP(a, b);if (Py_ABS(Py_SIZE(a)) &lt;= 1 &amp;&amp; Py_ABS(Py_SIZE(b)) &lt;= 1) &#123;    return PyLong_FromLong(MEDIUM_VALUE(a) + MEDIUM_VALUE(b));&#125;if (Py_SIZE(a) &lt; 0) &#123;    if (Py_SIZE(b) &lt; 0) &#123;        z = x_add(a, b);        if (z != NULL) &#123;            assert(Py_REFCNT(z) == 1);            Py_SIZE(z) = -(Py_SIZE(z));        &#125;    &#125;    else        z = x_sub(b, a);&#125;else &#123;    if (Py_SIZE(b) &lt; 0)        z = x_sub(a, b);    else        z = x_add(a, b);&#125;return (PyObject *)z;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- x_add</span><br></pre></td></tr></table></figure><p>static PyLongObject *<br>x_add(PyLongObject *a, PyLongObject *b)<br>{<br>    Py_ssize_t size_a = Py_ABS(Py_SIZE(a)), size_b = Py_ABS(Py_SIZE(b));<br>    PyLongObject *z;<br>    Py_ssize_t i;<br>    digit carry = 0;</p><pre><code>// 如果a比b小，就交换两个数，以保证a是大的那个数if (size_a &lt; size_b) &#123;    &#123; PyLongObject *temp = a; a = b; b = temp; &#125;    &#123; Py_ssize_t size_temp = size_a;        size_a = size_b;        size_b = size_temp; &#125;&#125;// 以最大的那个值的size+1为新创建的long对象大小z = _PyLong_New(size_a+1);if (z == NULL)    return NULL;// 低位开始逐位相加（两个数中小的那个数的最高位及以下位相加）for (i = 0; i &lt; size_b; ++i) &#123;    carry += a-&gt;ob_digit[i] + b-&gt;ob_digit[i];    z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;    carry &gt;&gt;= PyLong_SHIFT;&#125;// 高位只剩下a的值，直接将a的值填充for (; i &lt; size_a; ++i) &#123;    carry += a-&gt;ob_digit[i];    z-&gt;ob_digit[i] = carry &amp; PyLong_MASK;    carry &gt;&gt;= PyLong_SHIFT;&#125;// 新创建的对象保存对应结果z-&gt;ob_digit[i] = carry;// long_normalize将数值前面的0删除（并没有真正删除释放，而是改变其允许指向数值的范围大小）return long_normalize(z);</code></pre><p>}<br>```</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python中有int对象，但是在cPython中可是没有这个对象的&lt;br&gt;cPython中只有PyLongObject&lt;/p&gt;
&lt;h2 id=&quot;PyLongObject&quot;&gt;&lt;a href=&quot;#PyLongObject&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="python源码解析" scheme="http://example.com/categories/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>list源码解析(Cpython)</title>
    <link href="http://example.com/2021/06/18/python/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/list%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/18/python/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/list%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-18T01:03:51.510Z</published>
    <updated>2021-06-17T08:16:59.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码文件"><a href="#源码文件" class="headerlink" title="源码文件"></a>源码文件</h2><p><a href="https://github.com/python/cpython/blob/main/Objects/listobject.c">https://github.com/python/cpython/blob/main/Objects/listobject.c</a></p><h2 id="PyListObject的定义"><a href="#PyListObject的定义" class="headerlink" title="PyListObject的定义"></a>PyListObject的定义</h2><p>在列表对象接口listobject.h中，PyListObject的定义是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    &#x2F;* Vector of pointers to list elements.  list[0] is ob_item[0], etc. *&#x2F;</span><br><span class="line">    PyObject **ob_item;</span><br><span class="line"></span><br><span class="line">    &#x2F;* ob_item contains space for &#39;allocated&#39; elements.  The number</span><br><span class="line">     * currently in use is ob_size.</span><br><span class="line">     * Invariants:</span><br><span class="line">     *     0 &lt;&#x3D; ob_size &lt;&#x3D; allocated</span><br><span class="line">     *     len(list) &#x3D;&#x3D; ob_size</span><br><span class="line">     *     ob_item &#x3D;&#x3D; NULL implies ob_size &#x3D;&#x3D; allocated &#x3D;&#x3D; 0</span><br><span class="line">     * list.sort() temporarily sets allocated to -1 to detect mutations.</span><br><span class="line">     *</span><br><span class="line">     * Items must normally not be NULL, except during construction when</span><br><span class="line">     * the list is not yet visible outside the function that builds it.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Py_ssize_t allocated;</span><br><span class="line">&#125; PyListObject;</span><br></pre></td></tr></table></figure><ul><li>1.ob_item是指向了元素列表所在的内存块的首地址</li><li>2.allocated维护了当前列表中的可容纳的元素的总数<br>我们知道，用户选用list正是为了可以频繁的执行插入或删除等操作，如果是需要存多少就申请多大的内存，<br>这种内存管理显然是低效的。那么Python内部是怎么实现的呢？这就与刚才所提到的allocated有关了，我们知道，<br>在PyObject_VAR_HEAD中有一个ob_size，在PyListObject中，每一次需要申请内存时，总会申请一大块内存存，<br>这时申请的总内存的大小记录记录在allocated中，而其中实际被使用了的内存的数量则记录在ob_size中。</li></ul><h2 id="PyListObject对象的创建与维护"><a href="#PyListObject对象的创建与维护" class="headerlink" title="PyListObject对象的创建与维护"></a>PyListObject对象的创建与维护</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li><p>1.首先，进行溢出检查</p></li><li><p>2.List对象的创建Python中的list对象实际上是分为两部分</p><ul><li>1.PyListObject对象本身</li><li>2.PyListObject对象维护的元素列表，而这两块内存是通过ob_item建立联系的</li></ul></li><li><p>3.在创建PyListObject对象时，检查缓冲池中free_list是否有可用的对象，如果有，则直接使用，</p></li><li><p>4.若没有可用对象，则通过PyObject_GC_New在系统堆中申请内存</p></li><li><p>5.当创建了新的PyListObject对象之后，会根据调用PyList_New是传递的<br>size参数创建ListObject对象所维护的元素列表。</p></li></ul><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>Python对于创建一个列表，提供了唯一的一条途径，就是PyList_New()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyList_New(Py_ssize_t size)</span><br><span class="line">&#123;</span><br><span class="line">PyListObject *op;</span><br><span class="line">size_t nbytes;</span><br><span class="line">#ifdef SHOW_ALLOC_COUNT</span><br><span class="line">static int initialized &#x3D; 0;</span><br><span class="line">if (!initialized) &#123;</span><br><span class="line">Py_AtExit(show_alloc);</span><br><span class="line">initialized &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">if (size &lt; 0) &#123;</span><br><span class="line">PyErr_BadInternalCall();</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;进行溢出检查</span><br><span class="line">if ((size_t)size &gt; PY_SIZE_MAX &#x2F; sizeof(PyObject *))</span><br><span class="line">return PyErr_NoMemory();</span><br><span class="line">nbytes &#x3D; size * sizeof(PyObject *);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;为PyListObject对象申请空间，使用到缓冲池技术</span><br><span class="line">if (numfree) &#123;</span><br><span class="line">numfree--;</span><br><span class="line">op &#x3D; free_list[numfree];</span><br><span class="line">_Py_NewReference((PyObject *)op);</span><br><span class="line">#ifdef SHOW_ALLOC_COUNT</span><br><span class="line">count_reuse++;</span><br><span class="line">#endif</span><br><span class="line">&#125; else &#123;</span><br><span class="line">op &#x3D; PyObject_GC_New(PyListObject, &amp;PyList_Type);</span><br><span class="line">if (op &#x3D;&#x3D; NULL)</span><br><span class="line">return NULL;</span><br><span class="line">#ifdef SHOW_ALLOC_COUNT</span><br><span class="line">count_alloc++;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;为PyListObject对象中维护的元素列表申请空间</span><br><span class="line">if (size &lt;&#x3D; 0)</span><br><span class="line">op-&gt;ob_item &#x3D; NULL;</span><br><span class="line">else &#123;</span><br><span class="line">op-&gt;ob_item &#x3D; (PyObject **) PyMem_MALLOC(nbytes);</span><br><span class="line">if (op-&gt;ob_item &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">Py_DECREF(op);</span><br><span class="line">return PyErr_NoMemory();</span><br><span class="line">&#125;</span><br><span class="line">memset(op-&gt;ob_item, 0, nbytes);</span><br><span class="line">&#125;</span><br><span class="line">Py_SIZE(op) &#x3D; size;</span><br><span class="line">op-&gt;allocated &#x3D; size;</span><br><span class="line">_PyObject_GC_TRACK(op);</span><br><span class="line">return (PyObject *) op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置元素"><a href="#设置元素" class="headerlink" title="设置元素"></a>设置元素</h3><p>元素创建好了，下一步就是向元素中添加元素了,通过PyList_SetItem()实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list[5] &#x3D; 1</span><br></pre></td></tr></table></figure><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ul><li>1.进行类型检查</li><li>2.然后进行索引的有效性检查</li><li>3.当类型检查和索引检查均通过的时候，就可以将待加入的Pyobject*指针放在指定的位置。</li></ul><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PyList_SetItem(register PyObject *op, register Py_ssize_t i,</span><br><span class="line">register PyObject *newitem)</span><br><span class="line">&#123;</span><br><span class="line">register PyObject *olditem;</span><br><span class="line">register PyObject **p;</span><br><span class="line">if (!PyList_Check(op)) &#123;</span><br><span class="line">Py_XDECREF(newitem);</span><br><span class="line">PyErr_BadInternalCall();</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;索引检查</span><br><span class="line">if (i &lt; 0 || i &gt;&#x3D; Py_SIZE(op)) &#123;</span><br><span class="line">Py_XDECREF(newitem);</span><br><span class="line">PyErr_SetString(PyExc_IndexError,</span><br><span class="line">&quot;list assignment index out of range&quot;);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;存放元素</span><br><span class="line">p &#x3D; ((PyListObject *)op) -&gt; ob_item + i;</span><br><span class="line">olditem &#x3D; *p;</span><br><span class="line">*p &#x3D; newitem;</span><br><span class="line">Py_XDECREF(olditem);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>插入元素和设置元素的不同在于:设置元素不会将ob_item指向的内存<br>发生变化，而插入内存可能会导致ob_item指向的内存发生变化。</p><ul><li>比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; [0, 0, 0, 0]</span><br><span class="line">a[2] &#x3D; 3</span><br><span class="line">print(a)</span><br><span class="line">[0, 0, 3, 0]</span><br><span class="line">a.insert(2,3)</span><br><span class="line">[0, 0, 2, 3, 0]</span><br></pre></td></tr></table></figure>这个插入动作确实导致了元素列表的内存发生变化。关于插入，在列表中有两种操作：insert()和append()。</li></ul><h4 id="insert插入步骤"><a href="#insert插入步骤" class="headerlink" title="insert插入步骤"></a>insert插入步骤</h4><ul><li>1.参数检查</li><li>2.从新调整列表容量通过 list_resize 方法确定是否需要申请内存</li><li>3.确定插入点</li><li>4.插入元素</li></ul><h4 id="insert源码"><a href="#insert源码" class="headerlink" title="insert源码"></a>insert源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">ins1(PyListObject *self, Py_ssize_t where, PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i, n &#x3D; Py_SIZE(self);</span><br><span class="line">    PyObject **items;</span><br><span class="line">    if (v &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n &#x3D;&#x3D; PY_SSIZE_T_MAX) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">            &quot;cannot add more objects to list&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (list_resize(self, n+1) &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    if (where &lt; 0) &#123;</span><br><span class="line">        where +&#x3D; n;</span><br><span class="line">        if (where &lt; 0)</span><br><span class="line">            where &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (where &gt; n)</span><br><span class="line">        where &#x3D; n;</span><br><span class="line">    items &#x3D; self-&gt;ob_item;</span><br><span class="line">    for (i &#x3D; n; --i &gt;&#x3D; where; )</span><br><span class="line">        items[i+1] &#x3D; items[i];</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    items[where] &#x3D; v;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="append步骤"><a href="#append步骤" class="headerlink" title="append步骤"></a>append步骤</h4><ul><li>1.参数检查</li><li>2.容量检查</li><li>3.调用 list_resize 方法检查是否需要申请内存</li><li>4.添加元素</li></ul><h4 id="append源码"><a href="#append源码" class="headerlink" title="append源码"></a>append源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">PyList_Append(PyObject *op, PyObject *newitem)</span><br><span class="line">&#123;</span><br><span class="line">    if (PyList_Check(op) &amp;&amp; (newitem !&#x3D; NULL))</span><br><span class="line">        return app1((PyListObject *)op, newitem);</span><br><span class="line">    PyErr_BadInternalCall();</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列表转元组"><a href="#列表转元组" class="headerlink" title="列表转元组"></a>列表转元组</h3><p>其实就是新建一个大小和列表一样大小的数组，并将该列表内的元素添加到元组中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyList_AsTuple(PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *w;</span><br><span class="line">    PyObject **p, **q;</span><br><span class="line">    Py_ssize_t n;</span><br><span class="line">    if (v &#x3D;&#x3D; NULL || !PyList_Check(v)) &#123;</span><br><span class="line">        PyErr_BadInternalCall();</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    n &#x3D; Py_SIZE(v);</span><br><span class="line">    w &#x3D; PyTuple_New(n);</span><br><span class="line">    if (w &#x3D;&#x3D; NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    p &#x3D; ((PyTupleObject *)w)-&gt;ob_item;</span><br><span class="line">    q &#x3D; ((PyListObject *)v)-&gt;ob_item;</span><br><span class="line">    while (--n &gt;&#x3D; 0) &#123;</span><br><span class="line">        Py_INCREF(*q);</span><br><span class="line">        *p &#x3D; *q;</span><br><span class="line">        p++;</span><br><span class="line">        q++;</span><br><span class="line">    &#125;</span><br><span class="line">    return w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列表反转"><a href="#列表反转" class="headerlink" title="列表反转"></a>列表反转</h3><p>双向指针反转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">reverse_slice(PyObject **lo, PyObject **hi)</span><br><span class="line">&#123;</span><br><span class="line">    assert(lo &amp;&amp; hi);</span><br><span class="line"></span><br><span class="line">    --hi;</span><br><span class="line">    while (lo &lt; hi) &#123;</span><br><span class="line">        PyObject *t &#x3D; *lo;</span><br><span class="line">        *lo &#x3D; *hi;</span><br><span class="line">        *hi &#x3D; t;</span><br><span class="line">        ++lo;</span><br><span class="line">        --hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列表extend"><a href="#列表extend" class="headerlink" title="列表extend"></a>列表extend</h3><p>extend传说中的鸭子类型（动态类型），不在乎对象的确切形态，只要是可迭代对象就可以操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (PyList_CheckExact(iterable) || PyTuple_CheckExact(iterable) ||</span><br><span class="line">                (PyObject *)self &#x3D;&#x3D; iterable) &#123;</span><br><span class="line">        PyObject **src, **dest;</span><br><span class="line">        iterable &#x3D; PySequence_Fast(iterable, &quot;argument must be iterable&quot;);</span><br><span class="line">        if (!iterable)</span><br><span class="line">            return NULL;</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>对于一个容器而言，除了创建，插入这些操作，肯定是还得有删除操作的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">remove()</span><br><span class="line">a &#x3D; [1, 2, 3, 4]</span><br><span class="line">print a.remove(3)</span><br><span class="line">[1, 2, 4]</span><br></pre></td></tr></table></figure><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ul><li>1.遍历ob_item对比remove的对象</li><li>2.返回cmp大于0调用list_ass_slice删除后判断是否还有元素</li><li>3.如果本来就没有这个元素直接跳到最后报错<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: list.remove(x): x not in list</span><br></pre></td></tr></table></figure></li></ul><h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static PyObject *</span><br><span class="line">list_remove(PyListObject *self, PyObject *value)</span><br><span class="line">&#x2F;*[clinic end generated code: output&#x3D;f087e1951a5e30d1 input&#x3D;2dc2ba5bb2fb1f82]*&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; Py_SIZE(self); i++) &#123;</span><br><span class="line">        PyObject *obj &#x3D; self-&gt;ob_item[i];</span><br><span class="line">        Py_INCREF(obj);</span><br><span class="line">        int cmp &#x3D; PyObject_RichCompareBool(obj, value, Py_EQ);</span><br><span class="line">        Py_DECREF(obj);</span><br><span class="line">        if (cmp &gt; 0) &#123;</span><br><span class="line">            if (list_ass_slice(self, i, i+1,</span><br><span class="line">                               (PyObject *)NULL) &#x3D;&#x3D; 0)</span><br><span class="line">                Py_RETURN_NONE;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (cmp &lt; 0)</span><br><span class="line">            return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    PyErr_SetString(PyExc_ValueError, &quot;list.remove(x): x not in list&quot;);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PyListObject对象缓冲池"><a href="#PyListObject对象缓冲池" class="headerlink" title="PyListObject对象缓冲池"></a>PyListObject对象缓冲池</h2><ul><li><p>1.在创建PyListObject对象时，会首先检查缓冲区中的free_lists中是否有可用的对象，如果没有。</p><ul><li>1.创建PyListObject对象</li><li>2.然后创建PyListObject对象所维护的元素列表，与之对应</li></ul></li><li><p>2.在销毁一个list时销毁的过程也是分离的。</p><ul><li>1.销毁PyListObject所维护的元素列表</li><li>2.然后释放PyListObject对象自身</li></ul></li><li><p>3.在删除PylsitObject对象（较小的）自身时</p><ul><li>1.Python会先检查我们开始提到的那个缓冲池free_list，查看其中缓存的PyListObject的数量是否已经满了</li><li>2.如果没有，就将待删除的PyListObject对象放到缓冲池中，以备后用</li></ul></li></ul><p>因此，那个在Python启动时空荡荡的缓冲池原来都是被本应该死去的PyListObject对象给填充了，在以后需要创建新的PyListObject的时候，<br>Python会首先唤醒这些对象，重新分配Pyobject*元素列表占用的内存，重新拥抱新的对象。</p><h2 id="list-resize补充"><a href="#list-resize补充" class="headerlink" title="list_resize补充"></a>list_resize补充</h2><p>list作为一个可变对象，自然离不开内存的增加和减少(append、extend、insert、remove、pop等等都涉及到)，所以这方面对性能的影响也是有的。</p><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><ul><li>1.如果allocated/2 &lt;= newsize &lt;= allocated则allocated不变直接把ob_size设置成Py_SET_SIZE(self, newsize)</li><li><ol start="2"><li>否则<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocated &#x3D; newsize + ((newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6))</span><br><span class="line">ob_size &#x3D; newsize</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">list_resize(PyListObject *self, Py_ssize_t newsize)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject **items;</span><br><span class="line">    size_t new_allocated, num_allocated_bytes;</span><br><span class="line">    Py_ssize_t allocated &#x3D; self-&gt;allocated;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Bypass realloc() when a previous overallocation is large enough</span><br><span class="line">       to accommodate the newsize.  If the newsize falls lower than half</span><br><span class="line">       the allocated size, then proceed with the realloc() to shrink the list.</span><br><span class="line">    *&#x2F;</span><br><span class="line">    if (allocated &gt;&#x3D; newsize &amp;&amp; newsize &gt;&#x3D; (allocated &gt;&gt; 1)) &#123;</span><br><span class="line">        assert(self-&gt;ob_item !&#x3D; NULL || newsize &#x3D;&#x3D; 0);</span><br><span class="line">        Py_SET_SIZE(self, newsize);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* This over-allocates proportional to the list size, making room</span><br><span class="line">     * for additional growth.  The over-allocation is mild, but is</span><br><span class="line">     * enough to give linear-time amortized behavior over a long</span><br><span class="line">     * sequence of appends() in the presence of a poorly-performing</span><br><span class="line">     * system realloc().</span><br><span class="line">     * Add padding to make the allocated size multiple of 4.</span><br><span class="line">     * The growth pattern is:  0, 4, 8, 16, 24, 32, 40, 52, 64, 76, ...</span><br><span class="line">     * Note: new_allocated won&#39;t overflow because the largest possible value</span><br><span class="line">     *       is PY_SSIZE_T_MAX * (9 &#x2F; 8) + 6 which always fits in a size_t.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    new_allocated &#x3D; ((size_t)newsize + (newsize &gt;&gt; 3) + 6) &amp; ~(size_t)3;</span><br><span class="line">    &#x2F;* Do not overallocate if the new size is closer to overallocated size</span><br><span class="line">     * than to the old size.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (newsize - Py_SIZE(self) &gt; (Py_ssize_t)(new_allocated - newsize))</span><br><span class="line">        new_allocated &#x3D; ((size_t)newsize + 3) &amp; ~(size_t)3;</span><br><span class="line"></span><br><span class="line">    if (newsize &#x3D;&#x3D; 0)</span><br><span class="line">        new_allocated &#x3D; 0;</span><br><span class="line">    num_allocated_bytes &#x3D; new_allocated * sizeof(PyObject *);</span><br><span class="line">    items &#x3D; (PyObject **)PyMem_Realloc(self-&gt;ob_item, num_allocated_bytes);</span><br><span class="line">    if (items &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    self-&gt;ob_item &#x3D; items;</span><br><span class="line">    Py_SET_SIZE(self, newsize);</span><br><span class="line">    self-&gt;allocated &#x3D; new_allocated;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="python分析"><a href="#python分析" class="headerlink" title="python分析"></a>python分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">for i in range(100):</span><br><span class="line">if sys.getsizeof(a) not in b:</span><br><span class="line">print(i, sys.getsizeof(a))</span><br><span class="line">b.add(sys.getsizeof(a))</span><br><span class="line">a.append(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0 56</span><br><span class="line">1 88</span><br><span class="line">5 120</span><br><span class="line">9 184</span><br><span class="line">17 256</span><br><span class="line">26 336</span><br><span class="line">36 424</span><br><span class="line">47 520</span><br><span class="line">59 632</span><br><span class="line">73 760</span><br><span class="line">89 904</span><br></pre></td></tr></table></figure><h2 id="append-amp-insert-amp-extend性能分析"><a href="#append-amp-insert-amp-extend性能分析" class="headerlink" title="append&amp;insert&amp;extend性能分析"></a>append&amp;insert&amp;extend性能分析</h2><p>insert的逻辑中，需要对插入部分后面的数据进行后移操作，<br>以及对插入位置进行一些范围处理，所以效率上会比append差一些z，<br>在append里每添加一条数据都需要进行尺寸判断，不够则重新申请，<br>而extend则是一口气算出最终需要的尺寸，只需要申请一次即可，<br>所以效率上append会比extend差一些。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;源码文件&quot;&gt;&lt;a href=&quot;#源码文件&quot; class=&quot;headerlink&quot; title=&quot;源码文件&quot;&gt;&lt;/a&gt;源码文件&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/python/cpython/blob/main/Objects/l</summary>
      
    
    
    
    <category term="python源码解析" scheme="http://example.com/categories/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>str部分源码解析(Cpython python3)</title>
    <link href="http://example.com/2021/06/18/python/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/str%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/18/python/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/str%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-18T01:03:51.510Z</published>
    <updated>2021-06-17T02:09:00.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码文件"><a href="#源码文件" class="headerlink" title="源码文件"></a>源码文件</h2><p><a href="https://github.com/python/cpython/blob/main/Objects/unicodeobject.c">https://github.com/python/cpython/blob/main/Objects/unicodeobject.c</a></p><h2 id="字符对象创建"><a href="#字符对象创建" class="headerlink" title="字符对象创建"></a>字符对象创建</h2><p>Python中字符串（strs）对象最重要的创建方法为PyUnicode_DecodeUTF8Stateful，<br>最终都会调用到PyUnicode_DecodeUTF8Stateful：如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; &#39;hello&#39;</span><br><span class="line">b &#x3D; str(&#39;world&#39;)</span><br></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">static PyUnicodeObject *</span><br><span class="line">_PyUnicode_New(Py_ssize_t length)</span><br><span class="line">&#123;</span><br><span class="line">    PyUnicodeObject *unicode;</span><br><span class="line">    size_t new_size;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Optimization for empty strings *&#x2F;</span><br><span class="line">    if (length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return (PyUnicodeObject *)unicode_new_empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Ensure we won&#39;t overflow the size. *&#x2F;</span><br><span class="line">    if (length &gt; ((PY_SSIZE_T_MAX &#x2F; (Py_ssize_t)sizeof(Py_UNICODE)) - 1)) &#123;</span><br><span class="line">        return (PyUnicodeObject *)PyErr_NoMemory();</span><br><span class="line">    &#125;</span><br><span class="line">    if (length &lt; 0) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_SystemError,</span><br><span class="line">                        &quot;Negative size passed to _PyUnicode_New&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unicode &#x3D; PyObject_New(PyUnicodeObject, &amp;PyUnicode_Type);</span><br><span class="line">    if (unicode &#x3D;&#x3D; NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    new_size &#x3D; sizeof(Py_UNICODE) * ((size_t)length + 1);</span><br><span class="line"></span><br><span class="line">    _PyUnicode_WSTR_LENGTH(unicode) &#x3D; length;</span><br><span class="line">    _PyUnicode_HASH(unicode) &#x3D; -1;</span><br><span class="line">    _PyUnicode_STATE(unicode).interned &#x3D; 0;</span><br><span class="line">    _PyUnicode_STATE(unicode).kind &#x3D; 0;</span><br><span class="line">    _PyUnicode_STATE(unicode).compact &#x3D; 0;</span><br><span class="line">    _PyUnicode_STATE(unicode).ready &#x3D; 0;</span><br><span class="line">    _PyUnicode_STATE(unicode).ascii &#x3D; 0;</span><br><span class="line">    _PyUnicode_DATA_ANY(unicode) &#x3D; NULL;</span><br><span class="line">    _PyUnicode_LENGTH(unicode) &#x3D; 0;</span><br><span class="line">    _PyUnicode_UTF8(unicode) &#x3D; NULL;</span><br><span class="line">    _PyUnicode_UTF8_LENGTH(unicode) &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    _PyUnicode_WSTR(unicode) &#x3D; (Py_UNICODE*) PyObject_Malloc(new_size);</span><br><span class="line">    if (!_PyUnicode_WSTR(unicode)) &#123;</span><br><span class="line">        Py_DECREF(unicode);</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Initialize the first element to guard against cases where</span><br><span class="line">     * the caller fails before initializing str -- unicode_resize()</span><br><span class="line">     * reads str[0], and the Keep-Alive optimization can keep memory</span><br><span class="line">     * allocated for str alive across a call to unicode_dealloc(unicode).</span><br><span class="line">     * We don&#39;t want unicode_resize to read uninitialized memory in</span><br><span class="line">     * that case.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    _PyUnicode_WSTR(unicode)[0] &#x3D; 0;</span><br><span class="line">    _PyUnicode_WSTR(unicode)[length] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    assert(_PyUnicode_CheckConsistency((PyObject *)unicode, 0));</span><br><span class="line">    return unicode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串三大特性"><a href="#字符串三大特性" class="headerlink" title="字符串三大特性"></a>字符串三大特性</h2><ul><li><p>1.空串缓存：空串（unicode_empty）为同一个地址第二次需要空串时，只是将计<br>数加1，在_PyUnicodeWriter_Finish中实现空串缓存。</p></li><li><p>2.字符缓冲池：字符（unicode_latin1）为同一个地址，<br>第二次需要该字符时，只是将计数加1，在get_latin1_char中实现字符缓存。</p></li><li><p>3.常量字符串池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; &#39;hello&#39;</span><br><span class="line">b &#x3D; &#39;hello&#39;</span><br><span class="line">a is b  #True</span><br></pre></td></tr></table></figure><p>由上例可以看出Python对常量字符串做了缓存。<br>缓存的关键性实现在PyUnicode_InternInPlace方法中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; unicodeobject.c</span><br><span class="line">static PyObject *interned &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">PyUnicode_InternInPlace(PyObject **p)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *s &#x3D; *p;</span><br><span class="line">    PyObject *t;</span><br><span class="line">#ifdef Py_DEBUG</span><br><span class="line">    assert(s !&#x3D; NULL);</span><br><span class="line">    assert(_PyUnicode_CHECK(s));</span><br><span class="line">#else</span><br><span class="line">    if (s &#x3D;&#x3D; NULL || !PyUnicode_Check(s))</span><br><span class="line">        return;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;* If it&#39;s a subclass, we don&#39;t really know what putting</span><br><span class="line">       it in the interned dict might do. *&#x2F;</span><br><span class="line">    if (!PyUnicode_CheckExact(s))</span><br><span class="line">        return;</span><br><span class="line">    if (PyUnicode_CHECK_INTERNED(s))</span><br><span class="line">        return;</span><br><span class="line">    if (interned &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        interned &#x3D; PyDict_New();</span><br><span class="line">        if (interned &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            PyErr_Clear(); &#x2F;* Don&#39;t leave an exception *&#x2F;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_ALLOW_RECURSION</span><br><span class="line">    t &#x3D; PyDict_SetDefault(interned, s, s);</span><br><span class="line">    Py_END_ALLOW_RECURSION</span><br><span class="line">    if (t &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        PyErr_Clear();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (t !&#x3D; s) &#123;</span><br><span class="line">        Py_INCREF(t);</span><br><span class="line">        Py_SETREF(*p, t);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* The two references in interned are not counted by refcnt.</span><br><span class="line">       The deallocator will take care of this *&#x2F;</span><br><span class="line">    Py_REFCNT(s) -&#x3D; 2;</span><br><span class="line">    _PyUnicode_STATE(s).interned &#x3D; SSTATE_INTERNED_MORTAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="神奇的intern机制"><a href="#神奇的intern机制" class="headerlink" title="神奇的intern机制"></a>神奇的intern机制</h3><p>Python解释器中使用了 intern（字符串驻留）的技术来提高字符串效率，什么是intern机制？<br>就是同样的字符串对象仅仅会保存一份，放在一个字符串储蓄池</p><ul><li>1.如果有空格不使用intern机制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1&#x3D;&quot;hello&quot;</span><br><span class="line">&gt;&gt;&gt; s2&#x3D;&quot;hello&quot;</span><br><span class="line">&gt;&gt;&gt; s1 is s2</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s1&#x3D;&quot;hell o&quot;</span><br><span class="line">&gt;&gt;&gt; s2&#x3D;&quot;hell o&quot;</span><br><span class="line">&gt;&gt;&gt; s1 is s2</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li><li>2.如果一个字符串长度超过20个字符，不启动intern机制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 &#x3D; &quot;a&quot; * 20</span><br><span class="line">&gt;&gt;&gt; s2 &#x3D; &quot;a&quot; * 20</span><br><span class="line">&gt;&gt;&gt; s1 is s2</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s1 &#x3D; &quot;a&quot; * 21</span><br><span class="line">&gt;&gt;&gt; s2 &#x3D; &quot;a&quot; * 21</span><br><span class="line">&gt;&gt;&gt; s1 is s2</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;源码文件&quot;&gt;&lt;a href=&quot;#源码文件&quot; class=&quot;headerlink&quot; title=&quot;源码文件&quot;&gt;&lt;/a&gt;源码文件&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/python/cpython/blob/main/Objects/u</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>万物皆对象</title>
    <link href="http://example.com/2021/06/18/python/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/python%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2021/06/18/python/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/python%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-06-18T01:03:51.510Z</published>
    <updated>2021-06-16T14:45:54.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象分类"><a href="#对象分类" class="headerlink" title="对象分类"></a>对象分类</h2><ul><li><p>Fundamental对象<br>类型对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type</span><br></pre></td></tr></table></figure></li><li><p>Numeric对象<br>数值对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">integer</span><br><span class="line">float</span><br><span class="line">boolean</span><br></pre></td></tr></table></figure></li><li><p>Sequence对象<br>容纳其他对象的序列集合对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list</span><br><span class="line">tuple</span><br><span class="line">string</span><br><span class="line">set</span><br></pre></td></tr></table></figure></li><li><p>Mapping对象<br>类似 C++中的 map 的关联对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict</span><br></pre></td></tr></table></figure></li><li><p>Internal对象:<br>Python 虚拟机在运行时内部使用的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function</span><br><span class="line">code</span><br><span class="line">frame</span><br><span class="line">module</span><br><span class="line">method</span><br></pre></td></tr></table></figure></li></ul><h2 id="对象三要素"><a href="#对象三要素" class="headerlink" title="对象三要素"></a>对象三要素</h2><p>对象三要素:</p><ul><li>双向链表</li><li>引用计数</li><li>类型对象指针</li></ul><p>PyObject定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Include&#x2F;object.h</span><br><span class="line">#define _PyObject_HEAD_EXTRA            \</span><br><span class="line">    struct _object *_ob_next;           \</span><br><span class="line">    struct _object *_ob_prev;</span><br><span class="line"></span><br><span class="line">typedef struct _object &#123;</span><br><span class="line">    _PyObject_HEAD_EXTRA    &#x2F;&#x2F; 双向链表 垃圾回收 需要用到</span><br><span class="line">    Py_ssize_t ob_refcnt;   &#x2F;&#x2F; 引用计数</span><br><span class="line">    struct _typeobject *ob_type;    &#x2F;&#x2F; 指向类型对象的指针，决定了对象的类型</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><h3 id="定长与变长对象"><a href="#定长与变长对象" class="headerlink" title="定长与变长对象"></a>定长与变长对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Include&#x2F;object.h</span><br><span class="line">typedef struct _object &#123;</span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    struct _typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; &#x2F;* Number of items in variable part *&#x2F;</span><br><span class="line">&#125; PyVarObject;</span><br><span class="line">&#x2F;* PyVarObject比PyObject多出了一个用于存储元素个数的变量ob_size *&#x2F;</span><br></pre></td></tr></table></figure><h3 id="类型对象"><a href="#类型对象" class="headerlink" title="类型对象"></a>类型对象</h3><p>PyObject 的 对象类型指针struct _typeobject *ob_type，<br>它指向的类型对象就决定了一个对象是什么类型的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _typeobject &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    const char *tp_name; &#x2F;* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; *&#x2F; &#x2F;&#x2F; 类型名</span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; &#x2F;* For allocation *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 创建该类型对象分配的内存空间大小</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 一堆方法定义，函数和指针</span><br><span class="line">    &#x2F;* Methods to implement standard operations *&#x2F;</span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    PyAsyncMethods *tp_as_async; &#x2F;* formerly known as tp_compare (Python 2)</span><br><span class="line">                                    or tp_reserved (Python 3) *&#x2F;</span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Method suites for standard classes *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 标准类方法集</span><br><span class="line">    PyNumberMethods *tp_as_number;  &#x2F;&#x2F; 数值对象操作</span><br><span class="line">    PySequenceMethods *tp_as_sequence;  &#x2F;&#x2F; 序列对象操作</span><br><span class="line">    PyMappingMethods *tp_as_mapping;  &#x2F;&#x2F; 字典对象操作</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 更多标准操作</span><br><span class="line">    &#x2F;* More standard operations (here for binary compatibility) *&#x2F;</span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line">    ......</span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure><p>Python 中的所有对象都拥有一些相同的内容，而这些内容就定义在PyObject中。</p><h4 id="类型对象创建"><a href="#类型对象创建" class="headerlink" title="类型对象创建"></a>类型对象创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Include&#x2F;object.h</span><br><span class="line">#ifdef Py_TRACE_REFS</span><br><span class="line">    #define _PyObject_EXTRA_INIT 0, 0,</span><br><span class="line">#else</span><br><span class="line">    #define _PyObject_EXTRA_INIT</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define PyObject_HEAD_INIT(type)        \</span><br><span class="line">    &#123; _PyObject_EXTRA_INIT              \</span><br><span class="line">    1, type &#125;,</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; Objects&#x2F;longobject.c</span><br><span class="line">static PyNumberMethods long_as_number &#x3D; &#123;</span><br><span class="line">    (binaryfunc)long_add,       &#x2F;*nb_add*&#x2F;</span><br><span class="line">    (binaryfunc)long_sub,       &#x2F;*nb_subtract*&#x2F;</span><br><span class="line">    (binaryfunc)long_mul,       &#x2F;*nb_multiply*&#x2F;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyTypeObject PyLong_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;int&quot;,                                      &#x2F;* tp_name *&#x2F;</span><br><span class="line">    offsetof(PyLongObject, ob_digit),           &#x2F;* tp_basicsize *&#x2F;</span><br><span class="line">    sizeof(digit),                              &#x2F;* tp_itemsize *&#x2F;</span><br><span class="line">    long_dealloc,                               &#x2F;* tp_dealloc *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_print *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_getattr *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_setattr *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_reserved *&#x2F;</span><br><span class="line">    long_to_decimal_string,                     &#x2F;* tp_repr *&#x2F;</span><br><span class="line">    &amp;long_as_number,                            &#x2F;* tp_as_number *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_sequence *&#x2F;</span><br><span class="line">    0,                                          &#x2F;* tp_as_mapping *&#x2F;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><ul><li>1.这类 API 通常形如PyObject_XXX这样的形式。可以应用在任何 Python 对象上，<br>如PyObject_New。创建一个整数对象的方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyObject* longobj &#x3D; PyObject_New(Pyobject, &amp;PyLong_Type);</span><br></pre></td></tr></table></figure></li><li>2.与类型相关的 API 或称为 COL (Concrete Object Layer)<br>这类 API 通常只能作用于某一种类型的对象上，对于每一种内建对象<br>Python 都提供了这样一组 API。例如整数对象，我们可以利用如下的 API 创建<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PyObject *longObj &#x3D; PyLong_FromLong(10);</span><br></pre></td></tr></table></figure></li></ul><h3 id="对象的多态性"><a href="#对象的多态性" class="headerlink" title="对象的多态性"></a>对象的多态性</h3><p>Python 创建一个对象比如 PyLongObject 时，会分配内存进行初始化，<br>然后 Python 内部会用 PyObject* 变量来维护这个对象，其他对象也与此类似<br>所以在 Python 内部各个函数之间传递的都是一种范型指针 PyObject* 我们不<br>知道这个指针所指的对象是什么类型，只能通过所指对象的 ob_type 域 动态进<br>行判断，而 Python 正是通过 ob_type 实现了多态机制<br>考虑以下的 calc_hash 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Py_hash_t</span><br><span class="line">calc_hash(PyObject* object)</span><br><span class="line">&#123;</span><br><span class="line">    Py_hash_t hash &#x3D; object-&gt;ob_type-&gt;tp_hash(object);</span><br><span class="line">    return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传递给 calc_hash 函数的指针是一个 PyLongObject*，那么它会调用 PyLongObject 对象对应的类型对象中定义的 hash 操作tp_hash，tp_hash可以在PyTypeObject中找到， 而具体赋值绑定我们可以在 PyLong_Type 初始化代码中看到绑定的是long_hash函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Objects&#x2F;longobject.c</span><br><span class="line">PyTypeObject PyLong_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;int&quot;,                                      &#x2F;* tp_name *&#x2F;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    (hashfunc)long_hash,                        &#x2F;* tp_hash *&#x2F;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果指针是一个 PyUnicodeObject*，那么就会调用 PyUnicodeObject 对象对应的类型对象中定义的 hash 操作，查看源码可以看到 实际绑定的是 unicode_hash函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Objects&#x2F;unicodeobject.c</span><br><span class="line">PyTypeObject PyUnicode_Type &#x3D; &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)</span><br><span class="line">    &quot;str&quot;,              &#x2F;* tp_name *&#x2F;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    (hashfunc) unicode_hash,        &#x2F;* tp_hash*&#x2F;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>Python 通过引用计数来管理维护对象在内存中的存在与否<br>Python 中的每个东西都是一个对象， 都有ob_refcnt 变量，<br>这个变量维护对象的引用计数，从而最终决定该对象的创建与销毁<br>在 Python 中，主要通过 Py_INCREF(op)与Py_DECREF(op) 这两个宏<br>来增加和减少对一个对象的引用计数。当一个对象的引用计数减少到 0 之后，<br>Py_DECREF将调用该对象的tp_dealloc来释放对象所占用的内存和系统资源；<br>但这并不意味着最终一定会调用 free 释放内存空间。因为频繁的申请、释放<br>内存会大大降低 Python 的执行效率。因此 Python 中大量采用了内存对象<br>池的技术，使得对象释放的空间归还给内存池而不是直接free，后续使用可先<br>从对象池中获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Include&#x2F;object.h</span><br><span class="line">#define _Py_NewReference(op) (                          \</span><br><span class="line">    _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA         \</span><br><span class="line">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA               \</span><br><span class="line">    Py_REFCNT(op) &#x3D; 1)</span><br><span class="line"></span><br><span class="line">#define Py_INCREF(op) (                         \</span><br><span class="line">    _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span><br><span class="line">    ((PyObject *)(op))-&gt;ob_refcnt++)</span><br><span class="line"></span><br><span class="line">#define Py_DECREF(op)                                   \</span><br><span class="line">    do &#123;                                                \</span><br><span class="line">        PyObject *_py_decref_tmp &#x3D; (PyObject *)(op);    \</span><br><span class="line">        if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA       \</span><br><span class="line">        --(_py_decref_tmp)-&gt;ob_refcnt !&#x3D; 0)             \</span><br><span class="line">            _Py_CHECK_REFCNT(_py_decref_tmp)            \</span><br><span class="line">        else                                            \</span><br><span class="line">            _Py_Dealloc(_py_decref_tmp);                \</span><br><span class="line">    &#125; while (0)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;对象分类&quot;&gt;&lt;a href=&quot;#对象分类&quot; class=&quot;headerlink&quot; title=&quot;对象分类&quot;&gt;&lt;/a&gt;对象分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Fundamental对象&lt;br&gt;类型对象&lt;/p&gt;
&lt;figure class=&quot;highlight pl</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    <category term="cpython源码解析" scheme="http://example.com/categories/python/cpython%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/06/18/python/pysider2/"/>
    <id>http://example.com/2021/06/18/python/pysider2/</id>
    <published>2021-06-18T01:03:51.510Z</published>
    <updated>2021-06-16T00:56:19.471Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>缓存问题</title>
    <link href="http://example.com/2021/06/15/redis%E9%AB%98%E7%BA%A7%E7%AF%87/%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/06/15/redis%E9%AB%98%E7%BA%A7%E7%AF%87/%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-15T08:57:18.147Z</published>
    <updated>2021-06-15T09:14:45.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h3><p>如果缓在某一个时刻出现大规模的key失效，那么就会导致大量的<br>请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况<br>下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，<br>马上又会有新的流量把数据库打死。这就是缓存雪崩。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>造成缓存雪崩的关键在于同一时间的大规模的key失效，为什么会出现这个<br>问题，主要有两种可能：第一种是Redis宕机，第二种可能就是采用了相同<br>的过期时间。搞清楚原因之后，那么有什么解决方案呢？</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>事前</p><ul><li>1.均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免<br>相同的过期时间导致缓存雪崩，造成大量数据库的访问。</li><li>2.分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失<br>效时间都不同。</li><li>3.热点数据缓存永远不过期。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">永不过期实际包含两层意思：</span><br><span class="line">物理不过期，针对热点key不设置过期时间</span><br><span class="line">逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，</span><br><span class="line">通过一个后台的异步线程进行缓存的构建</span><br></pre></td></tr></table></figure></li><li>4.保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。<br>可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。</li></ul></li><li><p>事中</p><ul><li><p>1.互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数<br>据写缓存的线程数量，比如某个key只允许一个线程查询数据和<br>写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统<br>的吞吐量会下降</p></li><li><p>2.使用熔断机制，限流降级。当流量达到一定的阈值，直接返回<br>“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，<br>至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到<br>结果。</p></li></ul></li><li><p>事后<br>  开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上<br>  自动加载数据恢复内存中的数据。</p></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h3><p>缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，<br>而缓存击穿是某个热点的key失效，大并发集中对其进行请求，<br>就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，<br>引起数据库压力剧增。这种现象就叫做缓存击穿。</p><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>关键在于某个热点的key失效了，导致大并发集中打在数据库上。<br>所以要从两个方面解决，第一是否可以考虑热点key不设置过期时间，<br>第二是否可以考虑降低打在数据库上的请求数量。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>1.在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，<br>比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种<br>方式会阻塞其他的线程，此时系统的吞吐量会下降</li><li>2.热点数据缓存永远不过期。 <h2 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h2><h3 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h3>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，<br>同时在数据库中也不存在，导致用户每次请求该数据都要去<br>数据库中查询一遍。如果有恶意攻击者不断请求系统中不存<br>在的数据，会导致短时间大量请求落在数据库上，造成数据<br>库压力过大，甚至导致数据库承受不住而宕机崩溃。</li></ul><h3 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h3><p>缓存穿透的关键在于在Redis中查不到key值，它和缓存击穿<br>的根本区别在于传进来的key在Redis中是不存在的。假如有<br>黑客传进大量的不存在的key，那么大量的请求打在数据库上<br>是很致命的问题，所以在日常开发中要对参数做好校验，一些<br>非法的参数，不可能存在的key就直接返回错误提示。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li><p>1.将无效的key存放进Redis中：<br>当出现Redis查不到数据，数据库也查不到数据的情况，<br>我们就把这个key保存到Redis中，设置value=”null”，<br>并设置其过期时间极短，后面再出现查询这个key的请求的时候，<br>直接返回null，就不需要再查询数据库了。但这种处理方式是有<br>问题的，假如传进来的这个不存在的Key值每次都是随机的，那存<br>进Redis也没有意义。</p></li><li><p>2.使用布隆过滤器<br>如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不<br>存在，如果判定某个 key 存在，那么很大可能是存在(存在一定的误判率)。<br>于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存<br>储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在，如果<br>不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。</p></li></ul><h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><p>针对一些恶意攻击，攻击带过来的大量key是随机，那么我们采用第一种方案就<br>会缓存大量不存在key的数据。那么这种方案就不合适了，我们可以先对使用布<br>隆过滤器方案进行过滤掉这些key。所以，针对这种key异常多、请求重复率比较<br>低的数据，优先使用第二种方案直接过滤掉。而对于空数据的key有限的，重复率<br>比较高的，则可优先采用第一种方式进行缓存。</p><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><h3 id="什么是缓存预热"><a href="#什么是缓存预热" class="headerlink" title="什么是缓存预热"></a>什么是缓存预热</h3><p>缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。<br>避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，<br>用户直接查询事先被预热的缓存数据。<br>如果不进行预热，那么Redis初始状态数据为空，系统上线初期，<br>对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。</p><h3 id="缓存预热解决方案"><a href="#缓存预热解决方案" class="headerlink" title="缓存预热解决方案"></a>缓存预热解决方案</h3><ul><li>1.数据量不大的时候，工程启动的时候进行加载缓存动作</li><li>2.数据量大的时候，设置一个定时任务脚本，进行缓存的刷新</li><li>3.数据量太大的时候，优先保证热点数据进行提前加载到缓存。</li></ul><h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><h3 id="什么是缓存降级"><a href="#什么是缓存降级" class="headerlink" title="什么是缓存降级"></a>什么是缓存降级</h3><p>缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，<br>直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所<br>以尽量减少降级对于业务的影响程度。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>在项目实战中通常会将部分热点数据缓存到服务的内存中，这样一旦缓存<br>出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。</p><ul><li>转载自<a href="https://blog.csdn.net/a745233700/article/details/88088669">Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;缓存雪崩&quot;&gt;&lt;a href=&quot;#缓存雪崩&quot; class=&quot;headerlink&quot; title=&quot;缓存雪崩&quot;&gt;&lt;/a&gt;缓存雪崩&lt;/h2&gt;&lt;h3 id=&quot;什么是缓存雪崩&quot;&gt;&lt;a href=&quot;#什么是缓存雪崩&quot; class=&quot;headerlink&quot; title=&quot;什么是</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="redis高级篇" scheme="http://example.com/categories/nosql/redis%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title>事务隔离级别</title>
    <link href="http://example.com/2021/06/15/mysql%E9%AB%98%E7%BA%A7%E7%AF%87/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://example.com/2021/06/15/mysql%E9%AB%98%E7%BA%A7%E7%AF%87/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2021-06-15T03:24:57.360Z</published>
    <updated>2021-06-15T03:45:50.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行<br>（如果单元中某个sql执行失败，整个单元将会回滚）<br>转账：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update table set余额&#x3D;500 where name&#x3D;’张三丰’</span><br><span class="line">update table set余额&#x3D;1500 where name&#x3D;’郭襄’</span><br></pre></td></tr></table></figure><p>如果单独执行，数据库出现意外挂掉只执行了一个就会很尴尬</p><h2 id="mysql的存储引擎"><a href="#mysql的存储引擎" class="headerlink" title="mysql的存储引擎"></a>mysql的存储引擎</h2><p>在mysql中的数据用各种不同的技术存储在文件（内存）中。<br>通过show engines查看所有mysql支持的引擎<br>主流 innoDB、MEMORY、MylSAM<br><strong>只有innoDB支持事务</strong></p><h2 id="事务的ACID-acid-属性"><a href="#事务的ACID-acid-属性" class="headerlink" title="事务的ACID(acid)属性"></a>事务的ACID(acid)属性</h2><ul><li><p>1.原子性（atomicity）<br>不可在分割的工作单位</p></li><li><p>2.一致性（Consistency）<br>就是这边变了那边也变了，一致的变化</p></li><li><p>3.隔离性（isolation）<br>事务的隔离性是指事务的执行不受其他事务干扰。<br>并发互不干扰（但很多时候是达不到隔离性的，要用隔离级别控制）</p></li><li><p>4.持久性（Durability）<br>一个事务一旦被提交，它对数据库中数据的改变就是永久性的，<br>接下来的其他操作和数据库故障不应该对其有影响。不能撤销</p></li></ul><h2 id="事务的创建"><a href="#事务的创建" class="headerlink" title="事务的创建"></a>事务的创建</h2><ul><li><p>隐式事务：事务没有明显的开启和结束的标记<br>比如insert、update、delete</p></li><li><p>显示事务：事务具有明显的开启结束标记<br>前提必须设置自动提交功能禁用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit &#x3D; 0;(只针对当前事务有效)</span><br></pre></td></tr></table></figure></li><li><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.set autocommit&#x3D;0;</span><br><span class="line">2.start transaction;可选的 不选也开启了</span><br><span class="line">3.编写事务中的sql（select insert update delete）</span><br><span class="line">如：</span><br><span class="line">1.update table set余额&#x3D;500 where name&#x3D;’张三丰’</span><br><span class="line">2.update table set余额&#x3D;1500 where name&#x3D;’郭襄’</span><br></pre></td></tr></table></figure></li><li><p>结束事务</p><ul><li>1.commit提交事务</li><li>2.rollback回滚事务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set autocommit &#x3D; 0;</span><br><span class="line">start transaction;</span><br><span class="line">update table set余额&#x3D;500 where name&#x3D;’张三丰’;</span><br><span class="line">update table set余额&#x3D;1500 where name&#x3D;’郭襄’;</span><br><span class="line">commit;提交到磁盘文件</span><br><span class="line">rollback;撤销</span><br><span class="line">savepoint 节点名，设置保存点</span><br><span class="line">（回滚点）</span><br><span class="line"></span><br><span class="line">delete可以回滚</span><br><span class="line">set autocommit &#x3D; 0;</span><br><span class="line">start transaction;</span><br><span class="line">delete from account where id&#x3D;25;</span><br><span class="line">savepoint a;</span><br><span class="line">delete from account where id&#x3D;28;</span><br><span class="line">rollback to a;回滚到保存点</span><br></pre></td></tr></table></figure>truncate无法回滚</li></ul></li></ul><h2 id="事务的隔离机制与并发性处理"><a href="#事务的隔离机制与并发性处理" class="headerlink" title="事务的隔离机制与并发性处理"></a>事务的隔离机制与并发性处理</h2><p>有时候同时运行多个事务，当这些事务访问数据库中相同数据时，<br>如果没有采取有效隔离机制，就会产生下面这些问题</p><ul><li>1.脏读：T1读取了T2更新还没提交的数据，若T2回滚，T1读取的内容就是临时无效的。</li><li>2.不可重复读：对于两个事务T1,T2 T1读取了一个字段，然后T2更新了该字段之后，<br>T1再次读取同一字段值就不同了。</li><li>3.幻读：T1读取一行发现不存在，T2插入这行，T1插入这行发现不行。</li></ul><p>数据事务隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使他们不会相互影响，避免各种并发问题。</p><h3 id="oracle支持两种事务隔离级别"><a href="#oracle支持两种事务隔离级别" class="headerlink" title="oracle支持两种事务隔离级别"></a>oracle支持两种事务隔离级别</h3><ul><li>1.READ COMMITED</li><li>2.SERIALIZABLE<br>默认隔离级别：READ COMMITED<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation; 查看隔离级别</span><br><span class="line">select @@transaction_isolation; mysql8格式</span><br><span class="line">设置当前mysql连接的隔离级别：</span><br><span class="line">set session transaction isolation level read uncommitted</span><br><span class="line">设置数据库系统的全局的隔离级别：(重启)</span><br><span class="line">set global transaction isolation level read uncommitted</span><br></pre></td></tr></table></figure></li></ul><h3 id="MYSQL支持4种事务隔离级别："><a href="#MYSQL支持4种事务隔离级别：" class="headerlink" title="MYSQL支持4种事务隔离级别："></a>MYSQL支持4种事务隔离级别：</h3><ul><li>1.read-uncommitted 最低级别读未提交的数据</li><li>2.read-committed 读已经提交的数据 避免脏读</li><li>3.REPEATABLE-READ 默认 避免不可重复读</li><li>4.SERIALIZABLE 避免所有问题（幻读）锁表<br>串行化这边事务未完成前，别的事务会锁住。所以性能很差，只有特殊情况才用它。<br>当事务2提交了插入数据，事务1插入同样数据的时候产生。</li></ul><h4 id="关于幻读"><a href="#关于幻读" class="headerlink" title="关于幻读"></a>关于幻读</h4><p>此时事务级别为repeatable read id为主键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">开启两个session transaction</span><br><span class="line">t1.</span><br><span class="line">insert into table values(1, ‘afa’)</span><br><span class="line">commit</span><br><span class="line">t2.</span><br><span class="line">select * from bb;</span><br><span class="line">此时查询并没有id&#x3D;1的数据</span><br><span class="line">insert into table values(1, ‘werwr’)</span><br><span class="line">报错：duplicate</span><br><span class="line">即为幻读</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行&lt;br&gt;（如果单元中某个sql执行失败，整个单元将会回滚）&lt;b</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="mysql高级篇" scheme="http://example.com/categories/nosql/mysql%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title>数据备份</title>
    <link href="http://example.com/2021/06/15/mysql%E9%AB%98%E7%BA%A7%E7%AF%87/mysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
    <id>http://example.com/2021/06/15/mysql%E9%AB%98%E7%BA%A7%E7%AF%87/mysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/</id>
    <published>2021-06-15T02:43:48.496Z</published>
    <updated>2021-06-15T08:44:44.689Z</updated>
    
    <content type="html"><![CDATA[<p>对于现代网络来说，数据是无价的，需要好好维护，为了避免误删、误更等的发生，需要一个<br>数据备份的方案进行维护。</p><h2 id="备份方式"><a href="#备份方式" class="headerlink" title="备份方式"></a>备份方式</h2><p>mysql按照备份恢复方式分为逻辑备份和物理备份</p><ul><li>逻辑备份：是备份sql语句，在恢复的时候执行备份的sql语句实<br>现数据库数据的重现。</li><li>物理备份：就是备份数据文件了，比较形象点就是cp下数据文件，<br>但真正备份的时候自然不是的cp这么简单。</li></ul><p>mysql按照数据库的运行状态分为热备，冷备和温备</p><ul><li>热备：在数据库运行时，直接进行备份，对运行的数据库没有影响。</li><li>冷备：在数据库停止运行的时候进行备份，这种备份方式最为简单，只需要拷贝数据库物理文件即可。</li><li>温备：同样是在数据库运行的时候进行备份的，但对当前数据库的操作会产生影响。</li></ul><h2 id="备份方案"><a href="#备份方案" class="headerlink" title="备份方案"></a>备份方案</h2><ul><li>1.mysqldump + mysqlbinlog</li><li>2.xtrabackup</li><li>3.lvm2快照+mysqlbinlog</li></ul><h2 id="mysqldump-amp-mysqlbinlog（全量物理-amp-增量逻辑）"><a href="#mysqldump-amp-mysqlbinlog（全量物理-amp-增量逻辑）" class="headerlink" title="mysqldump&amp;mysqlbinlog（全量物理&amp;增量逻辑）"></a>mysqldump&amp;mysqlbinlog（全量物理&amp;增量逻辑）</h2><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.输出指定数据库的完整备份文件到指定路径</span><br><span class="line">mysqldump  -hhostname –uname –ppasswd database &gt; path.sql</span><br><span class="line"></span><br><span class="line">2.备份到远程数据库</span><br><span class="line">mysqldump  -hhostname –uname –ppasswd database | mysql –hhostname –ppasswd –C database</span><br><span class="line"></span><br><span class="line">3.还原备份文件到某个sql的某个数据库</span><br><span class="line">mysql  -hhostname -uuser -ppwd databasename &lt; &#x2F;path.sql</span><br><span class="line"></span><br><span class="line">4.还原压缩的备份文件到某个sql的某个数据库</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;b77dfd6d998b</span><br><span class="line"></span><br><span class="line">5.备份并压缩</span><br><span class="line">mysqldump –h –u –p database | gzip &gt; path</span><br><span class="line"></span><br><span class="line">6.备份多个数据库</span><br><span class="line">mysqldump –h –u –p --databases databases1 2 3 &gt; path.sql</span><br><span class="line"></span><br><span class="line">7.备份数据库某些表</span><br><span class="line">mysqldump –h –u –p databasename table1 2 3 &gt; path.sql</span><br><span class="line"></span><br><span class="line">8.仅备份数据结构</span><br><span class="line">mysqldump -no-data –h –u –p databasename table1 2 3 &gt; path.sql</span><br><span class="line"></span><br><span class="line">9.备份所有数据库</span><br><span class="line">mysqldump –all-databases &gt; path.sql</span><br></pre></td></tr></table></figure><h4 id="简单linux脚本备份"><a href="#简单linux脚本备份" class="headerlink" title="简单linux脚本备份"></a>简单linux脚本备份</h4><ul><li><p>1.脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">touch mysql_backup.sh</span><br><span class="line">vim mysql_backup.sh</span><br><span class="line"></span><br><span class="line"># this is a mysql database backup shell script</span><br><span class="line">hostname &#x3D; ’10.167.218.161’</span><br><span class="line">database &#x3D; ‘test’</span><br><span class="line">bppath &#x3D;’&#x2F;root&#x2F;mysql_backup’</span><br><span class="line">data &#x3D; $(date+%Y%m%d_%H%M%S)</span><br><span class="line">user&#x3D;&quot;xxxx&quot;</span><br><span class="line">password&#x3D;&quot;xxxxx&quot;</span><br><span class="line">mysqldump –h$hostname –u$user –p$password $database|gzip &gt; $bppath&#x2F;$database_$date_sql.gz</span><br></pre></td></tr></table></figure></li><li><p>2.定时任务<br>把它加入定时任务crontab</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.启动定时任务</span><br><span class="line">service crond start|status|stop</span><br><span class="line">systemctl start crond</span><br><span class="line"># 查看config文件，可以看到定时规则</span><br><span class="line">cat &#x2F;etc&#x2F;cron</span><br><span class="line"># 添加定时任务</span><br><span class="line">crontab –e</span><br><span class="line"># 添加定时计划</span><br><span class="line">0 2 * * * &#x2F;path&#x2F;mysql_backup.sh</span><br><span class="line"># 查看当前定时任务</span><br><span class="line">crontab –l</span><br><span class="line"># 查看定时计划日志</span><br><span class="line">tail –f &#x2F;var&#x2F;log&#x2F;cron</span><br></pre></td></tr></table></figure></li></ul><h3 id="mysqlbinlog"><a href="#mysqlbinlog" class="headerlink" title="mysqlbinlog"></a>mysqlbinlog</h3><p>进行增量备份，备份二进制日志，将最后操作的二进制日志备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line"># 查看最新的binlog</span><br><span class="line">mysqlbinlog binlog.000001</span><br><span class="line"># 导出最新的增量</span><br><span class="line">mysqlbinlog  --start-position&#x3D;639 --stop-position&#x3D;835  </span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;bin-log.000003 &gt; &#x2F;backup&#x2F;binlog-&#96;date +%F_%T&#96;.sql</span><br></pre></td></tr></table></figure><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>1.使用mysqldump全量复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">备份整个库</span><br><span class="line">mysqldump --all-databases --lock-all-tables --flush-log  </span><br><span class="line">--master-data&#x3D;2 &gt;&#x2F;backup&#x2F;&#96;date +%F_%T&#96; -all.sql</span><br><span class="line">备份某一个库</span><br><span class="line">mysqldump -uroot -p123456 --databases </span><br><span class="line">test --lock-all-tables --flush-log -hlocalhost  </span><br><span class="line">--master-data&#x3D;2 &gt;&#x2F;backup&#x2F;&#96;date +%F_%T&#96;-test.sql;</span><br><span class="line">ls &#x2F;backup&#x2F;进行查看</span><br></pre></td></tr></table></figure><p>2.使用mysqlbinlog增量复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">保护最后的二进制文件</span><br><span class="line">mysqlbinlog  --start-position&#x3D;639 --stop-position&#x3D;835  </span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;bin-log.000003 &gt; &#x2F;backup&#x2F;binlog-&#96;date +%F_%T&#96;.sql</span><br></pre></td></tr></table></figure><p>3.数据恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 首先恢复mysqldump全量复制的某个库</span><br><span class="line">mysql -uroot -pZhanghaowei1! &lt; xxxxx.sql</span><br><span class="line"># 再恢复从那时起的增量</span><br><span class="line">mysql -uroot -pZhanghaowei1! &lt; bin_log-xxxxx.sql</span><br><span class="line">mysql -uroot -pZhanghaowei1! &lt; bin_log-xxxxx.sql</span><br></pre></td></tr></table></figure><h2 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h2><p>Xtrabackup是由percona提供的mysql数据库备份工具，据官方介绍，是一款<br>开源能够对innodb和xtradb数据库进行热备的工具。</p><p>特点：</p><ul><li>1.备份过程快速、可靠</li><li>2.备份过程不会打断正在执行的事务</li><li>3.能够基于压缩等功能节约磁盘空间和流量</li><li>4.自动实现备份检验</li><li>5.还原速度快</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum installpercona-xtrabackup-2.2.3-4982.el6.x86_64.rpm -y</span><br><span class="line">创建最小权限备份用户 </span><br><span class="line">grant reload,lock tables,replicationclient on *.* to </span><br><span class="line">&#39;fulanqi&#39;@&#39;localhost&#39; identified by &#39;123&#39;;</span><br></pre></td></tr></table></figure><h3 id="完全备份"><a href="#完全备份" class="headerlink" title="完全备份"></a>完全备份</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --user&#x3D;fulanqi --password&#x3D;123 &#x2F;backup&#x2F;</span><br></pre></td></tr></table></figure><h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --user&#x3D;fulanqi --password&#x3D;123 --incremental </span><br><span class="line">&#x2F;backup&#x2F;--incremental-basedir&#x3D;&#x2F;backup&#x2F;binlog-&#96;date +%F_%T&#96;.sql</span><br></pre></td></tr></table></figure><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><ul><li><p>数据准备<br>一般情况下，在备份完成后，数据尚且不能用于恢复操作，因为备份的数据中<br>可能会包含尚未提交的事务或已经提交但尚未同步至数据文件中的事务。因此<br>，此时数据文件仍处理不一致状态。“准备”的主要作用正是通过回滚未提交<br>的事务及同步已经提交的事务至数据文件也使得数据文件处于一致性状态</p></li><li><p>准备(prepare)增量备份与整理完全备份有着一些不同，尤其要注意的是：</p><ul><li>1.需要在每个备份(包括完全和各个增量备份)上，将已经提交的事务进行“<br>重放”。“重放”之后，所有的备份数据将合并到完全备份上。</li><li>2.基于所有的备份将未提交的事务进行“回滚”。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">全量</span><br><span class="line">innobackupex --apply-log --redo-only 全量路径</span><br><span class="line">增量</span><br><span class="line"># innobackupex --apply-log --redo-only BASE-DIR--incrementaldir&#x3D;增量路径</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据恢复<br>这时候所有备份数据都在全量路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --copy-back 全量路径</span><br></pre></td></tr></table></figure></li></ul><h3 id="python-amp-xtrabackup"><a href="#python-amp-xtrabackup" class="headerlink" title="python&amp;xtrabackup"></a>python&amp;xtrabackup</h3><p>采用每周一0点进行一次全备，每日0点进行增备，一星期为一个周期。<br>如要恢复到某个时间点的数据，只需要找到还原到时间点当天的增量备份，然后再结合binlog日志进行恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#39;utf8&#39;)</span><br><span class="line">import commands</span><br><span class="line">import base64</span><br><span class="line">import datetime</span><br><span class="line">import os</span><br><span class="line">#------------自定义变量----------- </span><br><span class="line">#备份数据库账号  bkUser&#x3D;&#39;bkuser&#39;      </span><br><span class="line">#备份数据库账户的密码,需要base64加密  bkPasswd&#x3D;&#39;passwd&#39;    </span><br><span class="line">#备份目录  bkDir&#x3D;&#39;&#x2F;data&#x2F;backup&#39;     </span><br><span class="line">#备份文件传给异地服务器的系统账号 tarUser&#x3D;&#39;user&#39;   </span><br><span class="line">#异地服务器 tarHost&#x3D;&#39;ip&#39;     </span><br><span class="line">#异地服务器的备份路径 ip tarBkDir&#x3D;&#39;&#39;          </span><br><span class="line"></span><br><span class="line">#--------------------------------- </span><br><span class="line">oneday&#x3D;datetime.timedelta(days&#x3D;1)</span><br><span class="line">twoday&#x3D;datetime.timedelta(days&#x3D;2)</span><br><span class="line">today&#x3D;datetime.date.today()</span><br><span class="line">formattedYesterday&#x3D;(today-oneday).strftime(&#39;%Y%m%d&#39;)</span><br><span class="line">formattedBeforeYesterday&#x3D;(today-twoday).strftime(&#39;%Y%m%d&#39;)</span><br><span class="line">week&#x3D;datetime.datetime.now().weekday()</span><br><span class="line">nowTime&#x3D;str(datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;))</span><br><span class="line"></span><br><span class="line">def installXtrabackup():</span><br><span class="line">    commands.getstatusoutput(&#39;mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup&#39;)</span><br><span class="line">    commands.getstatusoutput(&#39;mv &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo.backup&#39;)</span><br><span class="line">    commands.getstatusoutput(&#39;wget -O&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-6.repo&#39;)</span><br><span class="line">    commands.getstatusoutput(&#39;wget -O&#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-6.repo&#39;)</span><br><span class="line">    commands.getstatusoutput(&#39;yum install -y http:&#x2F;&#x2F;www.percona.com&#x2F;downloads&#x2F;percona-release&#x2F;redhat&#x2F;0.1-6&#x2F;percona-release-0.1-6.noarch.rpm&#39;)</span><br><span class="line">    commands.getstatusoutput(&#39;yum install -y percona-xtrabackup-24&#39;)</span><br><span class="line"></span><br><span class="line">def copyFull():</span><br><span class="line">    print(&#39;---全备开始时间---:&#39;+nowTime)</span><br><span class="line">    fileName&#x3D;&#39;full_&#39;+ formattedYesterday</span><br><span class="line">    bkFulCmd&#x3D;&#39;innobackupex --no-timestamp &#x2F;data&#x2F;backup&#x2F;%s -u%s -p%s&#39;%(fileName,bkUser,base64.decodestring(bkPasswd))</span><br><span class="line">    commands.getstatusoutput(bkFulCmd)</span><br><span class="line">    print(&#39;---全备结束时间---:&#39;+nowTime)</span><br><span class="line">    return fileName</span><br><span class="line"></span><br><span class="line">def copyIncrement(file):</span><br><span class="line">    print(&#39;---增备开始时间---:&#39;+nowTime)</span><br><span class="line">    fileName&#x3D;&#39;rec_&#39; + formattedYesterday</span><br><span class="line">    bkRecCmd&#x3D;&#39;innobackupex --no-timestamp --incremental &#x2F;data&#x2F;backup&#x2F;%s --incremental-basedir&#x3D;&#x2F;data&#x2F;backup&#x2F;%s -u%s -p%s&#39;%(fileName,file,bkUser,base64.decodestring(bkPasswd))</span><br><span class="line">    commands.getstatusoutput(bkRecCmd)</span><br><span class="line">    print(&#39;---增备结束时间---:&#39;+nowTime)</span><br><span class="line">    return fileName</span><br><span class="line"></span><br><span class="line">def packBackup():</span><br><span class="line">    print(&#39;---打包开始时间---:&#39;+nowTime)</span><br><span class="line">    os.chdir(bkDir)</span><br><span class="line">    os.chdir(&#39;..&#39;)</span><br><span class="line">    tarCmd&#x3D;&#39;tar -cvf backup_%s.tar backup&#x2F;&#39;%(formattedYesterday)</span><br><span class="line">    commands.getstatusoutput(tarCmd)</span><br><span class="line">    commands.getstatusoutput(&#39;rm -rf &#x2F;data&#x2F;backup&#39;)</span><br><span class="line">    print(&#39;---打包结束时间---:&#39;+nowTime)</span><br><span class="line"></span><br><span class="line">def isCopyFulRec():</span><br><span class="line">    if os.path.exists(bkDir) &#x3D;&#x3D; 0:</span><br><span class="line">       copyFull()</span><br><span class="line">    else:</span><br><span class="line">       dirlist &#x3D; os.listdir(bkDir)</span><br><span class="line">       if dirlist:</span><br><span class="line">           print(dirlist)</span><br><span class="line">           tagFul &#x3D; &#39;full&#39;</span><br><span class="line">           tagRec &#x3D; &#39;rec&#39;</span><br><span class="line">           fileName &#x3D; []</span><br><span class="line">           for i in dirlist:</span><br><span class="line">              if tagFul in i:</span><br><span class="line">                 fileName.append(1)</span><br><span class="line">              elif tagRec in i:</span><br><span class="line">                 fileName.append(2)</span><br><span class="line">              else:</span><br><span class="line">                 fileName.append(0)</span><br><span class="line">                 </span><br><span class="line">           if 2 in fileName:</span><br><span class="line">               copyIncrement(&#39;rec_&#39;+formattedBeforeYesterday)</span><br><span class="line">           elif 1 in fileName:</span><br><span class="line">               copyIncrement(&#39;full_&#39;+ formattedBeforeYesterday)</span><br><span class="line">           else:</span><br><span class="line">               copyFull()</span><br><span class="line">       else:</span><br><span class="line">           copyFull()</span><br><span class="line"></span><br><span class="line">def scpTarget():</span><br><span class="line">    print(&#39;---传包开始时间---:&#39;+nowTime)</span><br><span class="line">    os.chdir(bkDir)</span><br><span class="line">    os.chdir(&#39;..&#39;)</span><br><span class="line">    tarName&#x3D;&#39;backup_%s.tar&#39;%formattedYesterday</span><br><span class="line">    scpCmd&#x3D;&#39;scp %s %s@%s&#39;%(tarName,tarUser,tarHost)</span><br><span class="line">    commands.getstatusoutput(scpCmd)</span><br><span class="line">    rmCmd&#x3D;&#39;rm -rf %s&#39;%tarName</span><br><span class="line">    commands.getstatusoutput(rmCmd)</span><br><span class="line">    print(&#39;---传包结束时间---:&#39;+nowTime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    installXtrabackup()     </span><br><span class="line">    if week&#x3D;&#x3D;0:</span><br><span class="line">        copyFull()</span><br><span class="line">        packBackup() #打包                 </span><br><span class="line">        # 传到备份服务器 </span><br><span class="line">        scpTarget() </span><br><span class="line">    else:</span><br><span class="line">        isCopyFulRec()</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/Ketchup_/article/details/78945202">mysql三种备份方案</a><br><a href="http://www.cslingjun.com/2019/05/08/Mysql%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/">MySQL常用备份方案</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于现代网络来说，数据是无价的，需要好好维护，为了避免误删、误更等的发生，需要一个&lt;br&gt;数据备份的方案进行维护。&lt;/p&gt;
&lt;h2 id=&quot;备份方式&quot;&gt;&lt;a href=&quot;#备份方式&quot; class=&quot;headerlink&quot; title=&quot;备份方式&quot;&gt;&lt;/a&gt;备份方式&lt;/h2&gt;</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="mysql高级篇" scheme="http://example.com/categories/nosql/mysql%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title>zookeeper安装配置</title>
    <link href="http://example.com/2021/06/15/zookeeper/zookeeper%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2021/06/15/zookeeper/zookeeper%E5%AE%89%E8%A3%85/</id>
    <published>2021-06-15T01:28:37.716Z</published>
    <updated>2021-06-12T02:09:39.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本地模式安装部署"><a href="#本地模式安装部署" class="headerlink" title="本地模式安装部署"></a>本地模式安装部署</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zookeeper官网下载</span><br><span class="line">tar –zxvf table 解压</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>1.将zookeeper/conf/zoo_sample.conf修改为zoo.cfg<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv zoo_sample.conf zoo.cfg</span><br></pre></td></tr></table></figure></li><li>2.vim zoo.cfg<br>修改dataDir为你想要保存数据的路径（记得先在路径下创建该文件夹）</li><li>3.bin/zkServer.sh start启动</li><li>4.jps查看状态bin/zkServer.sh status</li><li>5.进入客户端bin/zkCli.sh(推出quit)<br>ls + path</li><li>6.关闭服务bin/zkServer.sh stop</li></ul><h2 id="配置参数解读"><a href="#配置参数解读" class="headerlink" title="配置参数解读"></a>配置参数解读</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tickTime&#x3D;2000 心跳 单位ms</span><br><span class="line">initLimit&#x3D;10 10个心跳帧*心跳 是leader和slave的初始通讯延时时间</span><br><span class="line">如果超过这个时间，默认通讯失败。(启动花时间所以长一些)</span><br><span class="line">syncLimit&#x3D;5 5个心跳帧集群正常启动之后，leader和slave通讯的时间。</span><br><span class="line">clientPort&#x3D;2181客户端访问端口号</span><br><span class="line">dataDir数据存储位置</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本地模式安装部署&quot;&gt;&lt;a href=&quot;#本地模式安装部署&quot; class=&quot;headerlink&quot; title=&quot;本地模式安装部署&quot;&gt;&lt;/a&gt;本地模式安装部署&lt;/h2&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="bigdata" scheme="http://example.com/categories/bigdata/"/>
    
    <category term="zookeeper" scheme="http://example.com/categories/bigdata/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>zookeeper选举机制和节点类型</title>
    <link href="http://example.com/2021/06/15/zookeeper/zookeeper%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/06/15/zookeeper/zookeeper%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/</id>
    <published>2021-06-15T01:28:37.716Z</published>
    <updated>2021-06-12T02:09:48.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选举机制-重要"><a href="#选举机制-重要" class="headerlink" title="选举机制 ***重要"></a>选举机制 ***重要</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>1.半数机制，集群中半数以上（一半就不能存活了）的机器存活，集群可用。<br>（高可用）所以zookeeper适合安装奇数台服务器。</li><li>2.zookeeper虽然在配置文件中没有master和slave，但在工作时，是有一个<br>节点为leader，其他则为follower。而leader则是通过内部选举临时产生。</li><li>3.如何选举出leader？<br>如何选举leader（简单的选举机制）每个服务器启动先选自己，发现不行，就投<br>给已经启动的id号大的服务器，当获得票数大于服务器数量的一半，即刻当选</li></ul><h2 id="节点的类型"><a href="#节点的类型" class="headerlink" title="节点的类型"></a>节点的类型</h2><h3 id="持久型-persistent"><a href="#持久型-persistent" class="headerlink" title="持久型 persistent"></a>持久型 persistent</h3><ul><li>1.客户端和服务器断开连接后创建的节点不删除，会带一个persistent的标识</li><li>2.创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器由父节点维护。</li><li>3.在分布式系统中顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序。</li></ul><h3 id="短暂型-ephemeral-临时目录节点"><a href="#短暂型-ephemeral-临时目录节点" class="headerlink" title="短暂型 ephemeral 临时目录节点"></a>短暂型 ephemeral 临时目录节点</h3><p>客户端和服务器断开连接后创建的节点自动删除</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;选举机制-重要&quot;&gt;&lt;a href=&quot;#选举机制-重要&quot; class=&quot;headerlink&quot; title=&quot;选举机制 ***重要&quot;&gt;&lt;/a&gt;选举机制 ***重要&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="bigdata" scheme="http://example.com/categories/bigdata/"/>
    
    <category term="zookeeper" scheme="http://example.com/categories/bigdata/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>zookeeper基本操作</title>
    <link href="http://example.com/2021/06/15/zookeeper/zookeeper%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2021/06/15/zookeeper/zookeeper%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</id>
    <published>2021-06-15T01:28:37.715Z</published>
    <updated>2021-06-12T02:09:42.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zookeeper操作命令"><a href="#zookeeper操作命令" class="headerlink" title="zookeeper操作命令"></a>zookeeper操作命令</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.help查看命令</span><br><span class="line">2.ls &#x2F;查看某个节点内容</span><br><span class="line">3.ls -s &#x2F;查看某个节点详细数据</span><br><span class="line">4.create &#x2F;sanguo + 内容</span><br><span class="line"></span><br><span class="line">创建短暂节点 临时节点 带序号的节点</span><br><span class="line">1.不带序号的临时节点</span><br><span class="line">create –e &#x2F;sanguo&#x2F;wuguo “zhouyu”</span><br><span class="line">ls &#x2F;sanguo</span><br><span class="line">quit退出再进来</span><br><span class="line">ls &#x2F;sanguo 短暂节点客户端退出删除</span><br><span class="line">2.带序号的节点</span><br><span class="line">create -s &#x2F;sanguo&#x2F;weiguo &quot;caocao&quot;</span><br><span class="line">ls &#x2F;sanguo</span><br><span class="line">&#x2F;sanguo&#x2F;weiguo0000000002</span><br></pre></td></tr></table></figure><h3 id="监听节点"><a href="#监听节点" class="headerlink" title="监听节点"></a>监听节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">get –w +node获取值</span><br><span class="line">监听一次有效一次。。。。。</span><br><span class="line">ls –w +node</span><br><span class="line">监听子节点</span><br><span class="line">delete + node删除节点</span><br><span class="line">deleteall + node删除所有节点</span><br></pre></td></tr></table></figure><h2 id="Stat-结构体"><a href="#Stat-结构体" class="headerlink" title="Stat 结构体"></a>Stat 结构体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cZxid &#x3D; 0x20创建节点的事务id</span><br><span class="line">ctime &#x3D; Wed Oct 21 17:20:01 CST 2020 创建节点时间</span><br><span class="line">mZxid &#x3D; 0x20最后更新的事务id</span><br><span class="line">mtime &#x3D; Wed Oct 21 17:20:01 CST 2020最后更新的时间</span><br><span class="line">pZxid &#x3D; 0x20最后更新的子节点的id</span><br><span class="line">cversion &#x3D; 0znode子节点变化版本号</span><br><span class="line">dataVersion &#x3D; 0znode数据变化号</span><br><span class="line">aclVersion &#x3D; 0 访问控制列表的变化号</span><br><span class="line">ephemeralOwner &#x3D; 0x0是临时节点，sessionId否则0</span><br><span class="line">dataLength &#x3D; 0znode数据长度</span><br><span class="line">numChildren &#x3D; 0子节点数量</span><br></pre></td></tr></table></figure><h2 id="监听的原理-重"><a href="#监听的原理-重" class="headerlink" title="监听的原理 ***重"></a>监听的原理 ***重</h2><ul><li>1.首先要有一个main线程</li><li>2.在main线程中创建zookeeper客户端，这时候创建两个线程，一个负责网络连接通讯connect，一个负责监听listener。</li><li>3.通过connect线程将注册的监听事件发送给zookeeper</li><li>4.在zookeeper的注册监听器列表中将注册的监听事件添加到列表中。</li><li>5.zookeeper监听到有数据或路径的变化，就会将这个消息发送给listener线程</li><li>6.listener线程内部调用了process()方法。</li></ul><p>常见监听：<br>节点数据的变化<br>子节点增减的变化</p><h2 id="写数据的流程"><a href="#写数据的流程" class="headerlink" title="写数据的流程"></a>写数据的流程</h2><p>client客户端向zookeeper服务器发送一个写的请求。<br>如果server1不是leader，会把请求转给leader。leader会把写请求广播给各个server。各个server写完通知leader。<br>当leader收到大多数server数据写成功了，那么数据就写成功了。leader这个时候会告诉server1数据写成功。server<br>在通知客户端。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;zookeeper操作命令&quot;&gt;&lt;a href=&quot;#zookeeper操作命令&quot; class=&quot;headerlink&quot; title=&quot;zookeeper操作命令&quot;&gt;&lt;/a&gt;zookeeper操作命令&lt;/h2&gt;&lt;h3 id=&quot;基础命令&quot;&gt;&lt;a href=&quot;#基础命令&quot;</summary>
      
    
    
    
    <category term="bigdata" scheme="http://example.com/categories/bigdata/"/>
    
    <category term="zookeeper" scheme="http://example.com/categories/bigdata/zookeeper/"/>
    
    
  </entry>
  
</feed>
