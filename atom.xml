<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>为美好的生活献礼</title>
  
  <subtitle>what？</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-03T14:41:29.195Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>durian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis发布订阅</title>
    <link href="http://example.com/2021/06/03/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
    <id>http://example.com/2021/06/03/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</id>
    <published>2021-06-03T14:16:05.550Z</published>
    <updated>2021-06-03T14:41:29.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h3><p>进程间的一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。</p><h3 id="5-2-基本命令"><a href="#5-2-基本命令" class="headerlink" title="5.2 基本命令"></a>5.2 <a href="https://www.cnblogs.com/xiao-xue-di/p/12690900.html">基本命令</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.subscribe c1 c2 c3</span><br><span class="line">一次订阅三个</span><br><span class="line">2.publish c2 hello-world</span><br><span class="line">这时订阅的用户就能收到消息</span><br><span class="line">3.psubscribe new* 订阅多个</span><br><span class="line">new1 2 3….</span><br><span class="line">一般不会用redis做消息中间键</span><br></pre></td></tr></table></figure><h3 id="5-3-应用场景"><a href="#5-3-应用场景" class="headerlink" title="5.3 应用场景"></a>5.3 应用场景</h3><ul><li>网站综合消息通知</li><li>网站更新消息通知</li><li>关注的人更新通知</li><li>订阅频道更新通知</li><li>别人发消息的通知</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;5-1-简介&quot;&gt;&lt;a href=&quot;#5-1-简介&quot; class=&quot;headerlink&quot; title=&quot;5.1 简介&quot;&gt;&lt;/a&gt;5.1 简介&lt;/h3&gt;&lt;p&gt;进程间的一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。&lt;/p&gt;
&lt;h3 id=&quot;5-</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="redis高级篇" scheme="http://example.com/categories/nosql/redis%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title>redis事务</title>
    <link href="http://example.com/2021/06/03/redis%E4%BA%8B%E5%8A%A1/"/>
    <id>http://example.com/2021/06/03/redis%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-06-03T13:34:05.965Z</published>
    <updated>2021-06-03T14:14:35.568Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 <a href="http://redisdoc.com/transaction/multi.html">简介</a></h3><p>和sql的事务一样,本质是一组命令的集合,一个事务中所有命令都会序列化,按顺序地串行执行而不会被其他命令插入加塞.(要么一起成功,要么一起失败)<br>一个队列中一次性、顺序性、排他性的执行一系列的命令</p><h3 id="4-2-应用场景"><a href="#4-2-应用场景" class="headerlink" title="4.2 应用场景"></a>4.2 应用场景</h3><ul><li>秒杀系统<br>网络上经常谈到的微信抢红包项目为例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.设计数据库字段</span><br><span class="line">红包id、发红包人、金额、数量、剩余金额、剩余数量、抢到人的名单、过期时间、添加时间等</span><br><span class="line">发红包时入库，并在redis储存红包id:金额，红包id:数量</span><br><span class="line">基于微信用户量来说这显然是一个秒杀系统，存在高并发。</span><br><span class="line"></span><br><span class="line">2.抢红包设计</span><br><span class="line">用redis的list构建抢红包队列和打开红包的队列，进入抢红包队列前n个人的获取可以打开红包的token，</span><br><span class="line">其余人则直接获得无效token（无效请求），然后是打开红包的操作，点击打开即加入打开红包队列，同时</span><br><span class="line">记录该人的分配金额（分配算法，要满足在最后一个前不把钱扣完），同时用事务将缓存的数量、金额减少</span><br><span class="line">然后最后一个人分配剩余金额，金额发放用异步的方式进行（消费者消费打开红包队列），最后达到最终一致性。</span><br><span class="line"></span><br><span class="line">反正事务都有一个目的，保证几步操作的原子性，不过redis的不一定能保证。。。。</span><br></pre></td></tr></table></figure></li><li>支付系统</li></ul><h3 id="4-3-基本使用"><a href="#4-3-基本使用" class="headerlink" title="4.3 基本使用"></a>4.3 基本使用</h3><p>命令：</p><ul><li><p>1.Multi<br>标记一个事务块的开始。<br>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</p></li><li><p>2.exec<br>执行所有事务块内的命令。<br>假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</p></li><li><p>3.discard<br>取消事务，放弃执行事务块内的所有命令。<br>如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。</p></li><li><p>4.watch<br>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p></li><li><p>5.unwatch<br>取消 WATCH 命令对所有 key 的监视。<br>如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。<br>因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.正常执行</span><br><span class="line">multi</span><br><span class="line">set k1 v1</span><br><span class="line">get k2</span><br><span class="line">exec</span><br><span class="line"></span><br><span class="line">2.放弃事务</span><br><span class="line">multi</span><br><span class="line">set k1 v1</span><br><span class="line">get k2</span><br><span class="line">discard</span><br><span class="line"></span><br><span class="line">3.全体连坐</span><br><span class="line">multi</span><br><span class="line">set k1 v1</span><br><span class="line">get k2</span><br><span class="line">set k2这条命令在加入队列前就报错了！所以全体连坐</span><br><span class="line">exec</span><br><span class="line"></span><br><span class="line">4.冤头债主</span><br><span class="line">multi</span><br><span class="line">incr k1这条命令在执行的时候才报错</span><br><span class="line">set k4 v4</span><br><span class="line">exec</span><br></pre></td></tr></table></figure><p>5.watch监控<br>1.监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。<br>2.一旦执行了exec、discard之前加的监控锁都会被取消掉<br>3.通过watch命令在事务执行之前监控了多个keys，倘若在watch之后有任何key的值发生了变化，exec命令执行的事务都将被放弃。</p><h3 id="4-4-锁机制"><a href="#4-4-锁机制" class="headerlink" title="4.4 锁机制"></a>4.4 锁机制</h3><ul><li>1.悲观锁<br>pessimistic lock每次去拿数据的时候都认为别人会修改，所以在每次那拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁，读锁，写锁等，都是在操作前先上锁。</li><li>2.乐观锁 Optimistic lock<br>每次拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。<br>（提交的版本必须大于记录当前版本才能执行更新）</li></ul><h3 id="4-5-总结"><a href="#4-5-总结" class="headerlink" title="4.5 总结"></a>4.5 总结</h3><ul><li>1.单独的隔离操作<br>事务中的所有操作都会序列化、按顺序执行。事务在执行的过程中，不会被其它客户端发送来的命令请求所打断</li><li>2.没有隔离级别的概念<br>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li><li>3.不保证原子性<br>一条命令执行失败，其他的命令依然会被执行，没有回滚。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;4-1-简介&quot;&gt;&lt;a href=&quot;#4-1-简介&quot; class=&quot;headerlink&quot; title=&quot;4.1 简介&quot;&gt;&lt;/a&gt;4.1 &lt;a href=&quot;http://redisdoc.com/transaction/multi.html&quot;&gt;简介&lt;/a&gt;&lt;/h3&gt;</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="redis高级篇" scheme="http://example.com/categories/nosql/redis%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title>RDB&amp;AOF</title>
    <link href="http://example.com/2021/06/03/RDB&amp;AOF/"/>
    <id>http://example.com/2021/06/03/RDB&amp;AOF/</id>
    <published>2021-06-03T13:30:08.480Z</published>
    <updated>2021-06-03T13:31:43.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-RDB持久化"><a href="#2-RDB持久化" class="headerlink" title="2 RDB持久化"></a>2 RDB持久化</h2><h3 id="2-1-是什么？"><a href="#2-1-是什么？" class="headerlink" title="2.1 是什么？"></a>2.1 是什么？</h3><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里（内存的东西不保存关机就没了，为什么redis开机还有数据？因为内存中的数据集快照被写进了磁盘，开机从磁盘加载回内存。）</p><h3 id="2-2-相关配置"><a href="#2-2-相关配置" class="headerlink" title="2.2 相关配置"></a>2.2 相关配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis.conf的SNAPSHOTTING</span><br><span class="line">after 900 seconds if at least 1 key changed</span><br><span class="line">after 300 seconds if at least 10 keys changed</span><br><span class="line">after 60 seconds if at least 10000 keys changed</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">save + second + changes</span><br></pre></td></tr></table></figure><h3 id="2-3-执行原理（fork）"><a href="#2-3-执行原理（fork）" class="headerlink" title="2.3 执行原理（fork）"></a>2.3 执行原理（fork）</h3><ul><li>1.redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。<br>rdb保存的是dump.rdb文件，比如每隔5分钟，我们存一份5条记录，又过了5分钟我们存一份20条记录，这时候我们就用20条替换上一条新替换旧</li><li>2.整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。</li><li>3.如果需要进行大规模数据恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</li><li>4.RDB的缺点是最后一次持久化后的数据可能丢失。<br>（准备备份的时候这块儿出故障了，就没有备份）</li></ul><p>redis为了避免上下文切换的时间消耗，用单线程加epoll的方式处理请求，在save的时候会阻塞，这时redis不能接受的，所以必须用bgsave复制一份子进程作为工具进行rdb</p><p>fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程 和gihub的fork类似，系统有时候本来就慢紧张，还做备份，这时候fork一份就会崩溃</p><h3 id="2-4-如何触发"><a href="#2-4-如何触发" class="headerlink" title="2.4 如何触发"></a>2.4 如何触发</h3><ul><li>1.配置文件中默认的快照配置<br>冷拷贝后重新使用（主机和备份机器一定是两台）可以cp dump.rdb dump_new.rdb</li><li>2.命令save或bgsave<br>save:可以迅速生成dump.rdb，save的时候会只管保存其它的全部阻塞，在save的时候无法进来新的数据<br>bgsvae:redis会在后台异步进行快照操作，快照同时还可以响应客户端的需求，可以通过lastsave命令获取最后一次成功执行快照的时间</li><li>3.执行flushall和shutdown也会产生dump.rdb<br>但dump.rdb这时候是空的，没用</li></ul><h3 id="2-5-如何恢复"><a href="#2-5-如何恢复" class="headerlink" title="2.5 如何恢复"></a>2.5 如何恢复</h3><p>将备份文件dump.rdb移动到redis安装目录并启动服务即可（config get dir获取当前路径）</p><h3 id="2-6-优缺分析"><a href="#2-6-优缺分析" class="headerlink" title="2.6 优缺分析"></a>2.6 优缺分析</h3><ul><li>优点</li></ul><p>1.适合大规模的数据恢复<br>2.对数据的完整性和一致性要求不高<br>（比如你突然kill redis）这样当前两分钟的数据就丢失了，没有备份进去</p><ul><li>缺点</li></ul><p>1.在一定时间间隔做数据备份，如果redis意外down掉，就会丢失最后一次快照后的所有修改<br>2.Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。</p><h2 id="3-AOF持久化"><a href="#3-AOF持久化" class="headerlink" title="3.AOF持久化"></a>3.AOF持久化</h2><p>Append Only File<br>新技术的出现一定会弥补老技术的不足</p><h3 id="3-1-是什么？"><a href="#3-1-是什么？" class="headerlink" title="3.1 是什么？"></a>3.1 是什么？</h3><p>以日志的形式来记录每个写操作，将redis执行过的所有指令记录下来（读操作不做记录），只许追加文件，但不改写文件，redis启动之初会读取该文件重构数据，换言之，redis重启的话就根据日志文件的内容将写指令从头到尾执行一遍以完成数据恢复工作。</p><h3 id="3-2-相关配置"><a href="#3-2-相关配置" class="headerlink" title="3.2 相关配置"></a>3.2 相关配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># redis.conf</span><br><span class="line">appendonly yes</span><br><span class="line">appendsync</span><br><span class="line">1.always 同步持久化,每次发生数据变更会被立即记录到磁盘,性能较差但数据完整性比较好.</span><br><span class="line">2.Everysec 出厂默认,异步操作,每秒记录,如果一秒内宕机,会有数据丢失</span><br><span class="line">3.no</span><br></pre></td></tr></table></figure><h3 id="3-3-AOF恢复"><a href="#3-3-AOF恢复" class="headerlink" title="3.3 AOF恢复"></a>3.3 AOF恢复</h3><ul><li><p>1.正常恢复<br>启动:设置yes 修改默认appendonly no,改为yes<br>将有数据的aof文件复制一份保存到对应目录config get dir<br>恢复:重启redis然后重新加载</p></li><li><p>2.异常恢复<br>启动<br>备份被写坏的AOF文件<br>修复:redis-check-aof –fix appendonly.aof进行修复<br>恢复:重启redis加载</p></li></ul><h3 id="3-5-AOF重写"><a href="#3-5-AOF重写" class="headerlink" title="3.5 AOF重写"></a>3.5 AOF重写</h3><p>AOF有个缺点:一直往里面写越写越多,越来越大<br>这时候我们就需要压缩精简,而AOF已经提供好了精简算法</p><h4 id="3-5-1-是什么"><a href="#3-5-1-是什么" class="headerlink" title="3.5.1 是什么"></a>3.5.1 是什么</h4><p>新增重写机制防止AOF越写越大,当AOF文件大小超过设定的阀值,redis就会启动AOF文件的内容压缩,只保留可以恢复数据的最小指令集,可以使用命令bgrewriteaof</p><h4 id="3-5-2-重写原理"><a href="#3-5-2-重写原理" class="headerlink" title="3.5.2 重写原理"></a>3.5.2 重写原理</h4><p>AOF文件持续增长而过大时,会fork出一条新进程来将文件重写(也是先写临时文件最后再rename),遍历新进程的内存中数据,每条记录有一条的set语句,重写aof文件的操作,并没有读取旧的aof文件,而是将整个内存中的数据库内容用命令的方式重写进了一个新的aof文件,这点和快照很相似.</p><h4 id="3-5-3-触发机制"><a href="#3-5-3-触发机制" class="headerlink" title="3.5.3 触发机制"></a>3.5.3 触发机制</h4><p>redis会记录上次重写时的AOF大小,默认配置时当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发.<br>设置重写的基准值和百分比<br>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64MB<br>(大公司肯定不止64MB)3G是起步</p><h2 id="3-6-相较RDB的优劣"><a href="#3-6-相较RDB的优劣" class="headerlink" title="3.6 相较RDB的优劣"></a>3.6 相较RDB的优劣</h2><p>优势:每秒同步,每修改同步,不同步<br>劣势:相同数据集的数据AOF文件要远大于rdb文件,恢复速度远远慢于rdb文件,aof运行效率要慢于rdb,每秒同步策略较好,不同步频率和rdb相同.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-RDB持久化&quot;&gt;&lt;a href=&quot;#2-RDB持久化&quot; class=&quot;headerlink&quot; title=&quot;2 RDB持久化&quot;&gt;&lt;/a&gt;2 RDB持久化&lt;/h2&gt;&lt;h3 id=&quot;2-1-是什么？&quot;&gt;&lt;a href=&quot;#2-1-是什么？&quot; class=&quot;head</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="redis高级篇" scheme="http://example.com/categories/nosql/redis%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title>redis.conf解析</title>
    <link href="http://example.com/2021/06/03/redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/03/redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-03T13:16:10.347Z</published>
    <updated>2021-06-03T13:32:20.446Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"># General 通用常见标准化配置</span><br><span class="line">1.Redis默认不是以守护进程的方式运行，可以通过修改配置项，使用yes启用守护进程</span><br><span class="line">daemonize no -&gt; yes</span><br><span class="line"></span><br><span class="line">2.当Redis以守护进程方式运行时，Redis默认会把pid写入&#x2F;var&#x2F;run&#x2F;redis.pid文件，</span><br><span class="line">可以通过pidfile制定</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis.pid</span><br><span class="line"></span><br><span class="line">3.指定日志级别，Redis总共支持四个级别</span><br><span class="line">debug、verbose、notice、warning, 默认为notice</span><br><span class="line">debug建议开发阶段用notice生产环境用</span><br><span class="line">真的出故障就用warning只打出故障日志</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line">4.日志的记录方式，默认为标准输出。</span><br><span class="line">如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，</span><br><span class="line">则日志会发送给&#x2F;dev&#x2F;null</span><br><span class="line">logfile stdout</span><br><span class="line"></span><br><span class="line">5.如果希望日志打印到 syslog 中，也很容易，通过 syslog-enabled 来控制。</span><br><span class="line">syslog-enabled no</span><br><span class="line"></span><br><span class="line">6.另外，syslog-ident 还可以指定syslog 里的日志标志，比如：</span><br><span class="line">syslog-ident Redis</span><br><span class="line"></span><br><span class="line">7.而且还支持指定 syslog 设备，值可以是 USER 或 LOCAL0-LOCAL7 。</span><br><span class="line">具体可以参考 syslog 服务本身的用法。</span><br><span class="line">syslog-facility local0</span><br><span class="line"></span><br><span class="line">8.对于 Redis 来说，可以设置其数据库的总数量，</span><br><span class="line">假如希望一个 Redis 包含16个数据库，那么设置如下：</span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"># NETWORK</span><br><span class="line">1.指定Redis监听端口，默认端口为6379, 作者在博客中提到为什么用6379. </span><br><span class="line">因为6379代表MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字。</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line">2.绑定的主机地址</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line">3.当客户端闲置太长时间后关闭链接，如果指定为0，则表示关闭该功能</span><br><span class="line">(就像qq，30分钟没人给你发消息，你也没发消息，就终端连接减轻服务器负担)</span><br><span class="line">timeout 300</span><br><span class="line"></span><br><span class="line">4.tcp-backlog 511(默认511)</span><br><span class="line">backlog其实是一个连接队列，</span><br><span class="line">backlog队列总和&#x3D;未完成三次握手队列+已经完成三次握手队列</span><br><span class="line">在高并发的情况下，你需要一个高的backlog来避免慢客户端连接的问题，</span><br><span class="line">注意linux内核会将这个值减小到&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn的值</span><br><span class="line">所以需要确认增大somaxconn和tcp_max_syn_backlog两个值来达到想要的效果。</span><br><span class="line"></span><br><span class="line">5.tcp-keepalive</span><br><span class="line">TCP连接保活策略，可以通过 tcp-keepalive 配置项来进行设置，单位为秒，</span><br><span class="line">假如设置为60秒，则 server 端会每60秒向连接空闲的客户端发起一次 ACK 请求，</span><br><span class="line">以检查客户端是否已经挂掉，对于无响应的客户端则会关闭其连接。</span><br><span class="line">所以关闭一个连接最长需要120秒的时间。如果设置为0，则不会进行保活检测。</span><br><span class="line">tcp-keepalive 0</span><br><span class="line"></span><br><span class="line"># SNAPSHTTING快照</span><br><span class="line">备份</span><br><span class="line">1.save save + second + changes</span><br><span class="line">redis.conf的SNAPSHOTTING</span><br><span class="line">出发条件</span><br><span class="line">after 900 seconds if at least 1 key changed</span><br><span class="line">after 300 seconds if at least 10 keys changed</span><br><span class="line">after 60 seconds if at least 10000 keys changed</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">2.如果想禁用（save指令）（禁用RDB持久化策略），把三个默认删除，</span><br><span class="line">不要设置任何save指令或者给save传一个空字符串参数save “”</span><br><span class="line">3.你也可以在set key之后马上save</span><br><span class="line">set key</span><br><span class="line">save(手动挡)</span><br><span class="line">4.stop-writes-on-bgsave-error</span><br><span class="line">默认yes，出错了就刹车。</span><br><span class="line">5.rdbcompression yes</span><br><span class="line">是否启动压缩算法，LZF（如果你要节约cpu和内存耗损）则关闭，默认都用出厂设置。</span><br><span class="line">6.rdbchecksum</span><br><span class="line">在存储快照后，还可以让redis使用CRC64算法来进行数据校验，</span><br><span class="line">但这样会增加10%的性能消耗。继续用yes(mysql的checksum~)</span><br><span class="line"></span><br><span class="line">7.dbfilename</span><br><span class="line">叫dump.rdb</span><br><span class="line"></span><br><span class="line">8.dir</span><br><span class="line">config get dir可以获得，在哪里开启的该进程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># REPLICATION复制</span><br><span class="line"></span><br><span class="line"># security安全</span><br><span class="line">前提是认为内存缓存服务架构在一个安全加固环境里面</span><br><span class="line">所以出厂服务是不用输入密码</span><br><span class="line">config requirepass “123456”</span><br><span class="line">这样每次都要输入密码才能获取值。</span><br><span class="line"></span><br><span class="line"># limits回收机制</span><br><span class="line">1.maxclients 10000</span><br><span class="line">默认10000个人同时连接</span><br><span class="line">2.maxmemory</span><br><span class="line"></span><br><span class="line">3.maxmemory-policy当到达最大内存，你如何选择删除</span><br><span class="line">（考过，它的缓存过期配置如何理解配置）</span><br><span class="line">默认永不过期noeviction</span><br><span class="line">        对于内存移除规则来说， Redis 提供了多达6种的移除规则。他们是：</span><br><span class="line">        （1）volatile-lru：使用 LRU 算法移除过期集合中的 key</span><br><span class="line">        只对设置了过期时间的key</span><br><span class="line">        （2）allkeys-lru：使用 LRU 算法移除 key（所有）</span><br><span class="line">        （3）volatile-random：在过期集合中移除随机的 key</span><br><span class="line">        （4）allkeys-random：移除随机的 key</span><br><span class="line">        （5）volatile-ttl：移除那些 TTL 值最小的 key ，即那些最近要过期的 </span><br><span class="line">             key</span><br><span class="line">        （6）noeviction：不进行移除。针对写操作，只是返回错误信息</span><br><span class="line">        LRU:LAST RECENT USE最近最少使用</span><br><span class="line">        4.maxmemory-sample</span><br><span class="line">        LRU算法和最小TTL算法都并非是精确的算法，而是估算值。</span><br><span class="line">        所以可以设置样本的大小。假如Redis默认会检查三个key并选择其中LRU的那个，</span><br><span class="line">        那么可以改变这个key样本的数量。默认5个，3个精确度没那么高，但快。</span><br><span class="line">        maxmemory-samples 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-事务"><a href="#4-事务" class="headerlink" title="4 事务"></a>4 事务</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><h2 id="4-2-应用场景"><a href="#4-2-应用场景" class="headerlink" title="4.2 应用场景"></a>4.2 应用场景</h2><h2 id="4-3-基本使用"><a href="#4-3-基本使用" class="headerlink" title="4.3 基本使用"></a>4.3 基本使用</h2><h2 id="4-4-锁机制"><a href="#4-4-锁机制" class="headerlink" title="4.4 锁机制"></a>4.4 锁机制</h2><h1 id="5-发布订阅"><a href="#5-发布订阅" class="headerlink" title="5 发布订阅"></a>5 发布订阅</h1><h2 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h2><h2 id="5-2-基本命令"><a href="#5-2-基本命令" class="headerlink" title="5.2 基本命令"></a>5.2 基本命令</h2><h1 id="6-redis主从复制"><a href="#6-redis主从复制" class="headerlink" title="6 redis主从复制"></a>6 redis主从复制</h1><h2 id="6-1-常见主从"><a href="#6-1-常见主从" class="headerlink" title="6.1 常见主从"></a>6.1 常见主从</h2><h3 id="6-1-1-一主二从"><a href="#6-1-1-一主二从" class="headerlink" title="6.1.1 一主二从"></a>6.1.1 一主二从</h3><h3 id="6-1-2-薪火相传"><a href="#6-1-2-薪火相传" class="headerlink" title="6.1.2 薪火相传"></a>6.1.2 薪火相传</h3><h3 id="6-1-3-反客为主"><a href="#6-1-3-反客为主" class="headerlink" title="6.1.3 反客为主"></a>6.1.3 反客为主</h3><h2 id="6-2-主从复制原理"><a href="#6-2-主从复制原理" class="headerlink" title="6.2 主从复制原理"></a>6.2 主从复制原理</h2><h2 id="6-3-哨兵模式"><a href="#6-3-哨兵模式" class="headerlink" title="6.3 哨兵模式"></a>6.3 哨兵模式</h2><h1 id="7-redis集群与方案"><a href="#7-redis集群与方案" class="headerlink" title="7 redis集群与方案"></a>7 redis集群与方案</h1><h2 id="7-1-集群概念"><a href="#7-1-集群概念" class="headerlink" title="7.1 集群概念"></a>7.1 集群概念</h2><h2 id="7-2-一致性hash与虚拟节点"><a href="#7-2-一致性hash与虚拟节点" class="headerlink" title="7.2 一致性hash与虚拟节点"></a>7.2 一致性hash与虚拟节点</h2><h2 id="7-3-redis内置集群详解"><a href="#7-3-redis内置集群详解" class="headerlink" title="7.3 redis内置集群详解"></a>7.3 redis内置集群详解</h2><h3 id="7-3-1-搭建配置"><a href="#7-3-1-搭建配置" class="headerlink" title="7.3.1 搭建配置"></a>7.3.1 搭建配置</h3><h3 id="7-3-2-slots槽概念"><a href="#7-3-2-slots槽概念" class="headerlink" title="7.3.2 slots槽概念"></a>7.3.2 slots槽概念</h3><h3 id="7-3-3-切换原理"><a href="#7-3-3-切换原理" class="headerlink" title="7.3.3 切换原理"></a>7.3.3 切换原理</h3><h1 id="8-redis布隆过滤器"><a href="#8-redis布隆过滤器" class="headerlink" title="8 redis布隆过滤器"></a>8 redis布隆过滤器</h1><h2 id="8-1-是什么？"><a href="#8-1-是什么？" class="headerlink" title="8.1 是什么？"></a>8.1 是什么？</h2><h2 id="8-2-基本使用"><a href="#8-2-基本使用" class="headerlink" title="8.2 基本使用"></a>8.2 基本使用</h2><h1 id="9-性能调优"><a href="#9-性能调优" class="headerlink" title="9 性能调优"></a>9 性能调优</h1><h2 id="常见大key分析"><a href="#常见大key分析" class="headerlink" title="常见大key分析"></a>常见大key分析</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="10-分布式锁解决方案"><a href="#10-分布式锁解决方案" class="headerlink" title="10 分布式锁解决方案"></a>10 分布式锁解决方案</h1><h2 id="10-1-基本setnx实现"><a href="#10-1-基本setnx实现" class="headerlink" title="10.1 基本setnx实现"></a>10.1 基本setnx实现</h2><h2 id="10-2-redlock"><a href="#10-2-redlock" class="headerlink" title="10.2 redlock"></a>10.2 redlock</h2><h2 id="10-3-zookeeper"><a href="#10-3-zookeeper" class="headerlink" title="10.3 zookeeper"></a>10.3 zookeeper</h2><h1 id="11-linux多路复用和redis单线程"><a href="#11-linux多路复用和redis单线程" class="headerlink" title="11 linux多路复用和redis单线程"></a>11 linux多路复用和redis单线程</h1><h2 id="11-1-select"><a href="#11-1-select" class="headerlink" title="11.1 select"></a>11.1 select</h2><h2 id="11-2-poll"><a href="#11-2-poll" class="headerlink" title="11.2 poll"></a>11.2 poll</h2><h2 id="11-3-epoll"><a href="#11-3-epoll" class="headerlink" title="11.3 epoll"></a>11.3 epoll</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="redis高级篇" scheme="http://example.com/categories/nosql/redis%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title>五大数据类型</title>
    <link href="http://example.com/2021/06/03/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2021/06/03/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-06-03T13:09:25.014Z</published>
    <updated>2021-06-03T13:10:47.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-1-string"><a href="#4-1-string" class="headerlink" title="4.1 string"></a>4.1 string</h3><p>一个key对应一个value（和Memcached一样），字符串是一种最基本的Redis值类型。Redis字符串是二进制安全的，这意味着一个Redis字符串能包含任意类型的数据，例如： 一张JPEG格式的图片或者一个序列化的Ruby对象，一个字符串类型的值最多能存储512M字节的内容。</p><h4 id="4-1-1-基础命令"><a href="#4-1-1-基础命令" class="headerlink" title="4.1.1 基础命令"></a>4.1.1 基础命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 常见增删改</span><br><span class="line">1.get set</span><br><span class="line">2.append k1 12345</span><br><span class="line">3.strlen k1 获取长度</span><br><span class="line">4.incr k2 (set k2 2)增加整数的值比如浏览量加放在redis</span><br><span class="line">5.decr k2 减</span><br><span class="line">6.incrby k2 3 加3</span><br><span class="line">7.decrby k2 2 减2（封装原子操作，一个线程加，一个减）</span><br><span class="line"></span><br><span class="line">8.getrange #　获取区间范围的值类似与between and</span><br><span class="line">　getrange k1 0 -1  # 获取0到-1的值</span><br><span class="line">　getrange k1 0 3   # 和切片一样</span><br><span class="line">　</span><br><span class="line">9.setrange修改开始位置的值</span><br><span class="line">　setrange k1 0 xxx 把前三个数设置为xxx</span><br><span class="line">　get k1</span><br><span class="line">　</span><br><span class="line">10.setex(set with expire)键秒值&#x2F;setnx（set if not exists）</span><br><span class="line">　　setex k1 10 v4设置10秒过期</span><br><span class="line">　　setnx k1 v100返回0表示已存在无法设置</span><br><span class="line">　　</span><br><span class="line">11.mset&#x2F;mget&#x2F;msetnx</span><br><span class="line">　d多个设置，获取</span><br><span class="line">　mset k1 v1 k2 v2 k3 v3</span><br><span class="line">　msetnx k1 v1 k5 v5 只要有一个存在就翻车</span><br><span class="line">　</span><br><span class="line">12.getset</span><br><span class="line">　getset k1 v100（获取原来的值，赋予新的值）</span><br></pre></td></tr></table></figure><h4 id="4-1-2-应用场景"><a href="#4-1-2-应用场景" class="headerlink" title="4.1.2 应用场景"></a>4.1.2 应用场景</h4><ul><li>作为邮件开关，点击开关</li><li>计数器，粉丝数、购买人数、浏览人数、限流（incr,decr)</li><li>使用setbit/getbit实现bloom过滤器</li></ul><p>这里需要注意的是，redis本身是单线程的，所以做计数器不用考虑并发带来的影响，且redis内存存储并支持集群、持久化的特性，使得redis高效快速，适合做高并发系统的计数器。bloom是解决缓存穿透的有效方法（请求进来先用bloom判断是否存在，存在再去那数据不存在直接返回），也是过滤一些特定大数据的解决方案（比如几亿的用户，需要看进来的用户是否是新用户</p><h4 id="4-1-3-内部源码"><a href="#4-1-3-内部源码" class="headerlink" title="4.1.3 内部源码"></a>4.1.3 <a href="https://my.oschina.net/mengyuankan/blog/1926320">内部源码</a></h4><h3 id="4-2-list"><a href="#4-2-list" class="headerlink" title="4.2 list"></a>4.2 <a href="https://segmentfault.com/a/1190000016901154">list</a></h3><p>redis的list底层是双向链表的结构，其底层实现有三种linkdlist、ziplist和quicklist。</p><ul><li>redis 3.2之前<br>默认使用linklist和ziplist<br>linklist作为基础的朴素双向链表。<br>ziplist作为基本存储的压缩双向链表，ziplist所有信息保存在连续的内存中，每次修改都需要realloc或者memmove，所以效率比较低，是为了节省内存设计的。<br>ziplist要求单个节点小于64bytes，总数量小于512个，当数据量超出标准就会使用linkedlist，最大为2**32-1个值 </li><li>redis 3.2 之后<br>使用quicklist作为默认底层</li></ul><h4 id="4-2-1-基础命令"><a href="#4-2-1-基础命令" class="headerlink" title="4.2.1 基础命令"></a>4.2.1 基础命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lpush&#x2F;rpush k v</span><br><span class="line">lrange k start end</span><br><span class="line">lpushx&#x2F;rpushx k v（当k不存在不会创建）</span><br><span class="line">lpop&#x2F;rpop k</span><br><span class="line">lrem k count v 移除指定个数的值为v的元素，count&#x3D;0移除所有</span><br><span class="line">ltrim k start end 截取并保留范围值</span><br><span class="line">lindex k idx 索引</span><br><span class="line">llen k</span><br><span class="line">linsert k after|before v value 在固定的某个元素前或者后插入元素</span><br><span class="line">rpoplpush k v</span><br><span class="line">lset k idx v</span><br></pre></td></tr></table></figure><h4 id="4-2-2-应用场景"><a href="#4-2-2-应用场景" class="headerlink" title="4.2.2 应用场景"></a>4.2.2 应用场景</h4><ul><li>消息队列（celery）安全消息队列复制一份进行操作避免消费者异常</li><li>排行榜（每隔一段时间更新一次）</li><li>最新列表（点赞列表、评论列表）（固定条数左进右出）</li></ul><h4 id="4-2-3-内部源码"><a href="#4-2-3-内部源码" class="headerlink" title="4.2.3 内部源码"></a>4.2.3 <a href="https://blog.liexing.me/2019/12/28/from-ziplist-linkedlist-to-quicklist/">内部源码</a></h4><h5 id="4-2-3-1-ziplist源码分析"><a href="#4-2-3-1-ziplist源码分析" class="headerlink" title="4.2.3.1 ziplist源码分析"></a>4.2.3.1 ziplist源码分析</h5><p>ziplist是一种特殊编码的节省内存空间的双链表，能以O(1)的时间复杂度在两端push和pop数据，具有如下结构：<br><zlbytes><zltail><zllen><entry><entry><zlend></p><ul><li>zlbytes是一个unsigned integer，保存ziplist占用的总内存空间，在重新分配内存时，借助这个字段可以不用遍历整个ziplist；</li><li>zltail是指向最后一个entry的偏移量，这样对于尾部的操作不用去遍历所有entry；</li><li>zllen固定两个字节长度，表示entry的数量，最大能表示2^16-2个entry，如果超过了，则其值为2^16-1，需要遍历entry才能知道具体的数量；</li><li>zlend固定一个字节，值固定为255，表示ziplist的结尾。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ziplist.c</span><br><span class="line">&#x2F;* Create a new empty ziplist. *&#x2F;</span><br><span class="line">unsigned char *ziplistNew(void) &#123;</span><br><span class="line">    unsigned int bytes &#x3D; ZIPLIST_HEADER_SIZE+1;</span><br><span class="line">    unsigned char *zl &#x3D; zmalloc(bytes);</span><br><span class="line">    ZIPLIST_BYTES(zl) &#x3D; intrev32ifbe(bytes);</span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) &#x3D; intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) &#x3D; 0;</span><br><span class="line">    zl[bytes-1] &#x3D; ZIP_END;</span><br><span class="line">    return zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-hash"><a href="#4-3-hash" class="headerlink" title="4.3 hash"></a>4.3 hash</h3>KV模式不变，但v是一个键值对，理论最大为2^32-1个键值对</li></ul><h4 id="4-3-1-基础命令"><a href="#4-3-1-基础命令" class="headerlink" title="4.3.1 基础命令"></a>4.3.1 基础命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.hset&#x2F;hget&#x2F;hmset&#x2F;hmget&#x2F;hgetall&#x2F;hdel</span><br><span class="line">  hset user id 11</span><br><span class="line">  hget user id</span><br><span class="line">  hmset cutomer name z3 id 2 age 26</span><br><span class="line">  hmget customer id name age</span><br><span class="line">  hgetall customer</span><br><span class="line">  hdel user name</span><br><span class="line">2.hlen user</span><br><span class="line">3.hexists key</span><br><span class="line">  hexists customer id</span><br><span class="line">4.hkeys&#x2F;hvals</span><br><span class="line">  hkeys customer 获取所有的键&#x2F;值</span><br><span class="line">5.hincrby&#x2F;hincrbyfloat</span><br><span class="line">  hincrby customer age 1</span><br><span class="line">  hset customer score 91.5</span><br><span class="line">  hincrby customer score 1.5</span><br><span class="line">6.hsetnx</span><br></pre></td></tr></table></figure><h4 id="4-3-2-应用场景"><a href="#4-3-2-应用场景" class="headerlink" title="4.3.2 应用场景"></a>4.3.2 应用场景</h4><ul><li><strong>用户信息存储</strong>，如果用string存储用户信息打包，内容修改时需要取出全部信息，使用hash只需要取出该字段即可。</li><li><strong>购物车数据</strong>，未登录用cookie存储购物车数据，登录使用redis的hash存储数据。</li></ul><h4 id="4-3-3-内部源码"><a href="#4-3-3-内部源码" class="headerlink" title="4.3.3 内部源码"></a>4.3.3 内部源码</h4><h3 id="4-4-set"><a href="#4-4-set" class="headerlink" title="4.4 set"></a>4.4 set</h3><h4 id="4-4-1-基础命令"><a href="#4-4-1-基础命令" class="headerlink" title="4.4.1 基础命令"></a>4.4.1 基础命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.sadd&#x2F;smembers&#x2F;sismember</span><br><span class="line">sadd set01 1 1 2 2 3 3会把重复的数去掉并构建set</span><br><span class="line">smembers set01 查看set01的元素</span><br><span class="line">sismember set01 x 是成员返回1不是0</span><br><span class="line">2.scard</span><br><span class="line">scard set01 获取set01元素个数</span><br><span class="line">3.srem key vlaue 删除集合中的元素</span><br><span class="line">srem set01 3</span><br><span class="line">4.srandmember set02 3从集合中随机取出3个</span><br><span class="line">（就像什么抽红包，从100个里面随机抽10个）</span><br><span class="line">5.spop key 随机出栈</span><br><span class="line">spop set01</span><br><span class="line">6.smove key1 key2 val在key1里的某个值 赋给key2</span><br><span class="line">smove set02 set01 7</span><br><span class="line">smembers set01</span><br><span class="line">7.数学集合类</span><br><span class="line">差集：sdiff</span><br><span class="line">sdiff set01 set02 在第一个里面不在第二个里面的</span><br><span class="line">sdiff set02 set01</span><br><span class="line">交集：sinter</span><br><span class="line">sinter set01 set02相交部分</span><br><span class="line">并集：sunion set01 set02</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-4-2-应用场景"><a href="#4-4-2-应用场景" class="headerlink" title="4.4.2 应用场景"></a>4.4.2 应用场景</h4><ul><li>共同好友、共同关注、相似关注、共同喜好</li><li>可以将一个用户的所有关注存在一个集合，粉丝存在一个集合</li><li>去重</li><li><h4 id="4-4-3-内部源码"><a href="#4-4-3-内部源码" class="headerlink" title="4.4.3 内部源码"></a>4.4.3 内部源码</h4>zset和set一样也是string类型元素的集合，且不允许重复的成员不同的是(在set的基础上加)每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员来进行大小排序，zset的成员是唯一的，但分数score可以重复。</li></ul><h2 id="4-5-zset-sorted-set"><a href="#4-5-zset-sorted-set" class="headerlink" title="4.5 zset(sorted set)"></a>4.5 zset(sorted set)</h2><h3 id="4-5-1-基础命令"><a href="#4-5-1-基础命令" class="headerlink" title="4.5.1 基础命令"></a>4.5.1 基础命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.zadd&#x2F;zrange</span><br><span class="line">zadd zset01 60 v1 70 v2 80 v3 90 v4 100 v5</span><br><span class="line">zrange zset01 0 -1</span><br><span class="line">zadd 60 v9</span><br><span class="line">zrange zset01 0 -1 withscores</span><br><span class="line">2.zrangebyscore key</span><br><span class="line">zrangebyscore zset 60 90 60到90分的</span><br><span class="line">3.zrangebyscore zset01 (60 (90</span><br><span class="line">大于60小于90不包含</span><br><span class="line">4. zrangebyscore key 60 90 limit 2 2</span><br><span class="line">从第二个开始截取两个</span><br><span class="line">5.zrem zseto1 v5</span><br><span class="line">删除v5</span><br><span class="line">6.zcard 统计个数</span><br><span class="line">zcard zset01</span><br><span class="line">7.zcount + key + score区间</span><br><span class="line">zcount zset01 60 80统计60到80的数量</span><br><span class="line">8.zrank zset04 v4获取下标的值（索引值）</span><br><span class="line">9.zscore zset01 v4获取v4的得分</span><br><span class="line">10.zrevrank key values 逆序获得下标</span><br><span class="line">11.zrevrange zset01 0 -1逆序遍历</span><br><span class="line">12.zrevrangebyscore key</span><br></pre></td></tr></table></figure><h3 id="4-5-2-应用场景"><a href="#4-5-2-应用场景" class="headerlink" title="4.5.2 应用场景"></a>4.5.2 应用场景</h3><ul><li>排行榜</li><li>带权重的消息队列</li></ul><h3 id="4-5-3-内部源码"><a href="#4-5-3-内部源码" class="headerlink" title="4.5.3 内部源码"></a>4.5.3 内部源码</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;4-1-string&quot;&gt;&lt;a href=&quot;#4-1-string&quot; class=&quot;headerlink&quot; title=&quot;4.1 string&quot;&gt;&lt;/a&gt;4.1 string&lt;/h3&gt;&lt;p&gt;一个key对应一个value（和Memcached一样），字符串是一种最基本</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="redis" scheme="http://example.com/categories/nosql/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>redis下载安装</title>
    <link href="http://example.com/2021/06/03/download/"/>
    <id>http://example.com/2021/06/03/download/</id>
    <published>2021-06-03T13:06:42.632Z</published>
    <updated>2021-06-03T13:08:30.839Z</updated>
    
    <content type="html"><![CDATA[<h3 id="3-1-是什么"><a href="#3-1-是什么" class="headerlink" title="3.1 是什么"></a>3.1 是什么</h3><p>Remote Dictionary Server（远程字典服务器）<br>是完全开源的用C语言编写的，遵守BSD协议，是一个高性能、单线程的KEY/value分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，也被人们称为数据结构服务器</p><h4 id="3-1-1-为什么redis取代memcache？"><a href="#3-1-1-为什么redis取代memcache？" class="headerlink" title="3.1.1 为什么redis取代memcache？"></a>3.1.1 为什么redis取代memcache？</h4><ul><li>1.支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li><li>2.不仅仅支持简单的key-value类型数据，同时还提供list，set，zset，hash等数据结构的存储，且存储容量大。</li><li>3.支持数据备份，即master-slave模式的数据备份</li></ul><h3 id="3-3-下载配置"><a href="#3-3-下载配置" class="headerlink" title="3.3 下载配置"></a>3.3 下载配置</h3><ul><li><p>1.windows下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;dmajkic&#x2F;redis&#x2F;dowloads&#x2F;</span><br><span class="line">下载好 cd到该盘</span><br><span class="line">cmd运行redis-server.exe redis.conf</span><br><span class="line">这时启用另一个cmd，切换到redis目录下运行redis-cli.exe –h 127.0.0.1 –p 6379</span><br><span class="line">设置键值对 set myKey abc</span><br><span class="line">取出键值对 get myKey</span><br></pre></td></tr></table></figure></li><li><p>2.linux下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">官网下载</span><br><span class="line">tar –zxvf redis-3.0.4.tar.gz</span><br><span class="line">cd redis-6.0.6</span><br><span class="line">安装gcc</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_35976271&#x2F;article&#x2F;details&#x2F;88739607</span><br><span class="line">Jemalloc&#x2F;Jemalloc.h：没有那个文件或目录</span><br><span class="line">由于上一次make没有安装gcC导致残存一些文件需要删除</span><br><span class="line">运行make distclean之后再make</span><br><span class="line">redis 6.0.6需要gcc在5.0版本以上，用centos7的镜像只有gcc4.8.5所以需要升级</span><br><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line">scl enable devtoolset-9 bash</span><br><span class="line">echo &quot;source &#x2F;opt&#x2F;rh&#x2F;devtoolset-9&#x2F;enable&quot; &gt;&gt; &#x2F;etc&#x2F;profile</span><br><span class="line">gcc –v</span><br><span class="line">运行make</span><br><span class="line">make install</span><br><span class="line">正常来说可以把redis.conf扔到etc下边，但我们这里创建文件夹myredis cp redis.conf &#x2F;myredis&#x2F;</span><br><span class="line">修改vim myredis  general 第一个参数改为yes</span><br><span class="line">cd usr&#x2F;local&#x2F;bin&#x2F;</span><br><span class="line">redis-server &#x2F;myredis&#x2F;redis.conf</span><br><span class="line">redis-cli (–h远程ip) –p 6379 </span><br><span class="line">ping</span><br><span class="line">set k1 helloworld</span><br><span class="line">get k1</span><br><span class="line">shutdown可以关闭，重启redis-server &#x2F;myredis&#x2F;redis.conf</span><br><span class="line">redis-benchmark检测电脑redis性能，每秒存读。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;3-1-是什么&quot;&gt;&lt;a href=&quot;#3-1-是什么&quot; class=&quot;headerlink&quot; title=&quot;3.1 是什么&quot;&gt;&lt;/a&gt;3.1 是什么&lt;/h3&gt;&lt;p&gt;Remote Dictionary Server（远程字典服务器）&lt;br&gt;是完全开源的用C语言编写的</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="redis" scheme="http://example.com/categories/nosql/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>CAP&amp;BASE</title>
    <link href="http://example.com/2018/09/05/CAP&amp;BASE/"/>
    <id>http://example.com/2018/09/05/CAP&amp;BASE/</id>
    <published>2018-09-04T19:11:30.000Z</published>
    <updated>2021-06-03T13:10:22.351Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2-1-RDBMS-ACID"><a href="#2-1-RDBMS-ACID" class="headerlink" title="2.1 RDBMS ACID"></a>2.1 RDBMS <strong>ACID</strong></h3><ul><li>1.A atomicity         原子性<br>事务的成功条件是所有操作完成，事务失败整体回滚</li><li>2.C consistency     一致性<br>数据库要一直处于一个一致的状态，事务让数据库从一个一致的状态，到另一个一致的状态</li><li>3.I isolation        隔离性<br>事务之间互不影响（要看事务的隔离级别）</li><li>4.D duriability        持久性<br>一旦事务提交，对数据库的操作就是永久的</li></ul><h3 id="2-2-Nosql-CAP"><a href="#2-2-Nosql-CAP" class="headerlink" title="2.2 Nosql CAP"></a>2.2 Nosql <strong>CAP</strong></h3><ul><li>1.C:Consistency 强一致性</li><li>2.A:Availability 可用性</li><li>3.Partition tolerance 分区容错性</li></ul><h4 id="2-2-1-CAP理论核心"><a href="#2-2-1-CAP理论核心" class="headerlink" title="2.2.1 CAP理论核心"></a>2.2.1 CAP理论核心</h4><p>1.一个分布式的系统不可能同时很好的满足一致性，可用性，分区容错性,最多只能满足两个。</p><ul><li>CA– 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。（RDBMS传统）</li><li>CP– 满足一致性，分区容忍的系统，通常性能不是特别高MongoDB HBase Redis</li><li>AP– 满足可用性，分区容忍的系统，通常对一致性的要求低一些。(这个用的多)（CouchDB，CassandraDB，）</li></ul><p>2.P分区容忍性是我们必须要实现的，所以我们要在一致性C和可用性A之间权衡</p><ul><li>CA传统数据库</li><li>AP大多数网站架构的选择 传统分布式的选择（电商，金融系统）</li><li>CP Redis MongoDB（帮数据库减负）</li></ul><h2 id="2-3-BASE"><a href="#2-3-BASE" class="headerlink" title="2.3 BASE"></a>2.3 BASE</h2><ul><li>基本可用BA Basically Available</li><li>软状态  S  Soft     state</li><li>最终一致性 Eventually consistent<br>如浏览数，就算弱一致性，也不能差的太离谱，等高峰过了以后，要逐渐达到一致。 </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;2-1-RDBMS-ACID&quot;&gt;&lt;a href=&quot;#2-1-RDBMS-ACID&quot; class=&quot;headerlink&quot; title=&quot;2.1 RDBMS ACID&quot;&gt;&lt;/a&gt;2.1 RDBMS &lt;strong&gt;ACID&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="redis" scheme="http://example.com/categories/nosql/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>NoSql发展史</title>
    <link href="http://example.com/2018/09/05/nosql%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2018/09/05/nosql%E4%BB%8B%E7%BB%8D/</id>
    <published>2018-09-04T19:11:30.000Z</published>
    <updated>2021-06-03T13:12:07.180Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-1-Nosql概念"><a href="#1-1-Nosql概念" class="headerlink" title="1.1 Nosql概念"></a>1.1 Nosql概念</h3><p>nosql means not only sql</p><h3 id="1-2-为什么Nosql"><a href="#1-2-为什么Nosql" class="headerlink" title="1.2 为什么Nosql?"></a>1.2 为什么Nosql?</h3><p>web架构历史了解一下orz</p><h4 id="1-2-1-单机mysql的美好年代"><a href="#1-2-1-单机mysql的美好年代" class="headerlink" title="1.2.1 单机mysql的美好年代"></a>1.2.1 单机mysql的美好年代</h4><p>90年代，一个网站的访问量一般都不大，用单个数据库完全可以轻松应付，在那个时候，更多的网页都是静态的，动态交互类型的网站不多。<br><strong>APP（应用层）-&gt; DAL() -&gt; MysqlINSTANCE</strong></p><p><strong>架构缺陷</strong></p><ul><li>1.数据量的总大小，一个机器放不下时。单表500万预警优化分割。</li><li>2.数据的索引（B+Tree）一个机器内存放不下时，为了查询快速需要建立很多索引，这就需要很多磁盘空间。</li><li>3.访问量（读写混合）一个实例不能承受，真正的生产应该做到主从复制读写分离。<br>当遇到这些瓶颈时，我们就需要把我们的技术架构改变。</li></ul><h4 id="1-2-2-Memcached-缓存-mysql-垂直分离"><a href="#1-2-2-Memcached-缓存-mysql-垂直分离" class="headerlink" title="1.2.2 Memcached(缓存) + mysql + 垂直分离"></a>1.2.2 Memcached(缓存) + mysql + 垂直分离</h4><p>随着访问量的提升，几乎大部分使用MySQL架构的网站在数据库上开始出现性能问题，web程序不再仅仅专注在功能上，同时也在追求性能，程序员们开始大量的使用缓存技术来缓解数据库的压力，优化数据库的结构和索引。<br>开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带来了比较高的IO压力，在这个时候，Memcached/redis就自然的成了一个非常时尚的技术产品。<br>=============== business2 mysql instance<br>APP -&gt;DAL -&gt;cache  business1 mysql instance<br>=============== userinfo  mysql instance<br>1.memcached/redis在cache层为数据库缓解压力，频繁的查询固定的数据我们就可以把固定的数据宅出来放缓存里面，减轻数据库压力。<br>2.mysql垂直拆分，一个数据库装不住，买家和卖家分成两个数据库，数据库实例分担。</p><h4 id="1-2-3-mysql主从复制读写分离"><a href="#1-2-3-mysql主从复制读写分离" class="headerlink" title="1.2.3 mysql主从复制读写分离"></a>1.2.3 mysql主从复制读写分离</h4><p>由于数据库写入压力的增加，Memcached只能缓解数据库的读取压力，读写集中在一个数据库上，让数据库不堪重负，大部分网站开始使用主从复制技术从而达到读写分离，以提高读写性能和读库的可扩展性。Mysql的master-slave模式成为了这个时代网站的标配。</p><p>除了之前的redis和垂直拆分，新增加了主从复制和读写分离，进一步缓解了mysql写和读的压力。</p><h4 id="1-2-4-分库分表-水平拆分-mysql集群"><a href="#1-2-4-分库分表-水平拆分-mysql集群" class="headerlink" title="1.2.4 分库分表 + 水平拆分 + mysql集群"></a>1.2.4 分库分表 + 水平拆分 + mysql集群</h4><p>在Memcached的高速缓存，mysql的主从复制，读写分离的基础上，这时mysql主库的写压力开始出现瓶颈的时候，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁表问题，大量的高并发Mysql应用开始使用InnoDB引擎代MyISAM，同时，开始流行使用分表分库来缓解写压力和新数据增长的扩展问题，这个时候，分表分库成了一个热门技术，是面试的热门问题，也是业界的热门技术问题。就在这个时候，mysql推出了还不太稳定的表分区，这也给一般的公司带来了希望。虽然MySQL推出了MySQLCluster集群，但性能也不能很好的满足互联网的要求，只是在高可靠性上提供了非常大的保证。<br>尽量的仅耦合把业务相关的分在一个库，把业务其它不相关的单独放置</p><ul><li>1.冷数据就单独放置。比如用户的其他注册信息，身份证号码没人天天换。</li><li>2.热数据跟业务相关的紧密的数据放在一起，（频繁）</li><li>3.分库分表比如1到3000万的数据进1号库，3000到6000万的数据进2号库</li></ul><h4 id="1-2-5-mysql瓶颈"><a href="#1-2-5-mysql瓶颈" class="headerlink" title="1.2.5 mysql瓶颈"></a>1.2.5 mysql瓶颈</h4><p>即使是用到了各种技术，myql还是会有它的瓶颈，mysql数据库经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本接近40GB大小，如果能够把这些数据从Mysql省去，mysql将变得非常的小，关系型数据库很强大，但它并不能很好的应付所有的应用场景，mysql的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前mysql的瓶颈所在。<br>比如说vcr，大的二进制数据，图片，文件，视屏，并不能放到mysql里面这样数据库会非常的慢</p><h4 id="1-2-6-现今的时代"><a href="#1-2-6-现今的时代" class="headerlink" title="1.2.6 现今的时代"></a>1.2.6 现今的时代</h4><p>nginx代替appach做负载均衡反向代理的服务器</p><p>客户 -&gt; 企业防火墙 -&gt; 负载均衡的主机和备机nginx -&gt; app应用服务器集群 -&gt; mysql-oracle集群 -&gt; hadoop集群（缓存服务器，通信服务器，流媒体服务器（专门存储视频这种流），电子邮件服务器，图片（文件）服务器，转发服务器）</p><h4 id="1-2-7-为什么nosql"><a href="#1-2-7-为什么nosql" class="headerlink" title="1.2.7 为什么nosql?"></a>1.2.7 为什么nosql?</h4><p>1.传统关系型数据库难以解决一些多字段问题<br>2.传统关系型数据库难以解决大规模数据集合多重数据种类<br>3.性能问题，nosql具有极高的读写能力，因为内存存储</p><h3 id="1-3-nosql概述"><a href="#1-3-nosql概述" class="headerlink" title="1.3 nosql概述"></a>1.3 nosql概述</h3><p>泛指非关系型数据库，随着互联网web2.0网站的兴起，传统的关系型数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系的数据库由于其本身特点得到了非常迅速的发展，Nosql数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括大规模数据的存储。</p><h4 id="1-3-1-传统RDBMS-vs-NoSql"><a href="#1-3-1-传统RDBMS-vs-NoSql" class="headerlink" title="1.3.1 传统RDBMS vs NoSql"></a>1.3.1 传统RDBMS vs NoSql</h4><ul><li><p>RDBMS:</p><ul><li>1.高度组织化结构化数据</li><li>2.结构化查询语言（SQL）</li><li>3.数据和关系都存储在单独的表中</li><li>4.数据操纵语言，数据定义语言</li><li>5.严格的一致性</li><li>6.基础事务</li></ul></li><li><p>2.NoSql</p><ul><li>1.代表着不仅仅是SQL</li><li>2.没有声明性查询语言</li><li>3.没有预定义的模式</li><li>4.键值对存储，列存储，文档存储，图形数据库</li><li>5.最终一致性而非ACID属性</li><li>6.非结构化和不可预知的数据</li><li>7.CAP定理</li><li>8.高性能，高可用性和可伸缩性</li></ul></li></ul><h3 id="1-4-nosql统称聚合模型"><a href="#1-4-nosql统称聚合模型" class="headerlink" title="1.4 nosql统称聚合模型"></a>1.4 nosql统称聚合模型</h3><ul><li><p>1.KV键值对</p></li><li><p>2.BSON<br>BSON是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和json一样，支持内嵌的文档对象和数组对象<br>BSON模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">“customer”:&#123;</span><br><span class="line">“id”:1136,</span><br><span class="line">“name”:”z3”,</span><br><span class="line">“billingAddress”:[&#123;“city”:”Beijing”&#125;],</span><br><span class="line">“order”:[</span><br><span class="line">&#123;</span><br><span class="line">“id”:17,</span><br><span class="line">“customerId”:1136,</span><br><span class="line">“orderItem”:[&#123;“productId”:27, “price”:77.5, “productName”:”thinging in java”&#125;],</span><br><span class="line">“shippingAddress”:[&#123;“city”:”Beijing”&#125;]</span><br><span class="line">“orderPayment”:[&#123;“ccinfo”:”11231”, “txniid”:”sfafa233”, “billingAddress”:&#123;“city”:”Beijing”&#125;&#125;],</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>3.列族<br>按列存储数据，存储结构化和半结构化数据，方便数据压缩，对针对某一列或某几列的查询有非常大的IO优势。</p></li><li><p>4.图形<br>什么qq的共同好友，分组之类的。网状的数据模型介绍</p></li></ul><h3 id="1-5-nosql数据库四大分类"><a href="#1-5-nosql数据库四大分类" class="headerlink" title="1.5 nosql数据库四大分类"></a>1.5 nosql数据库四大分类</h3><h4 id="1-5-1-KV键值对"><a href="#1-5-1-KV键值对" class="headerlink" title="1.5.1 KV键值对"></a>1.5.1 KV键值对</h4><p>有些企业说他的项目用到了redis，可能只是加了这个技术，用了很小一块，可能只用到了KV键值对。<br>新浪：BerkeleyDB + redis<br>美团：redis + tair<br>阿里、百度：memcache + redis</p><ul><li>1.典型类型<br>Tokyo    Cabinet/Tyrant Redis Voldemort Oracle BOB</li><li>2.应用场景<br>内容缓存、主要用于处理大量数据的高访问负载，也用于一些日志系统等</li><li>3.数据模型<br>通常用hash table来实现</li><li>4.优缺点<br>查找数据快，但数据无结构化，通常只能被当做字符串或二进制数据</li></ul><h4 id="1-5-2-文档型数据库（bson格式比较多）"><a href="#1-5-2-文档型数据库（bson格式比较多）" class="headerlink" title="1.5.2 文档型数据库（bson格式比较多）"></a>1.5.2 文档型数据库（bson格式比较多）</h4><ul><li>1.典型类型<br>CouchDB<br>MongoDB<br>是一个基于分布式文件存储的数据库，由C++编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案<br>是一个介于关系型和非关系型数据库之间的产品，是非关系型数据库中功能最丰富，最像关系型数据库的。</li><li>2.应用场景<br>web应用（与KV类似）value是结构化的，不同的是数据库能够了解value的内容。</li><li>3.数据类型<br>KV对应的键值对，value为结构化数据</li><li>4.优缺点<br>数据结构要求不严，表结构可变，不需要像关系型数据库一样预先定义表结构。<br>查询性能不高，而且缺乏统一的查询语法。</li></ul><h4 id="1-5-3-列存储数据库"><a href="#1-5-3-列存储数据库" class="headerlink" title="1.5.3 列存储数据库"></a>1.5.3 列存储数据库</h4><ul><li>1.典型类型<br>Cassandra，HBase（hadoop） Rlak</li><li>2.应用场景<br>分布式文件系统</li><li>3.数据类型<br>以列簇式存储将同一列数据存在一起</li><li>4.优缺点<br>功能相对局限</li></ul><h4 id="1-5-4-图关系数据库"><a href="#1-5-4-图关系数据库" class="headerlink" title="1.5.4 图关系数据库"></a>1.5.4 图关系数据库</h4><p>它不是放图形的，放的关系比如：朋友圈社交网络、广告推荐系统社交网络、推荐系统等。专注于构建关系图谱。利用图结构相关算法，很多时候需要对整个图进行计算。</p><ul><li>1.典型类型<br>Neo4J， InfoGrid</li><li>2.应用场景<br>社交网络 推荐系统专注于构建</li><li>3.数据模型<br>图结构</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-1-Nosql概念&quot;&gt;&lt;a href=&quot;#1-1-Nosql概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 Nosql概念&quot;&gt;&lt;/a&gt;1.1 Nosql概念&lt;/h3&gt;&lt;p&gt;nosql means not only sql&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="redis" scheme="http://example.com/categories/nosql/redis/"/>
    
    
  </entry>
  
</feed>
