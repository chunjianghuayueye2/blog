<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>春江花月夜o</title>
  
  <subtitle>既自以心为形役，奚惆怅而独悲。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-15T09:14:45.938Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>durian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>缓存问题</title>
    <link href="http://example.com/2021/06/15/redis%E9%AB%98%E7%BA%A7%E7%AF%87/%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/06/15/redis%E9%AB%98%E7%BA%A7%E7%AF%87/%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-15T08:57:18.147Z</published>
    <updated>2021-06-15T09:14:45.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h3><p>如果缓在某一个时刻出现大规模的key失效，那么就会导致大量的<br>请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况<br>下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，<br>马上又会有新的流量把数据库打死。这就是缓存雪崩。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>造成缓存雪崩的关键在于同一时间的大规模的key失效，为什么会出现这个<br>问题，主要有两种可能：第一种是Redis宕机，第二种可能就是采用了相同<br>的过期时间。搞清楚原因之后，那么有什么解决方案呢？</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>事前</p><ul><li>1.均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免<br>相同的过期时间导致缓存雪崩，造成大量数据库的访问。</li><li>2.分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失<br>效时间都不同。</li><li>3.热点数据缓存永远不过期。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">永不过期实际包含两层意思：</span><br><span class="line">物理不过期，针对热点key不设置过期时间</span><br><span class="line">逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，</span><br><span class="line">通过一个后台的异步线程进行缓存的构建</span><br></pre></td></tr></table></figure></li><li>4.保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。<br>可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。</li></ul></li><li><p>事中</p><ul><li><p>1.互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数<br>据写缓存的线程数量，比如某个key只允许一个线程查询数据和<br>写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统<br>的吞吐量会下降</p></li><li><p>2.使用熔断机制，限流降级。当流量达到一定的阈值，直接返回<br>“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，<br>至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到<br>结果。</p></li></ul></li><li><p>事后<br>  开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上<br>  自动加载数据恢复内存中的数据。</p></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h3><p>缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，<br>而缓存击穿是某个热点的key失效，大并发集中对其进行请求，<br>就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，<br>引起数据库压力剧增。这种现象就叫做缓存击穿。</p><h3 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h3><p>关键在于某个热点的key失效了，导致大并发集中打在数据库上。<br>所以要从两个方面解决，第一是否可以考虑热点key不设置过期时间，<br>第二是否可以考虑降低打在数据库上的请求数量。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>1.在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，<br>比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种<br>方式会阻塞其他的线程，此时系统的吞吐量会下降</li><li>2.热点数据缓存永远不过期。 <h2 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h2><h3 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h3>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，<br>同时在数据库中也不存在，导致用户每次请求该数据都要去<br>数据库中查询一遍。如果有恶意攻击者不断请求系统中不存<br>在的数据，会导致短时间大量请求落在数据库上，造成数据<br>库压力过大，甚至导致数据库承受不住而宕机崩溃。</li></ul><h3 id="问题分析-2"><a href="#问题分析-2" class="headerlink" title="问题分析"></a>问题分析</h3><p>缓存穿透的关键在于在Redis中查不到key值，它和缓存击穿<br>的根本区别在于传进来的key在Redis中是不存在的。假如有<br>黑客传进大量的不存在的key，那么大量的请求打在数据库上<br>是很致命的问题，所以在日常开发中要对参数做好校验，一些<br>非法的参数，不可能存在的key就直接返回错误提示。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li><p>1.将无效的key存放进Redis中：<br>当出现Redis查不到数据，数据库也查不到数据的情况，<br>我们就把这个key保存到Redis中，设置value=”null”，<br>并设置其过期时间极短，后面再出现查询这个key的请求的时候，<br>直接返回null，就不需要再查询数据库了。但这种处理方式是有<br>问题的，假如传进来的这个不存在的Key值每次都是随机的，那存<br>进Redis也没有意义。</p></li><li><p>2.使用布隆过滤器<br>如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不<br>存在，如果判定某个 key 存在，那么很大可能是存在(存在一定的误判率)。<br>于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存<br>储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在，如果<br>不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。</p></li></ul><h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><p>针对一些恶意攻击，攻击带过来的大量key是随机，那么我们采用第一种方案就<br>会缓存大量不存在key的数据。那么这种方案就不合适了，我们可以先对使用布<br>隆过滤器方案进行过滤掉这些key。所以，针对这种key异常多、请求重复率比较<br>低的数据，优先使用第二种方案直接过滤掉。而对于空数据的key有限的，重复率<br>比较高的，则可优先采用第一种方式进行缓存。</p><h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><h3 id="什么是缓存预热"><a href="#什么是缓存预热" class="headerlink" title="什么是缓存预热"></a>什么是缓存预热</h3><p>缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。<br>避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，<br>用户直接查询事先被预热的缓存数据。<br>如果不进行预热，那么Redis初始状态数据为空，系统上线初期，<br>对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。</p><h3 id="缓存预热解决方案"><a href="#缓存预热解决方案" class="headerlink" title="缓存预热解决方案"></a>缓存预热解决方案</h3><ul><li>1.数据量不大的时候，工程启动的时候进行加载缓存动作</li><li>2.数据量大的时候，设置一个定时任务脚本，进行缓存的刷新</li><li>3.数据量太大的时候，优先保证热点数据进行提前加载到缓存。</li></ul><h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><h3 id="什么是缓存降级"><a href="#什么是缓存降级" class="headerlink" title="什么是缓存降级"></a>什么是缓存降级</h3><p>缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，<br>直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所<br>以尽量减少降级对于业务的影响程度。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>在项目实战中通常会将部分热点数据缓存到服务的内存中，这样一旦缓存<br>出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。</p><ul><li>转载自<a href="https://blog.csdn.net/a745233700/article/details/88088669">Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;缓存雪崩&quot;&gt;&lt;a href=&quot;#缓存雪崩&quot; class=&quot;headerlink&quot; title=&quot;缓存雪崩&quot;&gt;&lt;/a&gt;缓存雪崩&lt;/h2&gt;&lt;h3 id=&quot;什么是缓存雪崩&quot;&gt;&lt;a href=&quot;#什么是缓存雪崩&quot; class=&quot;headerlink&quot; title=&quot;什么是</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="redis高级篇" scheme="http://example.com/categories/nosql/redis%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/06/15/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/dict%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/15/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/dict%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-15T08:52:31.827Z</published>
    <updated>2021-06-15T08:52:31.827Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/06/15/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/int%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/15/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/int%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-15T08:52:31.827Z</published>
    <updated>2021-06-15T08:52:56.003Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/06/15/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/tuple%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/15/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/tuple%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-15T08:52:31.827Z</published>
    <updated>2021-06-15T08:52:43.801Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/06/15/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/list%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/15/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/list%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-15T08:52:17.313Z</published>
    <updated>2021-06-15T08:52:04.124Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/06/15/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/str%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2021/06/15/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/str%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-15T08:52:04.124Z</published>
    <updated>2021-06-15T08:52:04.124Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>事务隔离级别</title>
    <link href="http://example.com/2021/06/15/mysql%E9%AB%98%E7%BA%A7%E7%AF%87/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://example.com/2021/06/15/mysql%E9%AB%98%E7%BA%A7%E7%AF%87/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2021-06-15T03:24:57.360Z</published>
    <updated>2021-06-15T03:45:50.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行<br>（如果单元中某个sql执行失败，整个单元将会回滚）<br>转账：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update table set余额&#x3D;500 where name&#x3D;’张三丰’</span><br><span class="line">update table set余额&#x3D;1500 where name&#x3D;’郭襄’</span><br></pre></td></tr></table></figure><p>如果单独执行，数据库出现意外挂掉只执行了一个就会很尴尬</p><h2 id="mysql的存储引擎"><a href="#mysql的存储引擎" class="headerlink" title="mysql的存储引擎"></a>mysql的存储引擎</h2><p>在mysql中的数据用各种不同的技术存储在文件（内存）中。<br>通过show engines查看所有mysql支持的引擎<br>主流 innoDB、MEMORY、MylSAM<br><strong>只有innoDB支持事务</strong></p><h2 id="事务的ACID-acid-属性"><a href="#事务的ACID-acid-属性" class="headerlink" title="事务的ACID(acid)属性"></a>事务的ACID(acid)属性</h2><ul><li><p>1.原子性（atomicity）<br>不可在分割的工作单位</p></li><li><p>2.一致性（Consistency）<br>就是这边变了那边也变了，一致的变化</p></li><li><p>3.隔离性（isolation）<br>事务的隔离性是指事务的执行不受其他事务干扰。<br>并发互不干扰（但很多时候是达不到隔离性的，要用隔离级别控制）</p></li><li><p>4.持久性（Durability）<br>一个事务一旦被提交，它对数据库中数据的改变就是永久性的，<br>接下来的其他操作和数据库故障不应该对其有影响。不能撤销</p></li></ul><h2 id="事务的创建"><a href="#事务的创建" class="headerlink" title="事务的创建"></a>事务的创建</h2><ul><li><p>隐式事务：事务没有明显的开启和结束的标记<br>比如insert、update、delete</p></li><li><p>显示事务：事务具有明显的开启结束标记<br>前提必须设置自动提交功能禁用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit &#x3D; 0;(只针对当前事务有效)</span><br></pre></td></tr></table></figure></li><li><p>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.set autocommit&#x3D;0;</span><br><span class="line">2.start transaction;可选的 不选也开启了</span><br><span class="line">3.编写事务中的sql（select insert update delete）</span><br><span class="line">如：</span><br><span class="line">1.update table set余额&#x3D;500 where name&#x3D;’张三丰’</span><br><span class="line">2.update table set余额&#x3D;1500 where name&#x3D;’郭襄’</span><br></pre></td></tr></table></figure></li><li><p>结束事务</p><ul><li>1.commit提交事务</li><li>2.rollback回滚事务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set autocommit &#x3D; 0;</span><br><span class="line">start transaction;</span><br><span class="line">update table set余额&#x3D;500 where name&#x3D;’张三丰’;</span><br><span class="line">update table set余额&#x3D;1500 where name&#x3D;’郭襄’;</span><br><span class="line">commit;提交到磁盘文件</span><br><span class="line">rollback;撤销</span><br><span class="line">savepoint 节点名，设置保存点</span><br><span class="line">（回滚点）</span><br><span class="line"></span><br><span class="line">delete可以回滚</span><br><span class="line">set autocommit &#x3D; 0;</span><br><span class="line">start transaction;</span><br><span class="line">delete from account where id&#x3D;25;</span><br><span class="line">savepoint a;</span><br><span class="line">delete from account where id&#x3D;28;</span><br><span class="line">rollback to a;回滚到保存点</span><br></pre></td></tr></table></figure>truncate无法回滚</li></ul></li></ul><h2 id="事务的隔离机制与并发性处理"><a href="#事务的隔离机制与并发性处理" class="headerlink" title="事务的隔离机制与并发性处理"></a>事务的隔离机制与并发性处理</h2><p>有时候同时运行多个事务，当这些事务访问数据库中相同数据时，<br>如果没有采取有效隔离机制，就会产生下面这些问题</p><ul><li>1.脏读：T1读取了T2更新还没提交的数据，若T2回滚，T1读取的内容就是临时无效的。</li><li>2.不可重复读：对于两个事务T1,T2 T1读取了一个字段，然后T2更新了该字段之后，<br>T1再次读取同一字段值就不同了。</li><li>3.幻读：T1读取一行发现不存在，T2插入这行，T1插入这行发现不行。</li></ul><p>数据事务隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使他们不会相互影响，避免各种并发问题。</p><h3 id="oracle支持两种事务隔离级别"><a href="#oracle支持两种事务隔离级别" class="headerlink" title="oracle支持两种事务隔离级别"></a>oracle支持两种事务隔离级别</h3><ul><li>1.READ COMMITED</li><li>2.SERIALIZABLE<br>默认隔离级别：READ COMMITED<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select @@tx_isolation; 查看隔离级别</span><br><span class="line">select @@transaction_isolation; mysql8格式</span><br><span class="line">设置当前mysql连接的隔离级别：</span><br><span class="line">set session transaction isolation level read uncommitted</span><br><span class="line">设置数据库系统的全局的隔离级别：(重启)</span><br><span class="line">set global transaction isolation level read uncommitted</span><br></pre></td></tr></table></figure></li></ul><h3 id="MYSQL支持4种事务隔离级别："><a href="#MYSQL支持4种事务隔离级别：" class="headerlink" title="MYSQL支持4种事务隔离级别："></a>MYSQL支持4种事务隔离级别：</h3><ul><li>1.read-uncommitted 最低级别读未提交的数据</li><li>2.read-committed 读已经提交的数据 避免脏读</li><li>3.REPEATABLE-READ 默认 避免不可重复读</li><li>4.SERIALIZABLE 避免所有问题（幻读）锁表<br>串行化这边事务未完成前，别的事务会锁住。所以性能很差，只有特殊情况才用它。<br>当事务2提交了插入数据，事务1插入同样数据的时候产生。</li></ul><h4 id="关于幻读"><a href="#关于幻读" class="headerlink" title="关于幻读"></a>关于幻读</h4><p>此时事务级别为repeatable read id为主键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">开启两个session transaction</span><br><span class="line">t1.</span><br><span class="line">insert into table values(1, ‘afa’)</span><br><span class="line">commit</span><br><span class="line">t2.</span><br><span class="line">select * from bb;</span><br><span class="line">此时查询并没有id&#x3D;1的数据</span><br><span class="line">insert into table values(1, ‘werwr’)</span><br><span class="line">报错：duplicate</span><br><span class="line">即为幻读</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行&lt;br&gt;（如果单元中某个sql执行失败，整个单元将会回滚）&lt;b</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="mysql高级篇" scheme="http://example.com/categories/nosql/mysql%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title>数据备份</title>
    <link href="http://example.com/2021/06/15/mysql%E9%AB%98%E7%BA%A7%E7%AF%87/mysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
    <id>http://example.com/2021/06/15/mysql%E9%AB%98%E7%BA%A7%E7%AF%87/mysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/</id>
    <published>2021-06-15T02:43:48.496Z</published>
    <updated>2021-06-15T08:44:44.689Z</updated>
    
    <content type="html"><![CDATA[<p>对于现代网络来说，数据是无价的，需要好好维护，为了避免误删、误更等的发生，需要一个<br>数据备份的方案进行维护。</p><h2 id="备份方式"><a href="#备份方式" class="headerlink" title="备份方式"></a>备份方式</h2><p>mysql按照备份恢复方式分为逻辑备份和物理备份</p><ul><li>逻辑备份：是备份sql语句，在恢复的时候执行备份的sql语句实<br>现数据库数据的重现。</li><li>物理备份：就是备份数据文件了，比较形象点就是cp下数据文件，<br>但真正备份的时候自然不是的cp这么简单。</li></ul><p>mysql按照数据库的运行状态分为热备，冷备和温备</p><ul><li>热备：在数据库运行时，直接进行备份，对运行的数据库没有影响。</li><li>冷备：在数据库停止运行的时候进行备份，这种备份方式最为简单，只需要拷贝数据库物理文件即可。</li><li>温备：同样是在数据库运行的时候进行备份的，但对当前数据库的操作会产生影响。</li></ul><h2 id="备份方案"><a href="#备份方案" class="headerlink" title="备份方案"></a>备份方案</h2><ul><li>1.mysqldump + mysqlbinlog</li><li>2.xtrabackup</li><li>3.lvm2快照+mysqlbinlog</li></ul><h2 id="mysqldump-amp-mysqlbinlog（全量物理-amp-增量逻辑）"><a href="#mysqldump-amp-mysqlbinlog（全量物理-amp-增量逻辑）" class="headerlink" title="mysqldump&amp;mysqlbinlog（全量物理&amp;增量逻辑）"></a>mysqldump&amp;mysqlbinlog（全量物理&amp;增量逻辑）</h2><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.输出指定数据库的完整备份文件到指定路径</span><br><span class="line">mysqldump  -hhostname –uname –ppasswd database &gt; path.sql</span><br><span class="line"></span><br><span class="line">2.备份到远程数据库</span><br><span class="line">mysqldump  -hhostname –uname –ppasswd database | mysql –hhostname –ppasswd –C database</span><br><span class="line"></span><br><span class="line">3.还原备份文件到某个sql的某个数据库</span><br><span class="line">mysql  -hhostname -uuser -ppwd databasename &lt; &#x2F;path.sql</span><br><span class="line"></span><br><span class="line">4.还原压缩的备份文件到某个sql的某个数据库</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;b77dfd6d998b</span><br><span class="line"></span><br><span class="line">5.备份并压缩</span><br><span class="line">mysqldump –h –u –p database | gzip &gt; path</span><br><span class="line"></span><br><span class="line">6.备份多个数据库</span><br><span class="line">mysqldump –h –u –p --databases databases1 2 3 &gt; path.sql</span><br><span class="line"></span><br><span class="line">7.备份数据库某些表</span><br><span class="line">mysqldump –h –u –p databasename table1 2 3 &gt; path.sql</span><br><span class="line"></span><br><span class="line">8.仅备份数据结构</span><br><span class="line">mysqldump -no-data –h –u –p databasename table1 2 3 &gt; path.sql</span><br><span class="line"></span><br><span class="line">9.备份所有数据库</span><br><span class="line">mysqldump –all-databases &gt; path.sql</span><br></pre></td></tr></table></figure><h4 id="简单linux脚本备份"><a href="#简单linux脚本备份" class="headerlink" title="简单linux脚本备份"></a>简单linux脚本备份</h4><ul><li><p>1.脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">touch mysql_backup.sh</span><br><span class="line">vim mysql_backup.sh</span><br><span class="line"></span><br><span class="line"># this is a mysql database backup shell script</span><br><span class="line">hostname &#x3D; ’10.167.218.161’</span><br><span class="line">database &#x3D; ‘test’</span><br><span class="line">bppath &#x3D;’&#x2F;root&#x2F;mysql_backup’</span><br><span class="line">data &#x3D; $(date+%Y%m%d_%H%M%S)</span><br><span class="line">user&#x3D;&quot;xxxx&quot;</span><br><span class="line">password&#x3D;&quot;xxxxx&quot;</span><br><span class="line">mysqldump –h$hostname –u$user –p$password $database|gzip &gt; $bppath&#x2F;$database_$date_sql.gz</span><br></pre></td></tr></table></figure></li><li><p>2.定时任务<br>把它加入定时任务crontab</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.启动定时任务</span><br><span class="line">service crond start|status|stop</span><br><span class="line">systemctl start crond</span><br><span class="line"># 查看config文件，可以看到定时规则</span><br><span class="line">cat &#x2F;etc&#x2F;cron</span><br><span class="line"># 添加定时任务</span><br><span class="line">crontab –e</span><br><span class="line"># 添加定时计划</span><br><span class="line">0 2 * * * &#x2F;path&#x2F;mysql_backup.sh</span><br><span class="line"># 查看当前定时任务</span><br><span class="line">crontab –l</span><br><span class="line"># 查看定时计划日志</span><br><span class="line">tail –f &#x2F;var&#x2F;log&#x2F;cron</span><br></pre></td></tr></table></figure></li></ul><h3 id="mysqlbinlog"><a href="#mysqlbinlog" class="headerlink" title="mysqlbinlog"></a>mysqlbinlog</h3><p>进行增量备份，备份二进制日志，将最后操作的二进制日志备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line"># 查看最新的binlog</span><br><span class="line">mysqlbinlog binlog.000001</span><br><span class="line"># 导出最新的增量</span><br><span class="line">mysqlbinlog  --start-position&#x3D;639 --stop-position&#x3D;835  </span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;bin-log.000003 &gt; &#x2F;backup&#x2F;binlog-&#96;date +%F_%T&#96;.sql</span><br></pre></td></tr></table></figure><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>1.使用mysqldump全量复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">备份整个库</span><br><span class="line">mysqldump --all-databases --lock-all-tables --flush-log  </span><br><span class="line">--master-data&#x3D;2 &gt;&#x2F;backup&#x2F;&#96;date +%F_%T&#96; -all.sql</span><br><span class="line">备份某一个库</span><br><span class="line">mysqldump -uroot -p123456 --databases </span><br><span class="line">test --lock-all-tables --flush-log -hlocalhost  </span><br><span class="line">--master-data&#x3D;2 &gt;&#x2F;backup&#x2F;&#96;date +%F_%T&#96;-test.sql;</span><br><span class="line">ls &#x2F;backup&#x2F;进行查看</span><br></pre></td></tr></table></figure><p>2.使用mysqlbinlog增量复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">保护最后的二进制文件</span><br><span class="line">mysqlbinlog  --start-position&#x3D;639 --stop-position&#x3D;835  </span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;bin-log.000003 &gt; &#x2F;backup&#x2F;binlog-&#96;date +%F_%T&#96;.sql</span><br></pre></td></tr></table></figure><p>3.数据恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 首先恢复mysqldump全量复制的某个库</span><br><span class="line">mysql -uroot -pZhanghaowei1! &lt; xxxxx.sql</span><br><span class="line"># 再恢复从那时起的增量</span><br><span class="line">mysql -uroot -pZhanghaowei1! &lt; bin_log-xxxxx.sql</span><br><span class="line">mysql -uroot -pZhanghaowei1! &lt; bin_log-xxxxx.sql</span><br></pre></td></tr></table></figure><h2 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h2><p>Xtrabackup是由percona提供的mysql数据库备份工具，据官方介绍，是一款<br>开源能够对innodb和xtradb数据库进行热备的工具。</p><p>特点：</p><ul><li>1.备份过程快速、可靠</li><li>2.备份过程不会打断正在执行的事务</li><li>3.能够基于压缩等功能节约磁盘空间和流量</li><li>4.自动实现备份检验</li><li>5.还原速度快</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum installpercona-xtrabackup-2.2.3-4982.el6.x86_64.rpm -y</span><br><span class="line">创建最小权限备份用户 </span><br><span class="line">grant reload,lock tables,replicationclient on *.* to </span><br><span class="line">&#39;fulanqi&#39;@&#39;localhost&#39; identified by &#39;123&#39;;</span><br></pre></td></tr></table></figure><h3 id="完全备份"><a href="#完全备份" class="headerlink" title="完全备份"></a>完全备份</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --user&#x3D;fulanqi --password&#x3D;123 &#x2F;backup&#x2F;</span><br></pre></td></tr></table></figure><h3 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --user&#x3D;fulanqi --password&#x3D;123 --incremental </span><br><span class="line">&#x2F;backup&#x2F;--incremental-basedir&#x3D;&#x2F;backup&#x2F;binlog-&#96;date +%F_%T&#96;.sql</span><br></pre></td></tr></table></figure><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><ul><li><p>数据准备<br>一般情况下，在备份完成后，数据尚且不能用于恢复操作，因为备份的数据中<br>可能会包含尚未提交的事务或已经提交但尚未同步至数据文件中的事务。因此<br>，此时数据文件仍处理不一致状态。“准备”的主要作用正是通过回滚未提交<br>的事务及同步已经提交的事务至数据文件也使得数据文件处于一致性状态</p></li><li><p>准备(prepare)增量备份与整理完全备份有着一些不同，尤其要注意的是：</p><ul><li>1.需要在每个备份(包括完全和各个增量备份)上，将已经提交的事务进行“<br>重放”。“重放”之后，所有的备份数据将合并到完全备份上。</li><li>2.基于所有的备份将未提交的事务进行“回滚”。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">全量</span><br><span class="line">innobackupex --apply-log --redo-only 全量路径</span><br><span class="line">增量</span><br><span class="line"># innobackupex --apply-log --redo-only BASE-DIR--incrementaldir&#x3D;增量路径</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据恢复<br>这时候所有备份数据都在全量路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innobackupex --copy-back 全量路径</span><br></pre></td></tr></table></figure></li></ul><h3 id="python-amp-xtrabackup"><a href="#python-amp-xtrabackup" class="headerlink" title="python&amp;xtrabackup"></a>python&amp;xtrabackup</h3><p>采用每周一0点进行一次全备，每日0点进行增备，一星期为一个周期。<br>如要恢复到某个时间点的数据，只需要找到还原到时间点当天的增量备份，然后再结合binlog日志进行恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#39;utf8&#39;)</span><br><span class="line">import commands</span><br><span class="line">import base64</span><br><span class="line">import datetime</span><br><span class="line">import os</span><br><span class="line">#------------自定义变量----------- </span><br><span class="line">#备份数据库账号  bkUser&#x3D;&#39;bkuser&#39;      </span><br><span class="line">#备份数据库账户的密码,需要base64加密  bkPasswd&#x3D;&#39;passwd&#39;    </span><br><span class="line">#备份目录  bkDir&#x3D;&#39;&#x2F;data&#x2F;backup&#39;     </span><br><span class="line">#备份文件传给异地服务器的系统账号 tarUser&#x3D;&#39;user&#39;   </span><br><span class="line">#异地服务器 tarHost&#x3D;&#39;ip&#39;     </span><br><span class="line">#异地服务器的备份路径 ip tarBkDir&#x3D;&#39;&#39;          </span><br><span class="line"></span><br><span class="line">#--------------------------------- </span><br><span class="line">oneday&#x3D;datetime.timedelta(days&#x3D;1)</span><br><span class="line">twoday&#x3D;datetime.timedelta(days&#x3D;2)</span><br><span class="line">today&#x3D;datetime.date.today()</span><br><span class="line">formattedYesterday&#x3D;(today-oneday).strftime(&#39;%Y%m%d&#39;)</span><br><span class="line">formattedBeforeYesterday&#x3D;(today-twoday).strftime(&#39;%Y%m%d&#39;)</span><br><span class="line">week&#x3D;datetime.datetime.now().weekday()</span><br><span class="line">nowTime&#x3D;str(datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;))</span><br><span class="line"></span><br><span class="line">def installXtrabackup():</span><br><span class="line">    commands.getstatusoutput(&#39;mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup&#39;)</span><br><span class="line">    commands.getstatusoutput(&#39;mv &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo.backup&#39;)</span><br><span class="line">    commands.getstatusoutput(&#39;wget -O&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-6.repo&#39;)</span><br><span class="line">    commands.getstatusoutput(&#39;wget -O&#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-6.repo&#39;)</span><br><span class="line">    commands.getstatusoutput(&#39;yum install -y http:&#x2F;&#x2F;www.percona.com&#x2F;downloads&#x2F;percona-release&#x2F;redhat&#x2F;0.1-6&#x2F;percona-release-0.1-6.noarch.rpm&#39;)</span><br><span class="line">    commands.getstatusoutput(&#39;yum install -y percona-xtrabackup-24&#39;)</span><br><span class="line"></span><br><span class="line">def copyFull():</span><br><span class="line">    print(&#39;---全备开始时间---:&#39;+nowTime)</span><br><span class="line">    fileName&#x3D;&#39;full_&#39;+ formattedYesterday</span><br><span class="line">    bkFulCmd&#x3D;&#39;innobackupex --no-timestamp &#x2F;data&#x2F;backup&#x2F;%s -u%s -p%s&#39;%(fileName,bkUser,base64.decodestring(bkPasswd))</span><br><span class="line">    commands.getstatusoutput(bkFulCmd)</span><br><span class="line">    print(&#39;---全备结束时间---:&#39;+nowTime)</span><br><span class="line">    return fileName</span><br><span class="line"></span><br><span class="line">def copyIncrement(file):</span><br><span class="line">    print(&#39;---增备开始时间---:&#39;+nowTime)</span><br><span class="line">    fileName&#x3D;&#39;rec_&#39; + formattedYesterday</span><br><span class="line">    bkRecCmd&#x3D;&#39;innobackupex --no-timestamp --incremental &#x2F;data&#x2F;backup&#x2F;%s --incremental-basedir&#x3D;&#x2F;data&#x2F;backup&#x2F;%s -u%s -p%s&#39;%(fileName,file,bkUser,base64.decodestring(bkPasswd))</span><br><span class="line">    commands.getstatusoutput(bkRecCmd)</span><br><span class="line">    print(&#39;---增备结束时间---:&#39;+nowTime)</span><br><span class="line">    return fileName</span><br><span class="line"></span><br><span class="line">def packBackup():</span><br><span class="line">    print(&#39;---打包开始时间---:&#39;+nowTime)</span><br><span class="line">    os.chdir(bkDir)</span><br><span class="line">    os.chdir(&#39;..&#39;)</span><br><span class="line">    tarCmd&#x3D;&#39;tar -cvf backup_%s.tar backup&#x2F;&#39;%(formattedYesterday)</span><br><span class="line">    commands.getstatusoutput(tarCmd)</span><br><span class="line">    commands.getstatusoutput(&#39;rm -rf &#x2F;data&#x2F;backup&#39;)</span><br><span class="line">    print(&#39;---打包结束时间---:&#39;+nowTime)</span><br><span class="line"></span><br><span class="line">def isCopyFulRec():</span><br><span class="line">    if os.path.exists(bkDir) &#x3D;&#x3D; 0:</span><br><span class="line">       copyFull()</span><br><span class="line">    else:</span><br><span class="line">       dirlist &#x3D; os.listdir(bkDir)</span><br><span class="line">       if dirlist:</span><br><span class="line">           print(dirlist)</span><br><span class="line">           tagFul &#x3D; &#39;full&#39;</span><br><span class="line">           tagRec &#x3D; &#39;rec&#39;</span><br><span class="line">           fileName &#x3D; []</span><br><span class="line">           for i in dirlist:</span><br><span class="line">              if tagFul in i:</span><br><span class="line">                 fileName.append(1)</span><br><span class="line">              elif tagRec in i:</span><br><span class="line">                 fileName.append(2)</span><br><span class="line">              else:</span><br><span class="line">                 fileName.append(0)</span><br><span class="line">                 </span><br><span class="line">           if 2 in fileName:</span><br><span class="line">               copyIncrement(&#39;rec_&#39;+formattedBeforeYesterday)</span><br><span class="line">           elif 1 in fileName:</span><br><span class="line">               copyIncrement(&#39;full_&#39;+ formattedBeforeYesterday)</span><br><span class="line">           else:</span><br><span class="line">               copyFull()</span><br><span class="line">       else:</span><br><span class="line">           copyFull()</span><br><span class="line"></span><br><span class="line">def scpTarget():</span><br><span class="line">    print(&#39;---传包开始时间---:&#39;+nowTime)</span><br><span class="line">    os.chdir(bkDir)</span><br><span class="line">    os.chdir(&#39;..&#39;)</span><br><span class="line">    tarName&#x3D;&#39;backup_%s.tar&#39;%formattedYesterday</span><br><span class="line">    scpCmd&#x3D;&#39;scp %s %s@%s&#39;%(tarName,tarUser,tarHost)</span><br><span class="line">    commands.getstatusoutput(scpCmd)</span><br><span class="line">    rmCmd&#x3D;&#39;rm -rf %s&#39;%tarName</span><br><span class="line">    commands.getstatusoutput(rmCmd)</span><br><span class="line">    print(&#39;---传包结束时间---:&#39;+nowTime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    installXtrabackup()     </span><br><span class="line">    if week&#x3D;&#x3D;0:</span><br><span class="line">        copyFull()</span><br><span class="line">        packBackup() #打包                 </span><br><span class="line">        # 传到备份服务器 </span><br><span class="line">        scpTarget() </span><br><span class="line">    else:</span><br><span class="line">        isCopyFulRec()</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/Ketchup_/article/details/78945202">mysql三种备份方案</a><br><a href="http://www.cslingjun.com/2019/05/08/Mysql%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/">MySQL常用备份方案</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于现代网络来说，数据是无价的，需要好好维护，为了避免误删、误更等的发生，需要一个&lt;br&gt;数据备份的方案进行维护。&lt;/p&gt;
&lt;h2 id=&quot;备份方式&quot;&gt;&lt;a href=&quot;#备份方式&quot; class=&quot;headerlink&quot; title=&quot;备份方式&quot;&gt;&lt;/a&gt;备份方式&lt;/h2&gt;</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="mysql高级篇" scheme="http://example.com/categories/nosql/mysql%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title>zookeeper安装配置</title>
    <link href="http://example.com/2021/06/15/zookeeper/zookeeper%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2021/06/15/zookeeper/zookeeper%E5%AE%89%E8%A3%85/</id>
    <published>2021-06-15T01:28:37.716Z</published>
    <updated>2021-06-12T02:09:39.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本地模式安装部署"><a href="#本地模式安装部署" class="headerlink" title="本地模式安装部署"></a>本地模式安装部署</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zookeeper官网下载</span><br><span class="line">tar –zxvf table 解压</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>1.将zookeeper/conf/zoo_sample.conf修改为zoo.cfg<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv zoo_sample.conf zoo.cfg</span><br></pre></td></tr></table></figure></li><li>2.vim zoo.cfg<br>修改dataDir为你想要保存数据的路径（记得先在路径下创建该文件夹）</li><li>3.bin/zkServer.sh start启动</li><li>4.jps查看状态bin/zkServer.sh status</li><li>5.进入客户端bin/zkCli.sh(推出quit)<br>ls + path</li><li>6.关闭服务bin/zkServer.sh stop</li></ul><h2 id="配置参数解读"><a href="#配置参数解读" class="headerlink" title="配置参数解读"></a>配置参数解读</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tickTime&#x3D;2000 心跳 单位ms</span><br><span class="line">initLimit&#x3D;10 10个心跳帧*心跳 是leader和slave的初始通讯延时时间</span><br><span class="line">如果超过这个时间，默认通讯失败。(启动花时间所以长一些)</span><br><span class="line">syncLimit&#x3D;5 5个心跳帧集群正常启动之后，leader和slave通讯的时间。</span><br><span class="line">clientPort&#x3D;2181客户端访问端口号</span><br><span class="line">dataDir数据存储位置</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本地模式安装部署&quot;&gt;&lt;a href=&quot;#本地模式安装部署&quot; class=&quot;headerlink&quot; title=&quot;本地模式安装部署&quot;&gt;&lt;/a&gt;本地模式安装部署&lt;/h2&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="bigdata" scheme="http://example.com/categories/bigdata/"/>
    
    <category term="zookeeper" scheme="http://example.com/categories/bigdata/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>zookeeper选举机制和节点类型</title>
    <link href="http://example.com/2021/06/15/zookeeper/zookeeper%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/06/15/zookeeper/zookeeper%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/</id>
    <published>2021-06-15T01:28:37.716Z</published>
    <updated>2021-06-12T02:09:48.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选举机制-重要"><a href="#选举机制-重要" class="headerlink" title="选举机制 ***重要"></a>选举机制 ***重要</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>1.半数机制，集群中半数以上（一半就不能存活了）的机器存活，集群可用。<br>（高可用）所以zookeeper适合安装奇数台服务器。</li><li>2.zookeeper虽然在配置文件中没有master和slave，但在工作时，是有一个<br>节点为leader，其他则为follower。而leader则是通过内部选举临时产生。</li><li>3.如何选举出leader？<br>如何选举leader（简单的选举机制）每个服务器启动先选自己，发现不行，就投<br>给已经启动的id号大的服务器，当获得票数大于服务器数量的一半，即刻当选</li></ul><h2 id="节点的类型"><a href="#节点的类型" class="headerlink" title="节点的类型"></a>节点的类型</h2><h3 id="持久型-persistent"><a href="#持久型-persistent" class="headerlink" title="持久型 persistent"></a>持久型 persistent</h3><ul><li>1.客户端和服务器断开连接后创建的节点不删除，会带一个persistent的标识</li><li>2.创建znode时设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器由父节点维护。</li><li>3.在分布式系统中顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序。</li></ul><h3 id="短暂型-ephemeral-临时目录节点"><a href="#短暂型-ephemeral-临时目录节点" class="headerlink" title="短暂型 ephemeral 临时目录节点"></a>短暂型 ephemeral 临时目录节点</h3><p>客户端和服务器断开连接后创建的节点自动删除</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;选举机制-重要&quot;&gt;&lt;a href=&quot;#选举机制-重要&quot; class=&quot;headerlink&quot; title=&quot;选举机制 ***重要&quot;&gt;&lt;/a&gt;选举机制 ***重要&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="bigdata" scheme="http://example.com/categories/bigdata/"/>
    
    <category term="zookeeper" scheme="http://example.com/categories/bigdata/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>zookeeper基本操作</title>
    <link href="http://example.com/2021/06/15/zookeeper/zookeeper%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2021/06/15/zookeeper/zookeeper%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</id>
    <published>2021-06-15T01:28:37.715Z</published>
    <updated>2021-06-12T02:09:42.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zookeeper操作命令"><a href="#zookeeper操作命令" class="headerlink" title="zookeeper操作命令"></a>zookeeper操作命令</h2><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.help查看命令</span><br><span class="line">2.ls &#x2F;查看某个节点内容</span><br><span class="line">3.ls -s &#x2F;查看某个节点详细数据</span><br><span class="line">4.create &#x2F;sanguo + 内容</span><br><span class="line"></span><br><span class="line">创建短暂节点 临时节点 带序号的节点</span><br><span class="line">1.不带序号的临时节点</span><br><span class="line">create –e &#x2F;sanguo&#x2F;wuguo “zhouyu”</span><br><span class="line">ls &#x2F;sanguo</span><br><span class="line">quit退出再进来</span><br><span class="line">ls &#x2F;sanguo 短暂节点客户端退出删除</span><br><span class="line">2.带序号的节点</span><br><span class="line">create -s &#x2F;sanguo&#x2F;weiguo &quot;caocao&quot;</span><br><span class="line">ls &#x2F;sanguo</span><br><span class="line">&#x2F;sanguo&#x2F;weiguo0000000002</span><br></pre></td></tr></table></figure><h3 id="监听节点"><a href="#监听节点" class="headerlink" title="监听节点"></a>监听节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">get –w +node获取值</span><br><span class="line">监听一次有效一次。。。。。</span><br><span class="line">ls –w +node</span><br><span class="line">监听子节点</span><br><span class="line">delete + node删除节点</span><br><span class="line">deleteall + node删除所有节点</span><br></pre></td></tr></table></figure><h2 id="Stat-结构体"><a href="#Stat-结构体" class="headerlink" title="Stat 结构体"></a>Stat 结构体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cZxid &#x3D; 0x20创建节点的事务id</span><br><span class="line">ctime &#x3D; Wed Oct 21 17:20:01 CST 2020 创建节点时间</span><br><span class="line">mZxid &#x3D; 0x20最后更新的事务id</span><br><span class="line">mtime &#x3D; Wed Oct 21 17:20:01 CST 2020最后更新的时间</span><br><span class="line">pZxid &#x3D; 0x20最后更新的子节点的id</span><br><span class="line">cversion &#x3D; 0znode子节点变化版本号</span><br><span class="line">dataVersion &#x3D; 0znode数据变化号</span><br><span class="line">aclVersion &#x3D; 0 访问控制列表的变化号</span><br><span class="line">ephemeralOwner &#x3D; 0x0是临时节点，sessionId否则0</span><br><span class="line">dataLength &#x3D; 0znode数据长度</span><br><span class="line">numChildren &#x3D; 0子节点数量</span><br></pre></td></tr></table></figure><h2 id="监听的原理-重"><a href="#监听的原理-重" class="headerlink" title="监听的原理 ***重"></a>监听的原理 ***重</h2><ul><li>1.首先要有一个main线程</li><li>2.在main线程中创建zookeeper客户端，这时候创建两个线程，一个负责网络连接通讯connect，一个负责监听listener。</li><li>3.通过connect线程将注册的监听事件发送给zookeeper</li><li>4.在zookeeper的注册监听器列表中将注册的监听事件添加到列表中。</li><li>5.zookeeper监听到有数据或路径的变化，就会将这个消息发送给listener线程</li><li>6.listener线程内部调用了process()方法。</li></ul><p>常见监听：<br>节点数据的变化<br>子节点增减的变化</p><h2 id="写数据的流程"><a href="#写数据的流程" class="headerlink" title="写数据的流程"></a>写数据的流程</h2><p>client客户端向zookeeper服务器发送一个写的请求。<br>如果server1不是leader，会把请求转给leader。leader会把写请求广播给各个server。各个server写完通知leader。<br>当leader收到大多数server数据写成功了，那么数据就写成功了。leader这个时候会告诉server1数据写成功。server<br>在通知客户端。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;zookeeper操作命令&quot;&gt;&lt;a href=&quot;#zookeeper操作命令&quot; class=&quot;headerlink&quot; title=&quot;zookeeper操作命令&quot;&gt;&lt;/a&gt;zookeeper操作命令&lt;/h2&gt;&lt;h3 id=&quot;基础命令&quot;&gt;&lt;a href=&quot;#基础命令&quot;</summary>
      
    
    
    
    <category term="bigdata" scheme="http://example.com/categories/bigdata/"/>
    
    <category term="zookeeper" scheme="http://example.com/categories/bigdata/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>zookeeper简介</title>
    <link href="http://example.com/2021/06/15/zookeeper/zookeeper%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2021/06/15/zookeeper/zookeeper%E5%85%A5%E9%97%A8/</id>
    <published>2021-06-15T01:28:37.714Z</published>
    <updated>2021-06-12T02:09:46.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ZooKeeper服务器是用Java创建的，它在JVM上运行。你需要使用JDK 6或更高版本。<br>zookeeper是开源的分布式的，为分布式应用提供协调服务的Apache项目。<br>（管理整个大数据生态中的很多框架，hadoop，kafka，hbase，tire等）</p><h2 id="zookeeper的工作机制"><a href="#zookeeper的工作机制" class="headerlink" title="zookeeper的工作机制"></a>zookeeper的工作机制</h2><p>从设计模式角度理解，它是一个基于观察者模式设计的分布式服务管理框架。（23种设计模式）<br>它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据状态发生变化，<br>zookeeper就将负责通知已经在zookeeper上注册的那些观察者做出相应的反应。<br>文件系统+通知机制</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>1.zookeeper:一个领导者（Leader），多个跟随者（Follower）组成的集群。</li><li>2.集群中只要有半数以上节点存活，Zookeeper就能正常服务。（和redis很像）</li><li>3.全局数据一致：每个server保存一份相同的数据副本，client无论连接到哪个server，数据都是一致的。</li><li>4.更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行。</li><li>5.数据更新原子性，事务。</li><li>6.实时性，在一定时间范围内，client能读到最新数据。（同步副本的时间会很短，因为本来存储的就是一些配置信息）</li></ul><h2 id="zookeeper的数据结构"><a href="#zookeeper的数据结构" class="headerlink" title="zookeeper的数据结构"></a>zookeeper的数据结构</h2><p>zookeeper的数据结构与unix类似。整体结构可以看做是一颗树，每个节点称做一个znode。<br>每一个znode默认能够存储1M的数据，每个数据都可以通过其路径唯一标识。</p><h2 id="zookeeper的应用场景"><a href="#zookeeper的应用场景" class="headerlink" title="zookeeper的应用场景"></a>zookeeper的应用场景</h2><h3 id="统一命名服务"><a href="#统一命名服务" class="headerlink" title="统一命名服务"></a>统一命名服务</h3><p>例如：IP不容易记住，而域名容易记住。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zookeeper service</span><br><span class="line">&#x2F;</span><br><span class="line">&#x2F;service</span><br><span class="line">www.baidu.com</span><br><span class="line">10.167.219.250</span><br><span class="line">10.167.219.237</span><br><span class="line">10.167.219.249</span><br></pre></td></tr></table></figure><p>当客户端（client）访问<a href="http://www.baidu.com时,zookeeper帮助控制客户端连接访问哪一台服务器./">www.baidu.com时，zookeeper帮助控制客户端连接访问哪一台服务器。</a></p><h3 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h3><p>在分布式下配置文件同步非常重要。<br>比如kafka、hadoop。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.一般要求一个集群中，所有节点的配置信息是一致的，比如kafka集群。</span><br><span class="line">（1000台服务器，只需要配置zookeeper就可以同步到所有的服务器）</span><br><span class="line">2.对配置文件修改后，希望能够快速同步到各个集群服务器。</span><br><span class="line">zookeeper配置同步信息：</span><br><span class="line">    1.将配置信息写入zookeeper的一个znode。</span><br><span class="line">    2.各个客户端服务器监听这个znode。</span><br><span class="line">    3.只要配置信息变化了，就把配置信息拿过来同步。</span><br></pre></td></tr></table></figure><h3 id="统一集群管理"><a href="#统一集群管理" class="headerlink" title="统一集群管理"></a>统一集群管理</h3><p>分布式环境中，实时掌握每个节点的状态是必要的。</p><ul><li><p>1.可根据节点实时状态做出一些调整。</p></li><li><p>2.zookeeper可以实时监控节点的状态变化。</p><ul><li>1.可以将节点信息写入zookeeper上的一个znode</li><li>2.监听这个znode可获取它的实时状态变化</li></ul></li><li><p>3.服务器节点动态上下线<br>服务器上下线自动调节。</p></li><li><p>4.软负载均衡<br>在zookeeper中监听记录每个服务器的访问数，让访问数最少的服务器取处理最新的客户端请求。<br>（加权分配）</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;ZooKeeper服务器是用Java创建的，它在JVM上运行。你需要使用JDK 6或更高版本。&lt;br&gt;zookeeper是开源的分布式的，为</summary>
      
    
    
    
    <category term="bigdata" scheme="http://example.com/categories/bigdata/"/>
    
    <category term="zookeeper" scheme="http://example.com/categories/bigdata/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>python实操</title>
    <link href="http://example.com/2021/06/15/zookeeper/python%E5%AE%9E%E6%88%98/"/>
    <id>http://example.com/2021/06/15/zookeeper/python%E5%AE%9E%E6%88%98/</id>
    <published>2021-06-15T01:28:37.713Z</published>
    <updated>2021-06-12T02:09:36.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>pip isntall kazoo<br>服务器搭建zookeeper集群<br><a href="https://juejin.im/post/6844904052124303368#heading-7">python实操zookeeper1</a><br><a href="https://zhuanlan.zhihu.com/p/34177172">python实操zookeeper2</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">from kazoo.client import KazooClient, KazooState</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    level&#x3D;logging.DEBUG,</span><br><span class="line">    stream&#x3D;sys.stdout,</span><br><span class="line">    format&#x3D;&#39;%(asctime)s %(pathname)s %(funcName)s%(lineno)d %(levelname)s: %(message)s&#39;)</span><br><span class="line"></span><br><span class="line">zk &#x3D; KazooClient(</span><br><span class="line">    hosts&#x3D;&#39;10.167.218.158:2181&#39;,</span><br><span class="line">    timeout&#x3D;10.0,</span><br><span class="line">    logger&#x3D;logging</span><br><span class="line">)</span><br><span class="line"># 开始心跳</span><br><span class="line">zk.start()</span><br><span class="line"></span><br><span class="line"># 获取根节点数据和状态</span><br><span class="line">data, stat &#x3D; zk.get(&#39;&#x2F;&#39;)</span><br><span class="line">print(&quot;data:&quot;, data)</span><br><span class="line">print(&quot;stat:&quot;, stat)</span><br><span class="line"></span><br><span class="line"># 获取子节点</span><br><span class="line">children &#x3D; zk.get_children(&quot;&#x2F;&quot;)</span><br><span class="line">print(children)</span><br><span class="line"></span><br><span class="line"># 创建子节点</span><br><span class="line"># zk.create(&#39;&#x2F;sanguo&#x2F;shuguo&#39;, b&#39;caoChao&#39;, ephemeral&#x3D;False)</span><br><span class="line">if not zk.exists(&#39;&#x2F;sanguo&#x2F;weiguo&#39;):</span><br><span class="line">    zk.create(&#39;&#x2F;sanguo&#x2F;weiguo&#39;, b&#39;caoChao&#39;, ephemeral&#x3D;False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">children &#x3D; zk.get_children(&quot;&#x2F;sanguo&quot;)</span><br><span class="line">print(children)</span><br><span class="line">data, stat &#x3D; zk.get(&#39;&#x2F;sanguo&#x2F;weiguo&#39;)</span><br><span class="line">print(&quot;data:&quot;, data)</span><br><span class="line">print(&quot;stat:&quot;, stat)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def monitor(event):</span><br><span class="line">    print(type(event))</span><br><span class="line">    print(event)</span><br><span class="line">    print(zk.get_children(&#39;&#x2F;sanguo&#39;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">children &#x3D; zk.get_children(&#39;&#x2F;sanguo&#39;, watch&#x3D;monitor)</span><br><span class="line">print(children)</span><br><span class="line"></span><br><span class="line">node &#x3D; zk.create(&#39;&#x2F;b&#39;)</span><br><span class="line">print(node, &#39;aaaaaaaaaaaaaaaaaaaaa&#39;)</span><br><span class="line">print(zk.exists(&#39;&#x2F;sanguo&#39;), &#39;fafafafafaa&#39;)</span><br></pre></td></tr></table></figure><h2 id="zookeeper实现分布式锁"><a href="#zookeeper实现分布式锁" class="headerlink" title="zookeeper实现分布式锁"></a>zookeeper实现分布式锁</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import sys</span><br><span class="line">from kazoo.client import KazooClient</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">class ZkLock:</span><br><span class="line">    def __init__(self, root&#x3D;&#39;&#x2F;Lock&#39;, node&#x3D;None):</span><br><span class="line">        self.lock &#x3D; False</span><br><span class="line">        self.root &#x3D; root</span><br><span class="line">        self.node &#x3D; node</span><br><span class="line">        logging.basicConfig(</span><br><span class="line">            level&#x3D;logging.DEBUG,</span><br><span class="line">            stream&#x3D;sys.stdout,</span><br><span class="line">            format&#x3D;&#39;%(asctime)s %(pathname)s %(funcName)s%(lineno)d %(levelname)s: %(message)s&#39;)</span><br><span class="line">        self.zk &#x3D; KazooClient(</span><br><span class="line">            hosts&#x3D;&#39;10.167.218.158:2181&#39;,</span><br><span class="line">            timeout&#x3D;10.0,</span><br><span class="line">            logger&#x3D;logging</span><br><span class="line">        )</span><br><span class="line">        self.zk.start()</span><br><span class="line"></span><br><span class="line">    def acquire(self):</span><br><span class="line">        if not self.zk.exists(self.root):</span><br><span class="line">            self.zk.create(self.root)</span><br><span class="line">        if not self.node:</span><br><span class="line">            self.node &#x3D; self.zk.create(self.root+&#39;&#x2F;lock&#39;, ephemeral&#x3D;True, sequence&#x3D;True)</span><br><span class="line">        nodes &#x3D; self.zk.get_children(self.root)</span><br><span class="line">        if nodes[0] &#x3D;&#x3D; self.node:</span><br><span class="line">            print(&#39;Acquire lock successfully&#39;)</span><br><span class="line">            self.lock &#x3D; True</span><br><span class="line">        else:</span><br><span class="line">            print(&#39;Acquire lock failed start watching&#39;)</span><br><span class="line"></span><br><span class="line">            @self.zk.ChildrenWatch(self.root)</span><br><span class="line">            def watch_func(data):</span><br><span class="line">                print(&quot;Data is %s and node is %s and root.is %s&quot; % (data, self.node, self.root))</span><br><span class="line">                print(self.node, self.root + &#39;&#x2F;&#39; + data[-1], self.node &#x3D;&#x3D; self.root + &#39;&#x2F;&#39; + data[-1])</span><br><span class="line">                if self.node &#x3D;&#x3D; self.root + &#39;&#x2F;&#39; + data[-1]:</span><br><span class="line">                    self.lock &#x3D; True</span><br><span class="line"></span><br><span class="line">    def release(self):</span><br><span class="line">        self.zk.stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    t &#x3D; ZkLock()</span><br><span class="line">    while not t.lock:</span><br><span class="line">        t.acquire()</span><br><span class="line">    print(&#39;执行获取锁后的操作&#39;)</span><br><span class="line">    time.sleep(10)</span><br><span class="line">    print(&#39;执行操作结束释放锁&#39;)</span><br><span class="line">    t.release()</span><br></pre></td></tr></table></figure><ul><li>优点:ZK可以不需要关心锁超时时间，实现起来有现成的第三方包，比较方便，并且支持读写锁，<br>ZK获取锁会按照加锁的顺序，所以其是公平锁。对于高可用利用ZK集群进行保证。 </li><li>缺点:ZK需要额外维护，增加维护成本，性能和Mysql相差不大，依然比较差。并且需要开发人员了解ZK是什么。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础命令&quot;&gt;&lt;a href=&quot;#基础命令&quot; class=&quot;headerlink&quot; title=&quot;基础命令&quot;&gt;&lt;/a&gt;基础命令&lt;/h2&gt;&lt;p&gt;pip isntall kazoo&lt;br&gt;服务器搭建zookeeper集群&lt;br&gt;&lt;a href=&quot;https://juej</summary>
      
    
    
    
    <category term="bigdata" scheme="http://example.com/categories/bigdata/"/>
    
    <category term="zookeeper" scheme="http://example.com/categories/bigdata/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>第三方登录</title>
    <link href="http://example.com/2021/06/15/webframe/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"/>
    <id>http://example.com/2021/06/15/webframe/%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</id>
    <published>2021-06-15T01:28:37.712Z</published>
    <updated>2021-06-12T02:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大致流程（以github为例）"><a href="#大致流程（以github为例）" class="headerlink" title="大致流程（以github为例）"></a><a href="https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps">大致流程</a>（以github为例）</h2><ul><li><p>1.打开github-&gt;setting-&gt; developer setting-&gt; OAuth apps-&gt; Register a new application</p></li><li><p>2.填写app信息url、回调url、设置secret key</p></li><li><p>3.可以把appid、secret key记录在setting中，分布式配置在redis上</p></li><li><p>4.写一个访问github登录的url(访问时注意清理缓存)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">APP_ID &#x3D; &#39;0a71c910aea67cfddd46&#39;</span><br><span class="line">REDIRECT_URI &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1&#x2F;rms&#x2F;login2&#39;</span><br><span class="line">STATE &#x3D; &#39;&#39;</span><br><span class="line"># 可以把key放在环境变量、redis等</span><br><span class="line">SECRET_KEY &#x3D; &#39;e7c1eb41d600b7a6d1d8409eb44bb4bf7d4afc5c&#39;</span><br><span class="line">from django.http import HttpResponseRedirect</span><br><span class="line">from urllib.parse import urlencode, unquote</span><br><span class="line">@api_view([&#39;get&#39;, &#39;post&#39;])</span><br><span class="line">def get_login_url(request):</span><br><span class="line">    if request.method &#x3D;&#x3D; &#39;GET&#39;:</span><br><span class="line">        url &#x3D; &#39;https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;authorize?&#39;</span><br><span class="line">        params &#x3D; &#123;</span><br><span class="line">            &#39;response_type&#39;:&#39;code&#39;,</span><br><span class="line">            &#39;client_id&#39;: APP_ID,</span><br><span class="line">            &#39;redirect_url&#39;: REDIRECT_URI,</span><br><span class="line">            &#39;state&#39;: &#39;&#39;,</span><br><span class="line">        &#125;</span><br><span class="line">        return HttpResponseRedirect(url + urlencode(params))</span><br></pre></td></tr></table></figure></li><li><p>5.由于指定了回调函数，登录成功后，github带着生成的code调用我们的回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">@api_view([&#39;get&#39;, &#39;post&#39;])</span><br><span class="line">def login_by_github(request):</span><br><span class="line">    code &#x3D; request.GET.get(&#39;code&#39;)</span><br><span class="line">    state &#x3D; request.GET.get(&#39;state&#39;)</span><br><span class="line">    if state !&#x3D; STATE:</span><br><span class="line">        raise Exception(&#39;state error&#39;)</span><br><span class="line">    # 获取access_token</span><br><span class="line">    params &#x3D; &#123;</span><br><span class="line">        &#39;code&#39;: code,</span><br><span class="line">        &#39;client_id&#39;: APP_ID,</span><br><span class="line">        &#39;client_secret&#39;: SECRET_KEY ,</span><br><span class="line">        &#39;grant_type&#39;: &#39;authorization_code&#39;,</span><br><span class="line">        &#39;redirect_uri&#39;: REDIRECT_URI</span><br><span class="line">    &#125;</span><br><span class="line">    url &#x3D; &#39;https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;access_token&#39;</span><br><span class="line">    response &#x3D; requests.get(url, params&#x3D;params)</span><br><span class="line">    data &#x3D; response.content.decode(&#39;utf-8&#39;)</span><br><span class="line">    access_token &#x3D; data.split(&#39;&amp;&#39;)[0].split(&#39;&#x3D;&#39;)[1]</span><br><span class="line">    url2 &#x3D; &#39;https:&#x2F;&#x2F;api.github.com&#x2F;user&#39;</span><br><span class="line">    headers &#x3D; &#123;&#39;Authorization&#39;: &#39;token &#123;&#125;&#39;.format(access_token)&#125;</span><br><span class="line">    response &#x3D; requests.get(url2, headers&#x3D;headers)</span><br><span class="line">    data &#x3D; response.content.decode(&#39;utf-8&#39;)</span><br></pre></td></tr></table></figure></li><li><p>在回调函数中访问github的接口获取access_token</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;access_token&#39;</span><br><span class="line">response &#x3D; requests.get(url, params&#x3D;params)</span><br><span class="line">data &#x3D; response.content.decode(&#39;utf-8&#39;)</span><br><span class="line">access_token &#x3D; data.split(&#39;&amp;&#39;)[0].split(&#39;&#x3D;&#39;)[1]</span><br></pre></td></tr></table></figure></li><li><p>再通过access_token获得用户的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> access_token &#x3D; data.split(&#39;&amp;&#39;)[0].split(&#39;&#x3D;&#39;)[1]</span><br><span class="line">url2 &#x3D; &#39;https:&#x2F;&#x2F;api.github.com&#x2F;user&#39;</span><br><span class="line">headers &#x3D; &#123;&#39;Authorization&#39;: &#39;token &#123;&#125;&#39;.format(access_token)&#125;</span><br><span class="line">response &#x3D; requests.get(url2, headers&#x3D;headers)</span><br><span class="line"># data为一个字典字符串，用json.loads</span><br><span class="line">data &#x3D; response.content.decode(&#39;utf-8&#39;)</span><br></pre></td></tr></table></figure></li><li><p>此处data即为用户信息，我们可以用该用户信息和我们的网站做关联</p><ul><li>比如如果已经有用户可以把data里的id绑定我们的用户</li><li>没有用户则自动创建一个基础用户，用户名就用data中的用户名，还有唯一id<br>（下次第三方登录就用id去数据库查询该用户）（可以建第三方用户表区别主站用户）</li></ul></li></ul><h2 id="各个url参数解析"><a href="#各个url参数解析" class="headerlink" title="各个url参数解析"></a>各个url参数解析</h2><h3 id="https-github-com-login-oauth-authorize"><a href="#https-github-com-login-oauth-authorize" class="headerlink" title="https://github.com/login/oauth/authorize"></a><a href="https://github.com/login/oauth/authorize">https://github.com/login/oauth/authorize</a></h3><p>参数</p><ul><li><p>client_id<br>注册信息以后就会得到一个app_id</p></li><li><p>redirect_uri<br>在登录验证接口之后会调用回调函数</p></li><li><p>login<br>Suggests a specific account to use for signing in and authorizing the app</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/80659787">scope</a><br>微博服务器对自己对外开放的权限需要颗粒度的控制，比如只能获取昵称头像，<br>或者只能手机号等等，一般在前期部署都会定义好，告诉微博你需要申请什么<br>类型的授权scope=email</p></li><li><p>state<br>一个随机字符串，用来避免跨站请求、攻击。在这里传入后会在回调函数中以传参的形式返回<br>所以在回调函数中可以验证此函数</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大致流程（以github为例）&quot;&gt;&lt;a href=&quot;#大致流程（以github为例）&quot; class=&quot;headerlink&quot; title=&quot;大致流程（以github为例）&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.github.com/en/devel</summary>
      
    
    
    
    <category term="webframe" scheme="http://example.com/categories/webframe/"/>
    
    
  </entry>
  
  <entry>
    <title>单点登录</title>
    <link href="http://example.com/2021/06/15/webframe/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>http://example.com/2021/06/15/webframe/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</id>
    <published>2021-06-15T01:28:37.711Z</published>
    <updated>2021-06-12T02:42:21.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是单点登录？"><a href="#什么是单点登录？" class="headerlink" title="什么是单点登录？"></a>什么是单点登录？</h2><p><a href="https://developer.aliyun.com/article/636281">单点登录</a><br>是在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><h3 id="同域处理"><a href="#同域处理" class="headerlink" title="同域处理"></a>同域处理</h3><p>同域名下，可以设置cookie的顶级域名访问，然后共享session（redis）</p><h3 id="不同域处理"><a href="#不同域处理" class="headerlink" title="不同域处理"></a>不同域处理</h3><p>这里假设不同系统不共享session<br>把登录业务抽象出来做一个单独的sso系统，用户访问某个系统时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户访问app系统，app系统没有登录，跳转到SSO。</span><br><span class="line">由于SSO已经登录了，不需要重新登录认证。</span><br><span class="line">SSO生成ST，浏览器跳转到app系统，并将ST作为参数传递给app。</span><br><span class="line">app拿到ST，后台访问SSO，验证ST是否有效。</span><br><span class="line">验证成功后，app将登录状态写入session，并在app域下写入Cookie。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是单点登录？&quot;&gt;&lt;a href=&quot;#什么是单点登录？&quot; class=&quot;headerlink&quot; title=&quot;什么是单点登录？&quot;&gt;&lt;/a&gt;什么是单点登录？&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/article/</summary>
      
    
    
    
    <category term="webframe" scheme="http://example.com/categories/webframe/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2021/06/15/webframe/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2021/06/15/webframe/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-06-15T01:28:37.710Z</published>
    <updated>2021-06-13T07:20:21.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h2><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a><a href="http://c.biancheng.net/view/1322.html">开闭原则</a></h3><p>软件实体应当对扩展开放，对修改关闭</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a><a href="http://c.biancheng.net/view/1324.html">里氏替换原则</a></h3><ul><li>1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li><li>2.子类中可以增加自己特有的方法</li><li>3.当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li><li>4.当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等</li></ul><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a><a href="http://c.biancheng.net/view/1326.html">依赖倒置原则</a></h3><ul><li>1.每个类尽量提供接口或抽象类，或者两者都具备。</li><li>2.变量的声明类型尽量是接口或者是抽象类。</li><li>3.任何类都不应该从具体类派生。</li><li>4.使用继承时尽量遵循里氏替换原则。</li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a><a href="http://c.biancheng.net/view/1327.html">单一职责原则</a></h3><ul><li>单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</li><li>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性，降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</li></ul><h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a><a href="http://c.biancheng.net/view/1331.html">迪米特原则</a></h3><p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a><a href="http://c.biancheng.net/view/1333.html">合成复用原则</a></h3><p>它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a><a href="http://c.biancheng.net/view/1330.html">接口隔离原则</a></h3><p>要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p><h2 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h2><p>按照架构分为3种</p><ul><li>1.创建型模式</li><li>2.结构型模式</li><li>3.行为模式</li></ul><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 简单单例</span><br><span class="line">import threading</span><br><span class="line">class Single:</span><br><span class="line">    lock &#x3D; threading.Lock()</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        with Single.lock:</span><br><span class="line">            if not hasattr(cls, &#39;_instance&#39;):</span><br><span class="line">                cls._instance &#x3D; super().__new__(cls, *args, **kwargs)</span><br><span class="line">        return cls._instance</span><br></pre></td></tr></table></figure><h3 id="装饰器模式AOP"><a href="#装饰器模式AOP" class="headerlink" title="装饰器模式AOP"></a>装饰器模式AOP</h3><h4 id="装饰器实现日志"><a href="#装饰器实现日志" class="headerlink" title="装饰器实现日志"></a>装饰器实现日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    @wraps(func)</span><br><span class="line">    def decorator(*args, **kwargs):</span><br><span class="line">        with open(func.__name__, &#39;wb&#39;) as f:</span><br><span class="line">            current_time &#x3D; time.time()</span><br><span class="line">            res &#x3D; func(*args, **kwargs)</span><br><span class="line">            cost_time &#x3D; time.time() - current_time</span><br><span class="line">            f.write(&#39;执行&#123;&#125;函数，花费了&#123;&#125;s&#39;.format(func.__name__, cost_time).encode(&#39;utf-8&#39;))</span><br><span class="line">        return res</span><br><span class="line">    return decorator</span><br><span class="line">    </span><br><span class="line">@log</span><br><span class="line">def task(*args, **kwargs):</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line">    return &#39;axiba&#39;</span><br><span class="line"></span><br><span class="line">print(task(123, 5, 6))</span><br></pre></td></tr></table></figure><h4 id="装饰器实现缓存"><a href="#装饰器实现缓存" class="headerlink" title="装饰器实现缓存"></a>装饰器实现缓存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def cache(func):</span><br><span class="line">    cache &#x3D; &#123;&#125;</span><br><span class="line">    def decorator(n):</span><br><span class="line">        if n in cache:</span><br><span class="line">            return cache[n]</span><br><span class="line">        else:</span><br><span class="line">            cache[n] &#x3D; func(n)</span><br><span class="line">        return cache[n]</span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">@cache</span><br><span class="line">def fib(n):</span><br><span class="line">    if n &lt;&#x3D; 1:</span><br><span class="line">        return n</span><br><span class="line">    return fib(n-1) + fib(n-2)</span><br><span class="line"></span><br><span class="line">print(fib(100))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;七大原则&quot;&gt;&lt;a href=&quot;#七大原则&quot; class=&quot;headerlink&quot; title=&quot;七大原则&quot;&gt;&lt;/a&gt;七大原则&lt;/h2&gt;&lt;h3 id=&quot;开闭原则&quot;&gt;&lt;a href=&quot;#开闭原则&quot; class=&quot;headerlink&quot; title=&quot;开闭原则&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="webframe" scheme="http://example.com/categories/webframe/"/>
    
    
  </entry>
  
  <entry>
    <title>jwt</title>
    <link href="http://example.com/2021/06/15/webframe/jwt/"/>
    <id>http://example.com/2021/06/15/webframe/jwt/</id>
    <published>2021-06-15T01:28:37.710Z</published>
    <updated>2021-06-12T02:41:27.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JWT是一个含签名并携带用户相关信息的加密串，页面请求校验登录接口时，<br>请求头中携带JWT串到后端服务，后端通过签名加密串匹配校验，保证信息未<br>被篡改。校验通过则认为是可靠的请求，将正常返回数据。</p><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>JWT由三部分组成，分别是头信息header、有效载荷payload、签名signature，中间以（.）分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.yyy.zzz</span><br></pre></td></tr></table></figure><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>由两部分组成，令牌类型（即：JWT）、散列算法（HMAC、RSASSA、RSASSA-PSS等），例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，这个JSON被编码为Base64Url，形成JWT的第一部分。</p><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>JWT的第二部分是payload，其中包含claims。claims是关于实体（常用的是用户信息）<br>和其他数据的声明，claims有三种类型： registered, public, and private claims。</p><ul><li><p>1.Registered claims： 这些是一组预定义的claims，非强制性的，但是推荐使用，<br>iss（发行人）， exp（到期时间）， sub（主题）， aud（观众）等；</p></li><li><p>2.Public claims: 自定义claims，注意不要和JWT注册表中属性冲突，这里可以查看JWT注册表；</p></li><li><p>3.Private claims: 这些是自定义的claims，用于在同意使用这些claims的各方之间共享信息，<br>它们既不是Registered claims，也不是Public claims。</p></li><li><p>以下是payload示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，再经过Base64Url编码，形成JWT的第二部分。</p></li><li><p>注意<br>对于签名令牌，此信息虽然可以防止篡改，但任何人都可以读取。除非加密，<br>否则不要将敏感信息放入到Payload或Header元素中。</p></li></ul><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>要创建签名部分，必须采用编码的Header，编码的Payload，秘钥，Header中指定的算法，并对其进行签名。<br>例如，如果要使用HMAC SHA256算法，将按以下方式创建签名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>签名用于验证消息在此过程中未被篡改，并且，在使用私钥签名令牌的情况下，<br>它还可以验证JWT的请求方是否是它所声明的请求方。输出是三个由点分隔的<br>Base64-URL字符串，可以在HTML和HTTP环境中轻松传递，与SAML等基于XML<br>的标准相比更加紧凑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.</span><br><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.</span><br><span class="line">SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure><h2 id="jwt存储方式"><a href="#jwt存储方式" class="headerlink" title="jwt存储方式"></a>jwt存储方式</h2><h3 id="localStorage-sessionStorage存储"><a href="#localStorage-sessionStorage存储" class="headerlink" title="localStorage/sessionStorage存储"></a>localStorage/sessionStorage存储</h3><p>响应正文将包含JWT作为一个访问令牌:</p><ul><li><p>后台api</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line"> </span><br><span class="line">  &#123;</span><br><span class="line">  &quot;access_token&quot;: &quot;eyJhbGciOiJIUzI1NiIsI.eyJpc3MiOiJodHRwczotcGxlL.mFrs3Zo8eaSNcxiNfvRh9dqKP4F1cB&quot;,</span><br><span class="line">  &quot;expires_in&quot;:3600</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>在客户端，你可以将这个令牌存储在HTML5 Web存储中(假设我们有一个成功的回调函数)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function tokenSuccess(err, response) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">    $window.sessionStorage.accessToken &#x3D; response.body.access_token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回传访问令牌到你受保护的API，你将使用HTTP Authorization Header和Bearer组合。请求你的SPA将会像:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1</span><br><span class="line">GET &#x2F;xxx</span><br><span class="line">Host: xxx.com</span><br><span class="line">Authorization: Bearer eyJhbGciOiJIUzI1NiIsI.</span><br><span class="line">eyJpc3MiOiJodHRwczotcGxlL.</span><br><span class="line">mFrs3Zo8eaSNcxiNfvRh9dqKP4F1cB</span><br></pre></td></tr></table></figure><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>如果在Authorization header中发送令牌，则跨域资源共享（CORS）将不会成为问题，因为它不使用cookie，<br>这样可以用jwt做简单的单点登录，分离出登录系统做sso。</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>xss攻击<br>Web存储(localStorage/sessionStorage)可以通过同一域上JavaScript访问。<br>这意味着任何在你的网站上运行的JavaScript都可以访问Web存储，因为这样容易<br>受到跨站点脚本（XSS）攻击。(最好确定用https发送jwt)</li></ul><h3 id="cookie存储"><a href="#cookie存储" class="headerlink" title="cookie存储"></a>cookie存储</h3><ul><li>后端通过response.set_cookie进行设置</li><li>回传访问令牌到你同一领域受保护的API，浏览器将自动包括cookie的值。请求你受保护的API将类似于:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;xxx</span><br><span class="line">Host: xxx.com</span><br><span class="line">Cookie: access_token&#x3D;eyJhbGciOiJIUzI1NiIsI.</span><br><span class="line">eyJpc3MiOiJodHRwczotcGxlL.</span><br><span class="line">mFrs3Zo8eaSNcxiNfvRh9dqKP4F1cB;</span><br></pre></td></tr></table></figure><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4>Cookies，当使用带有HttpOnly的cookie标志时，通过<br>JavaScript是无法访问的，并且对XSS是免疫的。你还可<br>以设置安全的cookie标志来保证cokie仅通过HTTPS发送。<br>这是过去利用cookie存储令牌或会话数据的主要原因之一。<br>现代开发人员不愿使用cookie,因为它们通常要求状态被存<br>储在服务器上,从而打破RESTful的最佳实践。如果你在cookie<br>上存储JWT，cookie作为存储机制不用将状态存储在服务器上。<br>这是因为JWT封装了所有服务器需要服务的请求。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>csrf攻击<br>cookies容易受到不同类型的攻击：跨站点请求伪造(CSRF)。</li><li>解决设置cookie同源、同域、path等</li></ul><h2 id="jwt的缺点"><a href="#jwt的缺点" class="headerlink" title="jwt的缺点"></a>jwt的缺点</h2><h3 id="无法满足注销场景"><a href="#无法满足注销场景" class="headerlink" title="无法满足注销场景"></a>无法满足注销场景</h3><p>传统注销清空session即可，因为服务端保存状态。而jwt是无状态的，一旦被生成<br>在过期时间没到之前都是可用的，虽然注销后可以删除cookie中的jwt，但不代表这个<br>jwt不可用。</p><h3 id="无法满足修改密码场景"><a href="#无法满足修改密码场景" class="headerlink" title="无法满足修改密码场景"></a>无法满足修改密码场景</h3><p>修改密码后，盗号者在原jwt有效期内还是可以使用，如果你没有把password加入jwt（应该都不会把）。</p><h3 id="无法满足token续签场景"><a href="#无法满足token续签场景" class="headerlink" title="无法满足token续签场景"></a>无法满足token续签场景</h3><p>jwt严格定义过期时间，一旦生成，就无法续签延时。</p><h2 id="django-flask实操jwt登录"><a href="#django-flask实操jwt登录" class="headerlink" title="django/flask实操jwt登录"></a>django/flask实操jwt登录</h2><p>以django为例的jwt使用</p><h3 id="大致流程概述"><a href="#大致流程概述" class="headerlink" title="大致流程概述"></a>大致流程概述</h3><p>这里其实可以自己手动定制一个简单的jwt，并不复杂，但没必要-vvvvvv-嘿嘿，但还是可以，但……。</p><ul><li>1.生成payload里面带有user_id,exp(过期时间),username,email,aud,iat(issued at)甚至可以带权限</li><li>2.调准过期时间，payload用json.dumps编码为字符，并encode为二进制。</li><li>3.分别对payload，header(也需要dumps、encode一下下)（在setting中配置）进行base64编码</li><li>4.通过header中的algorithm拿到算法，获取secretkey（alg.prepare_key(key)）<br>再获取signature：alg.sign(signing_input, secretkey)</li><li>5.对signature进行base64，然后把三个段结合在一起。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#默认自带算法</span><br><span class="line">&#39;none&#39;: NoneAlgorithm(),</span><br><span class="line">&#39;HS256&#39;: HMACAlgorithm(HMACAlgorithm.SHA256),</span><br><span class="line">&#39;HS384&#39;: HMACAlgorithm(HMACAlgorithm.SHA384),</span><br><span class="line">&#39;HS512&#39;: HMACAlgorithm(HMACAlgorithm.SHA512)</span><br></pre></td></tr></table></figure></li></ul><h3 id="安装和简单使用"><a href="#安装和简单使用" class="headerlink" title="安装和简单使用"></a>安装和简单使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pip install djangorestframework-jwt</span><br><span class="line">pip install django-cors-header</span><br><span class="line">from rest_framework_jwt.serializers import jwt_encode_handler, jwt_payload_handler</span><br><span class="line">from rest_framework_jwt.authentication import JSONWebTokenAuthentication</span><br><span class="line"># 伪代码</span><br><span class="line">def create(self, request, *args, **kwargs):</span><br><span class="line">    serializer &#x3D; self.get_serializer(data&#x3D;request.data)</span><br><span class="line">    serializer.is_valid(raise_exception&#x3D;True)</span><br><span class="line">    user &#x3D; self.perform_create(serializer)</span><br><span class="line">    # token和payload的生成</span><br><span class="line">    re_dict &#x3D; serializer.data</span><br><span class="line">    payload &#x3D; jwt_payload_handler(user)</span><br><span class="line">    print(request.auth)</span><br><span class="line">    re_dict[&#39;token&#39;] &#x3D; jwt_encode_handler(payload)</span><br><span class="line">    re_dict[&#39;name&#39;] &#x3D; user.name if user.name else user.username</span><br><span class="line">    headers &#x3D; self.get_success_headers(serializer.data)</span><br><span class="line">    return Response(re_dict, status&#x3D;status.HTTP_201_CREATED, headers&#x3D;headers)</span><br></pre></td></tr></table></figure><h3 id="jwt-payload-handler生成payload"><a href="#jwt-payload-handler生成payload" class="headerlink" title="jwt_payload_handler生成payload"></a>jwt_payload_handler生成payload</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">注意这里payload的信息</span><br><span class="line">def jwt_payload_handler(user):</span><br><span class="line">    username_field &#x3D; get_username_field()</span><br><span class="line">    username &#x3D; get_username(user)</span><br><span class="line">    warnings.warn(</span><br><span class="line">        &#39;The following fields will be removed in the future: &#39;</span><br><span class="line">        &#39;&#96;email&#96; and &#96;user_id&#96;. &#39;,</span><br><span class="line">        DeprecationWarning</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    payload &#x3D; &#123;</span><br><span class="line">        &#39;user_id&#39;: user.pk,</span><br><span class="line">        &#39;username&#39;: username,</span><br><span class="line">        &#39;exp&#39;: datetime.utcnow() + api_settings.JWT_EXPIRATION_DELTA</span><br><span class="line">    &#125;</span><br><span class="line">    if hasattr(user, &#39;email&#39;):</span><br><span class="line">        payload[&#39;email&#39;] &#x3D; user.email</span><br><span class="line">    if isinstance(user.pk, uuid.UUID):</span><br><span class="line">        payload[&#39;user_id&#39;] &#x3D; str(user.pk)</span><br><span class="line"></span><br><span class="line">    payload[username_field] &#x3D; username</span><br><span class="line"></span><br><span class="line">    # Include original issued at time for a brand new token,</span><br><span class="line">    # to allow token refresh</span><br><span class="line">    if api_settings.JWT_ALLOW_REFRESH:</span><br><span class="line">        payload[&#39;orig_iat&#39;] &#x3D; timegm(</span><br><span class="line">            datetime.utcnow().utctimetuple()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    if api_settings.JWT_AUDIENCE is not None:</span><br><span class="line">        payload[&#39;aud&#39;] &#x3D; api_settings.JWT_AUDIENCE</span><br><span class="line"></span><br><span class="line">    if api_settings.JWT_ISSUER is not None:</span><br><span class="line">        payload[&#39;iss&#39;] &#x3D; api_settings.JWT_ISSUER</span><br><span class="line"></span><br><span class="line">    return payload</span><br></pre></td></tr></table></figure><h3 id="jwt-encode-handler获取jwt-token"><a href="#jwt-encode-handler获取jwt-token" class="headerlink" title="jwt_encode_handler获取jwt_token"></a>jwt_encode_handler获取jwt_token</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">def jwt_encode_handler(payload):</span><br><span class="line">    key &#x3D; api_settings.JWT_PRIVATE_KEY or jwt_get_secret_key(payload)</span><br><span class="line">    return jwt.encode(</span><br><span class="line">        payload,</span><br><span class="line">        key,</span><br><span class="line">        api_settings.JWT_ALGORITHM</span><br><span class="line">    ).decode(&#39;utf-8&#39;)</span><br><span class="line"></span><br><span class="line"># jwt.encode 主要设置jwt本地过期时间、编码payload</span><br><span class="line">def encode(self,</span><br><span class="line">           payload,  # type: Union[Dict, bytes]</span><br><span class="line">           key,  # type: str</span><br><span class="line">           algorithm&#x3D;&#39;HS256&#39;,  # type: str</span><br><span class="line">           headers&#x3D;None,  # type: Optional[Dict]</span><br><span class="line">           json_encoder&#x3D;None  # type: Optional[Callable]</span><br><span class="line">           ):</span><br><span class="line">    # Check that we get a mapping</span><br><span class="line">    if not isinstance(payload, Mapping):</span><br><span class="line">        raise TypeError(&#39;Expecting a mapping object, as JWT only supports &#39;</span><br><span class="line">                        &#39;JSON objects as payloads.&#39;)</span><br><span class="line"></span><br><span class="line">    # Payload</span><br><span class="line">    for time_claim in [&#39;exp&#39;, &#39;iat&#39;, &#39;nbf&#39;]:</span><br><span class="line">        # Convert datetime to a intDate value in known time-format claims</span><br><span class="line">        if isinstance(payload.get(time_claim), datetime):</span><br><span class="line">            payload[time_claim] &#x3D; timegm(payload[time_claim].utctimetuple())  # type: ignore</span><br><span class="line"></span><br><span class="line">    json_payload &#x3D; json.dumps(</span><br><span class="line">        payload,</span><br><span class="line">        separators&#x3D;(&#39;,&#39;, &#39;:&#39;),</span><br><span class="line">        cls&#x3D;json_encoder</span><br><span class="line">    ).encode(&#39;utf-8&#39;)</span><br><span class="line"></span><br><span class="line">    return super(PyJWT, self).encode(</span><br><span class="line">        json_payload, key, algorithm, headers, json_encoder</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"># super(PyJWT, self).encode(</span><br><span class="line">            json_payload, key, algorithm, headers, json_encoder</span><br><span class="line">        ) # 获取jwt_token</span><br><span class="line">    def encode(self,</span><br><span class="line">               payload,  # type: Union[Dict, bytes]</span><br><span class="line">               key,  # type: str</span><br><span class="line">               algorithm&#x3D;&#39;HS256&#39;,  # type: str</span><br><span class="line">               headers&#x3D;None,  # type: Optional[Dict]</span><br><span class="line">               json_encoder&#x3D;None  # type: Optional[Callable]</span><br><span class="line">               ):</span><br><span class="line">        segments &#x3D; []</span><br><span class="line"></span><br><span class="line">        if algorithm is None:</span><br><span class="line">            algorithm &#x3D; &#39;none&#39;</span><br><span class="line"></span><br><span class="line">        if algorithm not in self._valid_algs:</span><br><span class="line">            pass</span><br><span class="line"></span><br><span class="line">        # Header</span><br><span class="line">        header &#x3D; &#123;&#39;typ&#39;: self.header_typ, &#39;alg&#39;: algorithm&#125;</span><br><span class="line"></span><br><span class="line">        if headers:</span><br><span class="line">            self._validate_headers(headers)</span><br><span class="line">            header.update(headers)</span><br><span class="line"></span><br><span class="line">        json_header &#x3D; force_bytes(</span><br><span class="line">            json.dumps(</span><br><span class="line">                header,</span><br><span class="line">                separators&#x3D;(&#39;,&#39;, &#39;:&#39;),</span><br><span class="line">                cls&#x3D;json_encoder</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        segments.append(base64url_encode(json_header))</span><br><span class="line">        segments.append(base64url_encode(payload))</span><br><span class="line"></span><br><span class="line">        # Segments</span><br><span class="line">        signing_input &#x3D; b&#39;.&#39;.join(segments)</span><br><span class="line">        try:</span><br><span class="line">            alg_obj &#x3D; self._algorithms[algorithm]</span><br><span class="line">            key &#x3D; alg_obj.prepare_key(key)</span><br><span class="line">            signature &#x3D; alg_obj.sign(signing_input, key)</span><br><span class="line"></span><br><span class="line">        except KeyError:</span><br><span class="line">            if not has_crypto and algorithm in requires_cryptography:</span><br><span class="line">                raise NotImplementedError(</span><br><span class="line">                    &quot;Algorithm &#39;%s&#39; could not be found. Do you have cryptography &quot;</span><br><span class="line">                    &quot;installed?&quot; % algorithm</span><br><span class="line">                )</span><br><span class="line">            else:</span><br><span class="line">                raise NotImplementedError(&#39;Algorithm not supported&#39;)</span><br><span class="line"></span><br><span class="line">        segments.append(base64url_encode(signature))</span><br><span class="line"></span><br><span class="line">        return b&#39;.&#39;.join(segments)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;JWT是一个含签名并携带用户相关信息的加密串，页面请求校验登录接口时，&lt;br&gt;请求头中携带JWT串到后端服务，后端通过签名加密串匹配校验，保</summary>
      
    
    
    
    <category term="webframe" scheme="http://example.com/categories/webframe/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://example.com/2021/06/15/redis%E9%AB%98%E7%BA%A7%E7%AF%87/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://example.com/2021/06/15/redis%E9%AB%98%E7%BA%A7%E7%AF%87/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2021-06-15T01:28:37.709Z</published>
    <updated>2021-06-12T02:30:51.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式锁介绍"><a href="#分布式锁介绍" class="headerlink" title="分布式锁介绍"></a>分布式锁介绍</h2><p>当多个系统并发操作redis如何处理？<br>主要方法是使用分布式锁，抢到锁的做set操作·。<br><a href="https://juejin.im/post/6844903830442737671">分布式锁实现方式</a><br><a href="https://juejin.im/post/6844903688088059912">分布式锁</a></p><h3 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h3><ul><li>1.避免不同的节点做相同的工作，比如发送短信通知。</li><li>2.避免同时操作一个数据导致数据正确性出现问题。比如多个节点操作同一个订单流程，<br>还没付款已经结账了，或者同时操作一个库存，导致不一致。</li></ul><h3 id="2-分布式锁的特点"><a href="#2-分布式锁的特点" class="headerlink" title="2.分布式锁的特点"></a>2.分布式锁的特点</h3><ul><li><p>1.互斥性<br>保证在不同节点不同线程的互斥。</p></li><li><p>2.可重入<br>同一个节点上的同一个线程如果获取过该锁，那么可以再次获取。<br>若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另一段代码，<br>且这段代码又掉用了子程序不会出错，则称其为可重入”。即在該子程序在运行时，<br>执行线程可以再次进入并执行它。仍然获得符合符合设计预期的结果。与多线程并<br>发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序任然<br>是安全的。</p></li><li><p>如果想要实现锁的重入，至少要解决一下两个问题</p><ul><li>线程再次获取锁：锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</li><li>锁的最终释放：线程重复n次获取了锁，随后在n次释放该锁后，其他线程能够获取该锁。锁的最终释<br>放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数<br>等于0时表示锁已经释放<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"># python treading.local中的可重入锁，其实就是加一个计数器</span><br><span class="line">def RLock(*args, **kwargs):</span><br><span class="line">    if _CRLock is None:</span><br><span class="line">        return _PyRLock(*args, **kwargs)</span><br><span class="line">    return _CRLock(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">class _RLock:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._block &#x3D; _allocate_lock()</span><br><span class="line">        self._owner &#x3D; None</span><br><span class="line">        self._count &#x3D; 0</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        owner &#x3D; self._owner</span><br><span class="line">        try:</span><br><span class="line">            owner &#x3D; _active[owner].name</span><br><span class="line">        except KeyError:</span><br><span class="line">            pass</span><br><span class="line">        return &quot;&lt;%s %s.%s object owner&#x3D;%r count&#x3D;%d at %s&gt;&quot; % (</span><br><span class="line">            &quot;locked&quot; if self._block.locked() else &quot;unlocked&quot;,</span><br><span class="line">            self.__class__.__module__,</span><br><span class="line">            self.__class__.__qualname__,</span><br><span class="line">            owner,</span><br><span class="line">            self._count,</span><br><span class="line">            hex(id(self))</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def acquire(self, blocking&#x3D;True, timeout&#x3D;-1):</span><br><span class="line">        me &#x3D; get_ident()</span><br><span class="line">        if self._owner &#x3D;&#x3D; me:</span><br><span class="line">            self._count +&#x3D; 1</span><br><span class="line">            return 1</span><br><span class="line">        rc &#x3D; self._block.acquire(blocking, timeout)</span><br><span class="line">        if rc:</span><br><span class="line">            self._owner &#x3D; me</span><br><span class="line">            self._count &#x3D; 1</span><br><span class="line">        return rc</span><br><span class="line"></span><br><span class="line">    __enter__ &#x3D; acquire</span><br><span class="line"></span><br><span class="line">    def release(self):</span><br><span class="line">        if self._owner !&#x3D; get_ident():</span><br><span class="line">            raise RuntimeError(&quot;cannot release un-acquired lock&quot;)</span><br><span class="line">        self._count &#x3D; count &#x3D; self._count - 1</span><br><span class="line">        if not count:</span><br><span class="line">            self._owner &#x3D; None</span><br><span class="line">            self._block.release()</span><br><span class="line"></span><br><span class="line">    def __exit__(self, t, v, tb):</span><br><span class="line">        self.release()</span><br><span class="line"></span><br><span class="line">    # Internal methods used by condition variables</span><br><span class="line"></span><br><span class="line">    def _acquire_restore(self, state):</span><br><span class="line">        self._block.acquire()</span><br><span class="line">        self._count, self._owner &#x3D; state</span><br><span class="line"></span><br><span class="line">    def _release_save(self):</span><br><span class="line">        if self._count &#x3D;&#x3D; 0:</span><br><span class="line">            raise RuntimeError(&quot;cannot release un-acquired lock&quot;)</span><br><span class="line">        count &#x3D; self._count</span><br><span class="line">        self._count &#x3D; 0</span><br><span class="line">        owner &#x3D; self._owner</span><br><span class="line">        self._owner &#x3D; None</span><br><span class="line">        self._block.release()</span><br><span class="line">        return (count, owner)</span><br><span class="line"></span><br><span class="line">    def _is_owned(self):</span><br><span class="line">        return self._owner &#x3D;&#x3D; get_ident()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>3.超时设置<br>防止死锁</p></li><li><p>4.高效<br>高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。</p></li><li><p>5.阻塞和非阻塞<br>阻塞：<br>如果获取不到锁就一直获取。（增加一个监听）<br>非阻塞：<br>如果获取不到锁就直接返回（或者定义个时间多久获取不到就直接返回）。</p></li></ul><h2 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a>分布式锁的实现</h2><h3 id="redis-setnx"><a href="#redis-setnx" class="headerlink" title="redis setnx"></a>redis setnx</h3><p>使用lua脚本保证操作的原子性，防止操作到某一步机器挂掉。<br>客户端通过setnx+lua获取锁判断逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import redis</span><br><span class="line">r &#x3D; redis.Redis(&#39;10.167.219.250&#39;, port&#x3D;8001, db&#x3D;5)</span><br><span class="line"></span><br><span class="line">def try_lock_with_lua(key, val, second):</span><br><span class="line">    lua_scripts &#x3D; &quot;if redis.call(&#39;setnx&#39;,KEYS[1],ARGV[1]) &#x3D;&#x3D; 1 then &quot; \</span><br><span class="line">                  &quot;redis.call(&#39;expire&#39;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span><br><span class="line"></span><br><span class="line">    res &#x3D; r.eval(lua_scripts, 1, key, val, second)</span><br><span class="line">    return res &#x3D;&#x3D; 1</span><br><span class="line"></span><br><span class="line">if try_lock_with_lua(&#39;k5555&#39;, &#39;11&#39;, 20):</span><br><span class="line">    print(1)</span><br></pre></td></tr></table></figure><h3 id="redis-gt-2-6-12-set"><a href="#redis-gt-2-6-12-set" class="headerlink" title="redis &gt; 2.6.12 set"></a>redis &gt; 2.6.12 set</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">自从redis2.6.12以后，增加了set name value ex nx</span><br><span class="line">以保证操作的原子性。</span><br><span class="line">def try_lock_with_self(key, val, second):</span><br><span class="line">    res &#x3D; r.set(key, val, ex&#x3D;second, nx&#x3D;True)</span><br><span class="line">    return res &#x3D;&#x3D; 1</span><br><span class="line"></span><br><span class="line">if try_lock_with_self(&#39;k5554&#39;, &#39;11&#39;, 20):</span><br><span class="line">    print(1)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>1.value必须要有唯一性<br>随机字符串+redis判断，hash等方法保证。</p><ul><li>1.客户端1获取锁成功 </li><li>2.客户端1在某个操作上阻塞了太长时间 </li><li>3.设置的key过期了，锁自动释放了 </li><li>4.客户端2获取到了对应同一个资源的锁 </li><li>5.客户端1从阻塞中恢复过来，因为value值一样，所以执行释放锁操作时就会释放掉客户端2持有的锁，<br>这样就会造成问题。</li></ul></li><li><p>2.释放锁<br>为了保证释放锁的原子性操作，选择使用lua脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def release_lock_with_lua(key, val):</span><br><span class="line">    lua_script &#x3D; &quot;if redis.call(&#39;get&#39;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then &quot; \</span><br><span class="line">            &quot;return redis.call(&#39;del&#39;,KEYS[1]) else return 0 end&quot;</span><br><span class="line">    res &#x3D; r.eval(lua_script, 1, key, val)</span><br><span class="line">    return res &#x3D;&#x3D; 1</span><br></pre></td></tr></table></figure><p>使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 看上去很OK，<br>实际上在Redis集群的时候也会出现问题，比如说A客户端在Redis的master节点上拿到了锁，<br>但是这个加锁的key还没有同步到slave节点，master故障，发生故障转移，一个slave节点升<br>级为master节点，B客户端也可以获取同个key的锁，但客户端A也已经拿到锁了，这就导致多个<br>客户端都拿到锁。（简单来说就是同步延时的问题，主机节点的数据还没同步给slave就挂掉了）</p></li></ul><h3 id="redlock-实现分布式锁"><a href="#redlock-实现分布式锁" class="headerlink" title="redlock 实现分布式锁"></a>redlock 实现分布式锁</h3><p><a href="https://www.jianshu.com/p/fba7dd6dcef5">redlock算法</a><br><a href="https://www.cnpython.com/pypi/redlock">redission实现</a></p><p>python 版redlock redlock-py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install redlock-py</span><br></pre></td></tr></table></figure><h4 id="redlock设计理念"><a href="#redlock设计理念" class="headerlink" title="redlock设计理念"></a>redlock设计理念</h4><p>一个Client想要获得一个锁需要以下几个操作：</p><ul><li><p>1    得到本地时间</p></li><li><p>2 Client使用相同的key和随机数,按照顺序在每个Master实例中尝试获得锁。<br>在获得锁的过程中，为每一个锁操作设置一个快速失败时间(如果想要获得一个10秒的锁，<br>那么每一个锁操作的失败时间设为5-50ms)。这样可以避免客户端与一个已经故障的Master<br>通信占用太长时间，通过快速失败的方式尽快的与集群中的其他节点完成锁操作。</p></li><li><p>3 客户端计算出与master获得锁操作过程中消耗的时间，当且仅当Client获得锁消耗的<br>时间小于锁的存活时间，并且在一半以上的master节点中获得锁。才认为client成功的获得了锁。</p></li><li><p>4 如果已经获得了锁，Client执行任务的时间窗口是锁的存活时间减去获得锁消耗的时间。</p></li><li><p>5 如果Client获得锁的数量不足一半以上，或获得锁的时间超时，那么认为获得锁失败。<br>客户端需要尝试在所有的master节点中释放锁， 即使在第二步中没有成功获得该Master节点中的锁，<br>仍要进行释放操作。</p></li></ul><ul><li><p>redlock算法成立条件<br>这个算法成立的一个条件是：即使集群中没有同步时钟，各个进程的时间流逝速度也要大体一致，<br>并且误差与锁存活时间相比是比较小的。实际应用中的计算机也能满足这个条件：各个计算机中间<br>有几毫秒的时钟漂移(clock drift)。</p></li><li><p>失败重试机制</p></li><li><p>如果一个Client无法获得锁，它将在一个随机延时后开始重试。使用随机延时的目的是为了与<br>其他申请同一个锁的Client错开申请时间，减少脑裂(split brain)发生的可能性。</p></li><li><p>脑裂</p><ul><li><p>三个Client同时尝试获得锁，分别获得了2,2,1个实例中的锁，三个锁请求全部失败。</p></li><li><p>一个client在全部Redis实例中完成的申请时间越短，发生脑裂的时间窗口越小。<br>所以比较理想的做法是同时向N个Redis实例发出异步的SET请求。<br>当Client没有在大多数Master中获得锁时，立即释放已经取得的锁时非常必要的。<br>(PS.当极端情况发生时，比如获得了部分锁以后，client发生网络故障，无法再释放<br>锁资源，那么其他client重新获得锁的时间将是锁的过期时间)。</p></li><li><p>无论Client认为在指定的Master中有没有获得锁，都需要执行释放锁操作。</p></li></ul></li></ul><h4 id="python简单实操redlock"><a href="#python简单实操redlock" class="headerlink" title="python简单实操redlock"></a>python简单实操redlock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from contextlib import contextmanager</span><br><span class="line">from redlock import Redlock</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def worker_lock_manager(key, ttl, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    分布式锁</span><br><span class="line">    :param key: 分布式锁ID</span><br><span class="line">    :param ttl: 分布式锁生存时间</span><br><span class="line">    :param kwargs: 可选参数字典</span><br><span class="line">    :return: None</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    redis_servers &#x3D; [&#123;</span><br><span class="line">        &#39;host&#39;: &#39;10.167.219.250&#39;,</span><br><span class="line">        &#39;port&#39;: 8001,</span><br><span class="line">        &#39;db&#39;: 5,</span><br><span class="line">    &#125;]</span><br><span class="line"></span><br><span class="line">    rlk &#x3D; Redlock(redis_servers)</span><br><span class="line"></span><br><span class="line">    # 获取锁</span><br><span class="line">    lock &#x3D; rlk.lock(key, ttl)</span><br><span class="line"></span><br><span class="line">    yield lock</span><br><span class="line">    print(1)</span><br><span class="line">    # 释放锁</span><br><span class="line">    rlk.unlock(lock)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">def do_something():</span><br><span class="line">    print(&#39;获取锁成功，开始事务操作&#39;)</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    print(&#39;事务操作成功，锁释放&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    with worker_lock_manager(&#39;unique_key&#39;, 1000) as w_lock:</span><br><span class="line">        if w_lock:</span><br><span class="line">            do_something()</span><br></pre></td></tr></table></figure><h3 id="zookeeper-临时节点-序号实现分布式锁"><a href="#zookeeper-临时节点-序号实现分布式锁" class="headerlink" title="zookeeper 临时节点+序号实现分布式锁"></a>zookeeper 临时节点+序号实现分布式锁</h3><p><a href="https://juejin.cn/post/6844903729406148622">zookeeper实现分布式锁</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">python调用zookeeper实现分布式锁：</span><br><span class="line">1.给定一台安装好zookeeper的服务器</span><br><span class="line">2.pip install kazoo</span><br><span class="line">python连接kazoo</span><br><span class="line"></span><br><span class="line">zookeeeper实现分布式锁的办法：</span><br><span class="line">使用临节点：</span><br><span class="line">1.用有序节点每次获取序号最小的节点赋予锁</span><br><span class="line">2.用无序节点当一个session释放后才能重新赋值抢锁。</span><br><span class="line">这里我们使用临时有序级节点</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分布式锁介绍&quot;&gt;&lt;a href=&quot;#分布式锁介绍&quot; class=&quot;headerlink&quot; title=&quot;分布式锁介绍&quot;&gt;&lt;/a&gt;分布式锁介绍&lt;/h2&gt;&lt;p&gt;当多个系统并发操作redis如何处理？&lt;br&gt;主要方法是使用分布式锁，抢到锁的做set操作·。&lt;br&gt;&lt;a </summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="redis高级篇" scheme="http://example.com/categories/nosql/redis%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title>redis主从复制</title>
    <link href="http://example.com/2021/06/15/redis%E9%AB%98%E7%BA%A7%E7%AF%87/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://example.com/2021/06/15/redis%E9%AB%98%E7%BA%A7%E7%AF%87/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2021-06-15T01:28:37.708Z</published>
    <updated>2021-06-15T03:48:28.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主从复制读写分离，info replicaiton查看信息，Master以写为主，<br>slave以读为主，主要是读写分离和容灾恢复，注意一般配从不配主。</p><ul><li>1.从库配置slaveof主库IP 主库端口</li><li>2.每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件</li><li>3.一般一主2从</li></ul><h2 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h2><ul><li><p>1.拷贝多个redis.conf文件<br>redis6379.conf<br>redis6380.conf<br>redis6381.conf</p></li><li><p>2.修改各个文件的配置：<br>开启daemonize yes<br>修改pid文件名<br>指定port<br>修改log文件名<br>修改dump.rdb文件名</p></li><li><p>3.配置启动<br>进入6380 6381<br>redis-server /myredis/redis6380.conf<br>redis-cli –p 6380<br>slaveof 127.0.0.1 6379<br>即可开启主从复制</p></li><li><p>4.获取主从表信息<br>info replication</p></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>1.当配置主从复制后，slaveof，主表之前的数据从表能获得吗？能！</li><li>2.在进行主从复制时，从表会清空，然后复制主表</li><li>3.从表不能进行修改set</li><li>4.从表shutdown之后，重新登录需要重新进行主从复制，否则该从表就不再是从表</li><li>5.主表shutdown之后，从表会原地等待，主表重新连回之后，依然是主从关系</li></ul><h2 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h2><p>火车结构，从表连从表，上一个是下一个的主表。</p><ul><li>1.1个主表多个从表，从表都从主表拿数据，主表压力很大。</li><li>2.去中心化：减轻master的负担</li><li>3.上一个是下一个的主表，像链表一样相连。但是传递有失真延时</li></ul><h2 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h2><ul><li>当第一个主表宕机可以使用slaveof no one使当前的数据库停止与主表同步，转成主数据库<br>薪火相传后面的库不用变<br>一主一从就需要改变别的从库跟随新的主库</li></ul><h2 id="哨兵模式（sentinel）最重要"><a href="#哨兵模式（sentinel）最重要" class="headerlink" title="哨兵模式（sentinel）最重要"></a>哨兵模式（sentinel）最重要</h2><p>反客为主的自动版（反客为主需要手动修改slave）<br>能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li><p>1.调整结构为一主二从</p></li><li><p>2.自定义/myredis目录下新建sentinel.conf文件，名字绝对不能错</p></li><li><p>3.配置哨兵sentinel填写内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor被监控数据库名字（自己起名字）127.0.0.1 6379 1</span><br><span class="line">上面最后一个数字1，表示主机挂了后slave投票看让谁接替成为主机，得票多少后成为主机</span><br><span class="line">vim sentinel.conf</span><br><span class="line">sentinel monitor host6379 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure></li><li><p>4.启动哨兵<br>redis-sentinel /myredis/sentinel.conf</p></li><li><p>5.检测哨兵</p><ul><li>1.挂掉6379 shutdown exit</li><li>2.检查6380 6381和哨兵info replicaiton</li><li>3.投票选举这时候在6380 6381中选出了一个master</li><li>4.重启6379，发现6379被哨兵检测到后变成小弟slave</li></ul></li><li><p>5.一组sentinel可以监控多个master</p></li><li><p>6.开启多个sentinel可以发现自动会形成一个sentinel组合</p></li></ul><h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><ul><li>1.从节点（slave）内部通过每秒运行的定时任务维护复制相关逻辑，<br>当定时任务发现存在新的主节点后，会尝试与该节点建立网络连接</li><li>2.发送 ping 命令，连接建立成功后从节点发送 ping 请求进行首次通信</li><li>3.slave发送一个sync命令，并建立一个 socket 套接字，从节点建立了一个端口为51234的套接字，<br>专门用于接受主节点发送的复制命令</li><li>5.master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后</li><li>6.master将传送整个文件到slave，以完成一次完全同步</li><li>7.master继续将新的所有收集到的修改命令依次传给slave<h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3>slave服务在接收到数据库文件数据后，将其存盘并加载到内存中<h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3>master继续将新的所有收集到的修改命令依次传给slave，完成同步但是只要是重新连接master，一次完全同步（全量复制）将被自动执行。</li></ul><h2 id="主从复制的缺点"><a href="#主从复制的缺点" class="headerlink" title="主从复制的缺点"></a>主从复制的缺点</h2><p>由于所有的写操作都是先在Master上操作，然后同步更新到slave，所以master同步到slave机器有一定的延时，<br>当系统很繁忙的时候，延迟问题会更加严重，slave机器数量的增加也会使得这个问题更加严重。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;主从复制读写分离，info replicaiton查看信息，Master以写为主，&lt;br&gt;slave以读为主，主要是读写分离和容灾恢复，注意</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="redis高级篇" scheme="http://example.com/categories/nosql/redis%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title>redis.conf解析</title>
    <link href="http://example.com/2021/06/15/redis%E9%AB%98%E7%BA%A7%E7%AF%87/redis%E9%A5%9C%E7%A6%BB%E6%81%85%E7%92%83%E8%B3%A4%E6%98%B4/"/>
    <id>http://example.com/2021/06/15/redis%E9%AB%98%E7%BA%A7%E7%AF%87/redis%E9%A5%9C%E7%A6%BB%E6%81%85%E7%92%83%E8%B3%A4%E6%98%B4/</id>
    <published>2021-06-15T01:28:37.707Z</published>
    <updated>2021-06-12T02:30:50.726Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"># General 通用常见标准化配置</span><br><span class="line">1.Redis默认不是以守护进程的方式运行，可以通过修改配置项，使用yes启用守护进程</span><br><span class="line">daemonize no -&gt; yes</span><br><span class="line"></span><br><span class="line">2.当Redis以守护进程方式运行时，Redis默认会把pid写入&#x2F;var&#x2F;run&#x2F;redis.pid文件，</span><br><span class="line">可以通过pidfile制定</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis.pid</span><br><span class="line"></span><br><span class="line">3.指定日志级别，Redis总共支持四个级别</span><br><span class="line">debug、verbose、notice、warning, 默认为notice</span><br><span class="line">debug建议开发阶段用notice生产环境用</span><br><span class="line">真的出故障就用warning只打出故障日志</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line">4.日志的记录方式，默认为标准输出。</span><br><span class="line">如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，</span><br><span class="line">则日志会发送给&#x2F;dev&#x2F;null</span><br><span class="line">logfile stdout</span><br><span class="line"></span><br><span class="line">5.如果希望日志打印到 syslog 中，也很容易，通过 syslog-enabled 来控制。</span><br><span class="line">syslog-enabled no</span><br><span class="line"></span><br><span class="line">6.另外，syslog-ident 还可以指定syslog 里的日志标志，比如：</span><br><span class="line">syslog-ident Redis</span><br><span class="line"></span><br><span class="line">7.而且还支持指定 syslog 设备，值可以是 USER 或 LOCAL0-LOCAL7 。</span><br><span class="line">具体可以参考 syslog 服务本身的用法。</span><br><span class="line">syslog-facility local0</span><br><span class="line"></span><br><span class="line">8.对于 Redis 来说，可以设置其数据库的总数量，</span><br><span class="line">假如希望一个 Redis 包含16个数据库，那么设置如下：</span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"># NETWORK</span><br><span class="line">1.指定Redis监听端口，默认端口为6379, 作者在博客中提到为什么用6379. </span><br><span class="line">因为6379代表MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字。</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line">2.绑定的主机地址</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line">3.当客户端闲置太长时间后关闭链接，如果指定为0，则表示关闭该功能</span><br><span class="line">(就像qq，30分钟没人给你发消息，你也没发消息，就终端连接减轻服务器负担)</span><br><span class="line">timeout 300</span><br><span class="line"></span><br><span class="line">4.tcp-backlog 511(默认511)</span><br><span class="line">backlog其实是一个连接队列，</span><br><span class="line">backlog队列总和&#x3D;未完成三次握手队列+已经完成三次握手队列</span><br><span class="line">在高并发的情况下，你需要一个高的backlog来避免慢客户端连接的问题，</span><br><span class="line">注意linux内核会将这个值减小到&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn的值</span><br><span class="line">所以需要确认增大somaxconn和tcp_max_syn_backlog两个值来达到想要的效果。</span><br><span class="line"></span><br><span class="line">5.tcp-keepalive</span><br><span class="line">TCP连接保活策略，可以通过 tcp-keepalive 配置项来进行设置，单位为秒，</span><br><span class="line">假如设置为60秒，则 server 端会每60秒向连接空闲的客户端发起一次 ACK 请求，</span><br><span class="line">以检查客户端是否已经挂掉，对于无响应的客户端则会关闭其连接。</span><br><span class="line">所以关闭一个连接最长需要120秒的时间。如果设置为0，则不会进行保活检测。</span><br><span class="line">tcp-keepalive 0</span><br><span class="line"></span><br><span class="line"># SNAPSHTTING快照</span><br><span class="line">备份</span><br><span class="line">1.save save + second + changes</span><br><span class="line">redis.conf的SNAPSHOTTING</span><br><span class="line">出发条件</span><br><span class="line">after 900 seconds if at least 1 key changed</span><br><span class="line">after 300 seconds if at least 10 keys changed</span><br><span class="line">after 60 seconds if at least 10000 keys changed</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">2.如果想禁用（save指令）（禁用RDB持久化策略），把三个默认删除，</span><br><span class="line">不要设置任何save指令或者给save传一个空字符串参数save “”</span><br><span class="line">3.你也可以在set key之后马上save</span><br><span class="line">set key</span><br><span class="line">save(手动挡)</span><br><span class="line">4.stop-writes-on-bgsave-error</span><br><span class="line">默认yes，出错了就刹车。</span><br><span class="line">5.rdbcompression yes</span><br><span class="line">是否启动压缩算法，LZF（如果你要节约cpu和内存耗损）则关闭，默认都用出厂设置。</span><br><span class="line">6.rdbchecksum</span><br><span class="line">在存储快照后，还可以让redis使用CRC64算法来进行数据校验，</span><br><span class="line">但这样会增加10%的性能消耗。继续用yes(mysql的checksum~)</span><br><span class="line"></span><br><span class="line">7.dbfilename</span><br><span class="line">叫dump.rdb</span><br><span class="line"></span><br><span class="line">8.dir</span><br><span class="line">config get dir可以获得，在哪里开启的该进程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># REPLICATION复制</span><br><span class="line"></span><br><span class="line"># security安全</span><br><span class="line">前提是认为内存缓存服务架构在一个安全加固环境里面</span><br><span class="line">所以出厂服务是不用输入密码</span><br><span class="line">config requirepass “123456”</span><br><span class="line">这样每次都要输入密码才能获取值。</span><br><span class="line"></span><br><span class="line"># limits回收机制</span><br><span class="line">1.maxclients 10000</span><br><span class="line">默认10000个人同时连接</span><br><span class="line">2.maxmemory</span><br><span class="line"></span><br><span class="line">3.maxmemory-policy当到达最大内存，你如何选择删除</span><br><span class="line">（考过，它的缓存过期配置如何理解配置）</span><br><span class="line">默认永不过期noeviction</span><br><span class="line">        对于内存移除规则来说， Redis 提供了多达6种的移除规则。他们是：</span><br><span class="line">        （1）volatile-lru：使用 LRU 算法移除过期集合中的 key</span><br><span class="line">        只对设置了过期时间的key</span><br><span class="line">        （2）allkeys-lru：使用 LRU 算法移除 key（所有）</span><br><span class="line">        （3）volatile-random：在过期集合中移除随机的 key</span><br><span class="line">        （4）allkeys-random：移除随机的 key</span><br><span class="line">        （5）volatile-ttl：移除那些 TTL 值最小的 key ，即那些最近要过期的 </span><br><span class="line">             key</span><br><span class="line">        （6）noeviction：不进行移除。针对写操作，只是返回错误信息</span><br><span class="line">        LRU:LAST RECENT USE最近最少使用</span><br><span class="line">        4.maxmemory-sample</span><br><span class="line">        LRU算法和最小TTL算法都并非是精确的算法，而是估算值。</span><br><span class="line">        所以可以设置样本的大小。假如Redis默认会检查三个key并选择其中LRU的那个，</span><br><span class="line">        那么可以改变这个key样本的数量。默认5个，3个精确度没那么高，但快。</span><br><span class="line">        maxmemory-samples 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="nosql" scheme="http://example.com/categories/nosql/"/>
    
    <category term="redis高级篇" scheme="http://example.com/categories/nosql/redis%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    
    
  </entry>
  
</feed>
